function AlarmService(sidebarDivID, sidebarDetailDivID){
    var i;

	this.sidebarDivID = sidebarDivID;					//ID of div wrapping left sidebar
	this.sidebarDetailDivID = sidebarDetailDivID;		//ID of div wrapping detail level sidebar elements
	this.canvasID = 'alarmCanvas';						//ID of canvas to draw alarms on
	this.pID = 'alarmText';								//ID of <p> to write alarm text in

    this.nCrates = window.parameters.moduleSizes.length;

	//arrays of info for state reporting - repopulated every loop
	this.demandVoltage = [];
	this.reportVoltage = [];
	this.reportCurrent = [];
	this.reportTemperature = [];
    for(i=0; i<this.nCrates; i++){
        this.demandVoltage[i] = [];
        this.reportVoltage[i] = [];
        this.reportCurrent[i] = [];
        this.reportTemperature[i] = [];
    }

	var that = this;

	//number of alarms to report:
	this.nAlarms = 200;

	//arrays to hold alarm info:
	this.voltageAlarms = [];
	this.currentAlarms = [];
	this.temperatureAlarms = [];
	this.rateAlarms = [];
    this.clockAlarms = [];

    //remember last message printed to the message log, only print when the message changes:
    this.lastMessage = ['', '', '', '', '']; //voltage, current, temperature, clock, rate

	//establish animation parameters:
    this.FPS = 30;
    this.duration = 0.3;
    this.nFrames = this.FPS*this.duration;

    //minimum height of detail-level canvas:
    this.minBKGheight = $('#'+window.parameters.wrapper).height()*0.9;
    //height of detail-level canvas in previous update:
    this.bkgCanvasHeight = this.minBKGheight;

	//DOM manipulation//////////////////////////////////////////////////////////

	//insert canvas into alarm div:
	/*
    this.wrapper = document.getElementById(this.sidebarDivID);
    this.canvasWidth = 0.8*$(this.wrapper).width();
    this.canvasHeight = 0.05*$(this.wrapper).height();
    insertCanvas(this.canvasID, 'alarmDetailBackground', 'z-index:-1;', this.canvasWidth, this.canvasHeight, this.divID);
	this.canvas = document.getElementById(this.canvasID);
	this.context = this.canvas.getContext('2d');
	*/
	//insert <p> into detail-level left div:
    injectDOM('p', this.pID, this.sidebarDetailDivID, {'class':'alarmPara'});
	//make detail paragraph disappear onclick:
	document.getElementById(this.pID).setAttribute('onclick', 'javascript:hideDetail()');
	//insert button to call out alarm detail:
    if(window.parameters.topDeployment.HV) 
        injectDOM('button', 'alarmDetailButton', this.sidebarDivID, {
            'class' : 'alarmButton',
            'onclick' : function(){showDetail()},
            'innerHTML' : 'Alarms'
        });
    //document.getElementById('alarmDetailButton').setAttribute('disabled', 'true');
	//end DOM manipulation//////////////////////////////////////////////////////

    //member functions/////////////////////////////////////////////////////////

    //sort the alarms by severity:
    this.sortAlarms = function(){

    	//define sort function:
    	function sortAlarms(a, b){
        	if (a[3] > b[3]) return -1;
        	if (a[3] < b[3]) return 1;
        	else return 0;
    	}

    	this.voltageAlarms.sort(sortAlarms);
    	this.currentAlarms.sort(sortAlarms);
    	this.temperatureAlarms.sort(sortAlarms);
    	this.rateAlarms.sort(sortAlarms);

    };

    //print the alarms to the <p>:
    this.printAlarms = function(){
    	var i, j,
    	    alarmText = '',
    	    slot = -1,
    	    channel = -1,
            messageLogText = '',
            MIDASalarms = ODBGetAlarms(),
            alarmClasses = [this.voltageAlarms, this.currentAlarms, this.temperatureAlarms, this.clockAlarms],
            alarmTitles = ['Voltage Alarms', 'Current Alarms', 'Temperature Alarms', 'Clock Alarms'],
            messageHeader = ['Voltage alarms thrown by ', 'Current alarms thrown by ', 'Temperature alarms thrown by ', 'Clock alarms '],
            ODBalarmLocations = ['/DashboardConfig/CustomAlarms/Voltage', '/DashboardConfig/CustomAlarms/Current', '/DashboardConfig/CustomAlarms/Temperature', '/DashboardConfig/CustomAlarms/Clock']


        //include all the MIDAS alarms:
        if(MIDASalarms.length > 0){
            alarmText += '<h2>MIDAS Alarms</h2>'
            for(i=0; i<MIDASalarms.length; i++){
                alarmText += MIDASalarms[i] + '<br><br>';
            }
        }

        //loop over alarm classes: voltage, current, temperature, clock
        for(j=0; j<4; j++){
            //prepare message block as needed:
            messageLogText = '';
            if(alarmClasses[j].length != 0){
                alarmText += '<h2>'+alarmTitles[j]+'</h2>';
                messageLogText = messageHeader[j];
            }
            //assemble error report:
            for(i=0; i<Math.min(alarmClasses[j].length, this.nAlarms); i++){
                if(j<3){  //HV crate alarms
                    slot = primaryBin(window.parameters.moduleSizes[alarmClasses[j][i][2]], alarmClasses[j][i][1]);
                    channel = channelMap(alarmClasses[j][i][1], alarmClasses[j][i][0], window.parameters.moduleSizes[alarmClasses[j][i][2]], window.parameters.rows + 1);
                    if(channel == -1){
                        alarmText += 'Slot ' + slot + ' Primary' + '<br>';  
                    } else
                        alarmText += 'Slot ' + slot + ', Ch. ' + channel + '<br>';

                    if(j==0){ //voltage
                        alarmText += 'Demand Voltage: ' + (this.demandVoltage[this.voltageAlarms[i][2]][this.voltageAlarms[i][0]][this.voltageAlarms[i][1]]).toFixed(window.parameters.alarmPrecision) + ' V<br>';
                        alarmText += 'Report Voltage: ' + (this.reportVoltage[this.voltageAlarms[i][2]][this.voltageAlarms[i][0]][this.voltageAlarms[i][1]]).toFixed(window.parameters.alarmPrecision) + ' V<br><br>';
                    } else if(j==1){ //current
                        alarmText += (this.reportCurrent[this.currentAlarms[i][2]][this.currentAlarms[i][0]][this.currentAlarms[i][1]]).toFixed(window.parameters.alarmPrecision) + ' uA<br><br>';
                    } else if(j==2){ //temperature
                        alarmText += (this.reportTemperature[this.temperatureAlarms[i][2]][this.temperatureAlarms[i][0]][this.temperatureAlarms[i][1]]).toFixed(window.parameters.alarmPrecision) + ' C<br><br>';
                    }

                    if(i>0) messageLogText += ', ';
                    messageLogText += (channel == -1) ? ('Slot ' + slot + ' Primary') : ('Slot ' + slot + ', Ch. ' + channel);
                } else if(j==3){ //clock
                    alarmText += this.clockAlarms[i]+'<br>';
                    if(i>0) messageLogText += ', ';
                    messageLogText += this.clockAlarms[i]+'<br>';
                }                
            }
            //raise alarm and throw message on error state change only:
            if(messageLogText != this.lastMessage[j]){
                if(messageLogText == '')
                    ODBSet(ODBalarmLocations[j], 0);
                else{    
                    ODBSet(ODBalarmLocations[j], 1);
                    //ODBGenerateMsg(messageLogText);
                    this.lastMessage[j] = messageLogText;
                }
            }
        }

    	if(alarmText != ''){
    		$('#alarmDetailButton').css('background-color', '#FF0000');
    	} else {
    		alarmText = 'All Clear';
    		$('#alarmDetailButton').css('background-color', '#999999');
    	}

    	alarmText += '<br><h4 style="text-align:center">Click to Dismiss</h4>'
    	this.updateText(alarmText);
    };

    //dump alarm data in preperation for next update:
    this.wipeAlarms = function(){
		this.voltageAlarms = [];
		this.currentAlarms = [];
		this.temperatureAlarms = [];
		this.rateAlarms = [];
        this.clockAlarms = [];
    };

    //update the text:
    this.updateText = function(content){
	    document.getElementById('alarmText').innerHTML = content;
    };

    this.publishAlarms = function(){
        this.sortAlarms();
        this.printAlarms();
        this.wipeAlarms();    
    };

}

function showDetail(){
	//tabBKG('LeftSidebarDetailBKG', 'left');

    //$('#LeftSidebarDetailBKG').css('z-index', '0');
    //$('#LeftSidebarDetailBKG').css('opacity', '1');

	$('#leftSidebarDetail').css('z-index', '10');
	$('#leftSidebarDetail').css('opacity', '1');

    $('#leftSidebar').css('z-index', '-1');
    $('#leftSidebar').css('opacity', '0');
}

function hideDetail(){
	$('#leftSidebarDetail').css('z-index', '-1');
	$('#leftSidebarDetail').css('opacity', '0');

    $('#leftSidebar').css('z-index', '10');
    $('#leftSidebar').css('opacity', '1');
}BAMBINO.prototype = Object.create(Subsystem.prototype);

function BAMBINO(spiceMode){
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'BAMBINO';
    var that = this;
    Subsystem.call(this);

    //need special implementation of prameter dialog, since the may be deployed as BAMBINO or SPICE AUX
    this.canvas.onclick = function(event){
        var name,
            y = event.pageY - that.canvas.offsetTop - that.monitor.offsetTop;
            name = (that.spiceAux) ? "SPICE Auxilliary" : "BAMBINO";
        if(y > that.canvasHeight - that.scaleHeight)
            parameterDialogue(name, [[name, ODB[that.name][that.constructMinMaxKey(that.name)][0], ODB[that.name][that.constructMinMaxKey(that.name)][1], window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/'+that.name+'/'+scaleType()+'[0]', '/DashboardConfig/'+that.name+'/'+scaleType()+'[1]']], window.parameters.subdetectorColors[window.state.subdetectorView]);
    }

    //make a pointer at window level back to this object, so we can pass by reference to the nav button onclick
    window.BAMBINOpointer = that;

    //change the button name if we're deploying in spice mode:
    if(ODB.SPICE.SPICEauxiliary)
        document.getElementById('BAMBINOlink').innerHTML = 'SPICE '+ODB.SPICE.SPICEauxiliary;
    //member variables///////////////////////////////////
    this.spiceAux = (spiceMode) ? 1 : 0;
    this.mode = (this.spiceAux) ? spiceMode : ODB.BAMBINO.mode;      //'S2' or 'S3'
    this.layers = (this.spiceAux) ? ODB.SPICE.SPICEauxLayers : ODB.BAMBINO.layers;

    this.dataBus = new BAMBINODS(this.mode, this.layers, spiceMode);

    this.nRadial = 24;
    if(this.mode=='S2')
    	this.nAzimuthal = 16;
    else if(this.mode=='S3')
        this.nAzimuthal = 32;

    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['BAMBINO'];

    //drawing parameters//////////////////////////////////////////////////
    this.centerX = this.canvasWidth/2;
    this.centerY = this.canvasHeight/2;
    this.CDinnerRadius = this.canvasWidth*0.01;
    this.CDradius = (this.layers == 1) ? this.canvasHeight*0.17 : this.canvasWidth*0.12;
    if(this.layers==1 && !(ODB.BAMBINO.USdeploy && ODB.BAMBINO.DSdeploy) )
        this.CDradius *= 1.5
    this.centerLeft = this.canvasWidth*0.25;
    this.centerRight = this.canvasWidth*0.75;
    this.centerLeftE = this.canvasWidth*0.13;
    this.centerLeftD = this.canvasWidth*0.375;
    this.centerRightD = this.canvasWidth*0.625;
    this.centerRightE = this.canvasWidth*0.87;
    this.centerTop = this.canvasHeight*0.2;
    this.centerBottom = this.canvasHeight*0.6;
    this.radialWidth = (this.CDradius - this.CDinnerRadius) / this.nRadial;
    this.azimuthalArc = 2*Math.PI / this.nAzimuthal;

    if(this.layers==1 && ODB.BAMBINO.DSdeploy==0)
        this.upstreamTitleCenter = this.canvasWidth/2;
    else if(this.layers==1)
        this.upstreamTitleCenter = this.centerLeft;
    else if(ODB.BAMBINO.DSdeploy==1)
        this.upstreamTitleCenter = (this.centerLeftD + this.centerLeftE)/2
    else
        this.upstreamTitleCenter = this.canvasWidth/2;

    if(this.layers==1 && ODB.BAMBINO.USdeploy==0)
        this.downstreamTitleCenter = this.canvasWidth/2;
    else if(this.layers==1)
        this.downstreamTitleCenter = this.centerRight;
    else if(ODB.BAMBINO.USdeploy==1)
        this.downstreamTitleCenter = (this.centerRightD + this.centerRightE)/2   
    else
        this.downstreamTitleCenter = this.canvasWidth/2;    

    //which detectors are present: [upstream layer D, downstream layer D, upstream layer E, downstream layer E];
    this.detPresent = [0,0,0,0]; 
    if(ODB.BAMBINO.USdeploy){
        this.detPresent[0] = 1
        if(this.layers == 2){
            this.detPresent[2] = 1   
        }
    }
    if(ODB.BAMBINO.DSdeploy){
        this.detPresent[1] = 1
        if(this.layers == 2){
            this.detPresent[3] = 1   
        }
    }    

    //member functions///////////////////////////////////////////////////////////////////

    this.draw = function(frame){

    	var i, j, m, x0, y0, name, fill;

    	this.context.strokeStyle = '#999999';
        this.TTcontext.strokeStyle = '#123456';

        //each layer -> 1 or 2 disks (up and downstream) times 2 sides (front and back).
        //index i counts upstream/layerD/front, upstream/layerD/back, downstream/layerD/front, downstream/layerD/back, etc incrementing layers.
    	for(i=0; i<4*this.layers; i++){ 
            //bail out if this iteration's disk isn't there:
            if(!this.detPresent[Math.floor(i/2)]) continue;

            //determine disk image center
            //upstream layer D front || back:
            if(i==0 || i==1){
                if(this.layers == 2){
                    x0 = this.centerLeftD; y0 = (i==0) ? this.centerTop : this.centerBottom;
                } else if(ODB.BAMBINO.DSdeploy){
                    x0 = this.centerLeft; y0 = (i==0) ? this.centerTop : this.centerBottom;
                } else{
                    x0 = (i==0) ? this.centerLeft : this.centerRight; y0 = this.canvasHeight*0.4;
                }
            } else if(i==2 || i==3){ //downstream layer D front || back:
                if(this.layers == 2 && !ODB.BAMBINO.USdeploy){
                    x0 = this.centerLeftD; y0 = (i==2) ? this.centerTop : this.centerBottom;
                } else if(this.layers==2){
                    x0 = this.centerRightD; y0 = (i==2) ? this.centerTop : this.centerBottom;
                } else if(ODB.BAMBINO.USdeploy){
                    x0 = this.centerRight; y0 = (i==2) ? this.centerTop : this.centerBottom;
                } else{
                    x0 = (i==2) ? this.centerLeft : this.centerRight; y0 = this.canvasHeight*0.4;
                }
            } else if(i==4 || i==5){ //upstream layer E front || back:
                if(ODB.BAMBINO.DSdeploy){
                    x0 = this.centerLeftE; y0 = (i==4) ? this.centerTop : this.centerBottom;
                } else{
                    x0 = this.centerRightD; y0 = (i==4) ? this.centerTop : this.centerBottom;
                }
            } else if(i==6 || i==7){ //downstream layer E front || back:
                if(ODB.BAMBINO.USdeploy){
                    x0 = this.centerRightE; y0 = (i==6) ? this.centerTop : this.centerBottom;
                } else{
                    x0 = this.centerRightD; y0 = (i==6) ? this.centerTop : this.centerBottom;
                }
            }

            //fronts    
	    	if(i%2 == 0){

	    		for(j=0; j<this.nRadial; j++){
                    //name = ((this.spiceAux) ? 'SP' : 'BA' ) + ((this.mode=='S2') ? 'Z0' : 'E0') + ( (this.spiceAux) ? 0 : Math.floor((i%4)/2)+1) + this.dataBus.waypoints[Math.floor(i/4)] + 'P' +( (j<10) ? '0'+j : j ) + 'X';
                    if(i==2 || i==6) //downstream fronts count 0 on the inside to 23 on the outside
                        name = ((this.spiceAux) ? 'SP' : 'BA' ) + ((this.mode=='S2') ? 'Z0' : 'E0') + ( (this.spiceAux) ? 0 : Math.floor((i%4)/2)+1) + this.dataBus.waypoints[Math.floor(i/4)] + 'P' + ((this.nRadial-1-j < 10) ? '0'+(this.nRadial-1-j) : this.nRadial-1-j) + 'X';
                    else //upstream fronts count 0 on the outside to 23 on the inside
                        name = ((this.spiceAux) ? 'SP' : 'BA' ) + ((this.mode=='S2') ? 'Z0' : 'E0') + ( (this.spiceAux) ? 0 : Math.floor((i%4)/2)+1) + this.dataBus.waypoints[Math.floor(i/4)] + 'P' +( (j<10) ? '0'+j : j ) + 'X';
                    
    				this.context.beginPath()
                    fill = colors(name, this.dataBus.BAMBINO, frame, this.nFrames);
                    this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
	    			this.context.arc(x0, y0, this.CDradius - j*this.radialWidth, 0, 2*Math.PI);
	    			this.context.closePath();
    				this.context.fill();
	    			this.context.stroke();

                    //and again for tooltip:
                    if(!this.TTlayerDone){
                        this.TTcontext.fillStyle = 'rgba('+this.dataBus.BAMBINO[name].index+','+this.dataBus.BAMBINO[name].index+','+this.dataBus.BAMBINO[name].index+',1)';
                        this.TTcontext.beginPath();
                        this.TTcontext.arc(x0, y0, this.CDradius - j*this.radialWidth, 0, 2*Math.PI);
                        this.TTcontext.closePath();
                        this.TTcontext.fill();
                        this.TTcontext.stroke();
                    }
    			}
                //clear inner circle:
                this.context.fillStyle = '#333333';
                this.context.beginPath();
                this.context.arc(x0, y0, this.CDradius - j*this.radialWidth, 0, 2*Math.PI);
                this.context.closePath();
                this.context.fill(); 
                //and again in TT:
                if(!this.TTlayerDone){
                    this.TTcontext.fillStyle = '#987654';
                    this.TTcontext.beginPath();
                    this.TTcontext.arc(x0, y0, this.CDradius - j*this.radialWidth, 0, 2*Math.PI);
                    this.TTcontext.closePath();
                    this.TTcontext.fill();
    		    }	
            //backs
    		} else {
    
	    		for(j=0; j<this.nAzimuthal; j++){
                    name = ((this.spiceAux) ? 'SP' : 'BA' ) + ((this.mode=='S2') ? 'Z0' : 'E0') + ( (this.spiceAux) ? 0 : Math.floor((i%4)/2)+1) + this.dataBus.waypoints[Math.floor(i/4)] + 'N' +( (j<10) ? '0'+j : j ) + 'X';
    				this.context.beginPath()
                    fill = colors(name, this.dataBus.BAMBINO, frame, this.nFrames);
                    this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
                    
                    this.context.moveTo(x0 + this.CDinnerRadius*Math.cos(j*this.azimuthalArc), y0 - this.CDinnerRadius*Math.sin(j*this.azimuthalArc));
                    this.context.arc(x0,y0, this.CDinnerRadius, -j*this.azimuthalArc, -(j+1)*this.azimuthalArc, true);
                    this.context.lineTo(x0 + this.CDradius*Math.cos((j+1)*this.azimuthalArc), y0 - this.CDradius*Math.sin((j+1)*this.azimuthalArc));
                    this.context.arc(x0,y0, this.CDradius, -(j+1)*this.azimuthalArc, -j*this.azimuthalArc, false);
    				this.context.closePath();
    				this.context.fill();
	    			this.context.stroke();
                    
                    //and again for tooltip:
                    if(!this.TTlayerDone){
                        this.TTcontext.fillStyle = 'rgba('+this.dataBus.BAMBINO[name].index+','+this.dataBus.BAMBINO[name].index+','+this.dataBus.BAMBINO[name].index+',1)';
                        this.TTcontext.beginPath();
                        this.TTcontext.moveTo(x0 + this.CDinnerRadius*Math.cos(j*this.azimuthalArc), y0 - this.CDinnerRadius*Math.sin(j*this.azimuthalArc));
                        this.TTcontext.arc(x0,y0, this.CDinnerRadius, -j*this.azimuthalArc, -(j+1)*this.azimuthalArc, true);
                        this.TTcontext.lineTo(x0 + this.CDradius*Math.cos((j+1)*this.azimuthalArc), y0 - this.CDradius*Math.sin((j+1)*this.azimuthalArc));
                        this.TTcontext.arc(x0,y0, this.CDradius, -(j+1)*this.azimuthalArc, -j*this.azimuthalArc, false);
                        this.TTcontext.closePath();
                        this.TTcontext.fill();
                        this.TTcontext.stroke();                  
                    }

    			}

    		}
    	}

        if(frame==this.nFrames || frame==0) {
            //scale
            this.drawScale(this.context);
    	    //titles
            this.context.clearRect(0,0.80*this.canvasHeight,this.canvasWidth,0.20*this.canvasHeight - this.scaleHeight);
            this.context.fillStyle = '#999999';
            this.context.font="24px 'Orbitron'";
            if(ODB.BAMBINO.USdeploy) this.context.fillText('Upstream', this.upstreamTitleCenter - this.context.measureText('Upstream').width/2, 0.85*this.canvasHeight);
            if(ODB.BAMBINO.DSdeploy) this.context.fillText('Downstream', this.downstreamTitleCenter - this.context.measureText('Downstream').width/2, 0.85*this.canvasHeight);
        }

        this.TTlayerDone = 1;

    };

    //do an initial populate:
    //this.update();

}function BarGraph(cvas, moduleNumber, nBars, title, yAxisTitle, scaleMin, scaleMax, barChartPrecision, masterWaffle, crate){

	var i;

	//which crate is this card in?
	this.crate = crate;

	this.dataBus = new HVBarDS();

	//bar chart levels:
	this.oldLevels = [];
	this.levels = [];

	//alarms:
	this.oldAlarms = [];
	this.alarms = [];

	//module index:
	this.modIndex = moduleNumber;

	//scale:
	this.scaleMin = scaleMin;
	this.scaleMax = scaleMax;

	//number of y-axis scale ticks:
	this.yAxisTicks = 6;

	//precision:
	this.precision = barChartPrecision;

	//waffle of which these meters are a subset:
	this.masterWaffle = masterWaffle;

	//chart title:
	this.title = title;

	//y-axis title:
	this.yAxisTitle = yAxisTitle;

	//color, [R,G,B,A]:
	this.oldColor = [255,0,0,1];
	this.color = [0,0,0,1];

    //fetch canvas:
    this.cvas = cvas;
    this.canvas = document.getElementById(cvas);
    this.context = this.canvas.getContext('2d');

    //canvas dimensions:
    this.width = masterWaffle.totalWidth;
    this.height = masterWaffle.waffleHeight[crate];
    this.headerHeight = masterWaffle.headerHeight[crate];
    $('#'+cvas).attr('width', this.width);
    $('#'+cvas).attr('height', this.height);
    //$('#'+cvas).css('top', this.headerHeight);

    //determine optimal font sizes for labels:
    //determine longest y-axis tick label:
    this.context.font="12px 'Raleway'"; 
    var longestLabel = 0;
    var longestLabelIndex = 0;
    for(i=0; i<this.yAxisTicks; i++){
    	if(this.context.measureText( ((this.scaleMax-this.scaleMin)/(this.yAxisTicks-1)*i).toFixed(this.precision) ).width > longestLabel){
	    	longestLabel = Math.max(longestLabel, this.context.measureText( ((this.scaleMax-this.scaleMin)/(this.yAxisTicks-1)*i).toFixed(this.precision) ).width);
	    	longestLabelIndex = i;
	    }
    }
    //seek largest fontsize such that the longest label + height of y axis title fit into margin:
    this.fontscale = 1;
    this.context.font=this.fontscale+"px 'Raleway'";
    while( this.context.measureText( ((this.scaleMax-this.scaleMin)/(this.yAxisTicks-1)*longestLabelIndex).toFixed(this.precision) ).width + 2*this.fontscale < 0.1*this.width/2 ){
    	this.fontscale++ 
	    this.context.font=this.fontscale+"px 'Raleway'";
	}

    //number of bars:
    this.nBars = nBars;

    //channel names:
    this.channelNames = [];

    //bar width:
    this.barWidth = this.width*0.8 / (1.05*nBars);
    //vertical margins:
    this.topMargin = 0.1*this.height;
    this.bottomMargin = 0.2*this.height;
    //bar max height:
    this.barMax = this.height - this.topMargin - this.bottomMargin;

    //animation parameters:
    this.duration = 0.5; //seconds
    this.FPS = 30;
    this.nFrames = this.duration*this.FPS;

    //initialize arrays:
    for(var i = 0; i<nBars; i++){
    	this.oldLevels[i] = 0.01;
    	this.levels[i] = 0.01;
    	this.oldAlarms[i] = [0,0,0];
    	this.alarms[i] = [0,0,0];
    	this.channelNames[i] = i;
    }

    //make barchart clickable to set a variable for a channel:
    var that = this;
    this.canvas.onclick = function(event){clickBarChart(event, that)};

	//define the onclick behavior of the bar chart:
	function clickBarChart(event, obj){

        window.refreshInput = 1;

		var superDiv = document.getElementById(obj.masterWaffle.wrapperDiv);

        var module = obj.modIndex;
        var channel = Math.floor((event.pageX - superDiv.offsetLeft -  obj.canvas.offsetLeft - obj.width*0.1)/(1.05*obj.barWidth));
        var gridCoords = getPointer(module, channel, obj.masterWaffle, window.HVview);

        if(gridCoords[1]<obj.masterWaffle.cols[obj.crate] && gridCoords[0]>0 && gridCoords[0]<obj.masterWaffle.rows && channel<obj.nBars && window.onDisplay == obj.cvas){
            obj.masterWaffle.chx = gridCoords[1];
            obj.masterWaffle.chy = gridCoords[0];
            channelSelect(obj.masterWaffle);
        }

	}

	//draw a frame of a bar chart transition from previous levels to new levels:
	this.draw = function(frame){

		var i = 0;
		var leftEdge = this.width*0.1; //left edge of the first bar
		var barTop;
		var barHeight;

		//clear old canvas:
		this.context.clearRect(0, 0, this.width, this.height);

		//loop over bars:
		for(i=0; i<this.nBars; i++){
			barHeight = this.oldLevels[i]*this.barMax + (this.levels[i] - this.oldLevels[i])*this.barMax*frame/this.nFrames;
			barTop = this.height - this.bottomMargin - barHeight;
			this.context.fillStyle = '#FFFFFF';
			this.context.fillRect(leftEdge, barTop, this.barWidth, barHeight);			
			this.context.fillStyle = this.colorGradient(i, frame);
			this.context.fillRect(leftEdge, barTop, this.barWidth, barHeight);
			this.context.strokeRect(leftEdge, barTop, this.barWidth, barHeight);
			leftEdge += 1.05*this.barWidth;
		}

		//redraw frame:
		this.drawFrame();

	};

    //wrapper for transition from old state to new state via this.animate:
    this.update = function(newLevel, alarmStatus){

        //set up member variables for animation:
        this.setNewLevels(newLevel, alarmStatus);

        //animate:
        this.animate(this, 0);

    };

    //manage animation
    this.animate = function(){
        if(window.onDisplay == this.cvas) animate(this, 0);
    };

	//set new levels:
	this.setNewLevels = function(data, alarmStatus){

		//data must have one entry for each bar:
		if(data.length !== this.nBars){ 
			alert('Pass exactly one value to the bar chart for each bar on update!');
			return;
		}

		//loop over bars:
		for(var i=0; i<this.nBars; i++){
			//adjust scaleMax:
			if(data[i] > this.scaleMax)
				this.scaleMax = data[i];

			this.oldLevels[i] = this.levels[i];
			this.levels[i] = (data[i] - this.scaleMin) / (this.scaleMax - this.scaleMin);
			if(this.levels[i] <= 0.01) this.levels[i] = 0.01;
			if(this.levels[i] > 1) this.levels[i] = 1;

			for(var j=0; j<3; j++){
				this.oldAlarms[i][j] = this.alarms[i][j];
				this.alarms[i][j] = alarmStatus[i][j];
			}
		}


	};

	//draw axes and decorations:
	this.drawFrame = function(){

		var i = 0,
		longestyLabel = 0;

		//set label font:
		this.context.font=this.fontscale+"px Raleway";         ///Math.min(16, 0.8*this.barWidth)+"px 'Raleway'";    //0.25*this.barWidth+"px 'Raleway'";

		//set text color:
		this.context.fillStyle = 'rgba(255,255,255,0.3)';
		this.context.strokeStyle = 'rgba(255,255,255,0.3)';

		//draw principle axes:
		this.context.beginPath();
		this.context.moveTo(this.width*0.9, this.height - this.bottomMargin);
		this.context.lineTo(this.width*0.1, this.height - this.bottomMargin);
		this.context.lineTo(this.width*0.1, this.topMargin);
		this.context.stroke();

		//draw x-axis labels:
		for(i=0; i<this.nBars; i++){
			this.context.save();
			this.context.translate(this.width*0.1+(i+0.6)*1.05*this.barWidth,this.height - 0.9*this.bottomMargin);
			this.context.rotate(-Math.PI/2);  // -pi/2.4
			this.context.textAlign = 'right';
			this.context.fillText(this.channelNames[i], 0, 0);
			this.context.restore();
		}

		//draw y-axis ticks and labels:
		var yLabel;
		for(i=0; i<this.yAxisTicks; i++){
			this.context.beginPath();
			this.context.moveTo(this.width*0.1, this.height - this.bottomMargin - i*(this.height - this.topMargin - this.bottomMargin)/(this.yAxisTicks-1) );
			this.context.lineTo(this.width*0.1 - 10, this.height - this.bottomMargin - i*(this.height - this.topMargin - this.bottomMargin)/(this.yAxisTicks-1) );
			this.context.stroke();
			yLabel = ((this.scaleMax-this.scaleMin)/(this.yAxisTicks-1)*i).toFixed(this.precision);
			if(this.context.measureText(yLabel).width > longestyLabel) longestyLabel = this.context.measureText(yLabel).width;
			this.context.fillText( yLabel,  this.width*0.1 - this.context.measureText(yLabel).width - 10, this.height - this.bottomMargin - i*(this.height - this.topMargin - this.bottomMargin)/(this.yAxisTicks-1) + 5);
		}

		//draw y-axis title:
		this.context.font= 1.5*this.fontscale+'px Raleway';   //Math.max(0.4*this.barWidth,26)+"px 'Raleway'";
		this.context.save();
		this.context.translate(this.width*0.1-10-longestyLabel-10, this.topMargin + this.context.measureText(this.yAxisTitle).width);
		this.context.rotate(-Math.PI/2);
		this.context.fillText(this.yAxisTitle, 0, 0);
		this.context.restore();

		//draw chart title:
		this.context.font=Math.max(0.7*this.barWidth,42)+"px 'Raleway'";
		this.context.fillText(this.title, this.width*0.9 - this.context.measureText(this.title).width, this.height - 0.35*this.bottomMargin);

	};

	//determine the color for this bar at <frame>
	this.colorGradient = function(index, frame){
		var R, G, B, A;

		if(this.oldAlarms[index][0] == 0 && this.oldAlarms[index][1] == 0 && this.oldAlarms[index][2] == 0){
			this.oldColor = [0,255,0,0.3];
		} else if(this.oldAlarms[index][0] == -1){
			this.oldColor = [0,0,0,0.3];
		} else if(this.oldAlarms[index][0] == -2){
			this.oldColor = [255,255,0,0.3];
		} else if(this.oldAlarms[index][0] == -3){
			this.oldColor = [0,0,255,0.5];
		} else {
			this.oldColor = [255,0,0, Math.max(this.oldAlarms[index][0], this.oldAlarms[index][1], this.oldAlarms[index][2])*0.7 + 0.3];
		}

		if(this.alarms[index][0] == 0 && this.alarms[index][1] == 0 && this.alarms[index][2] == 0){
			this.color = [0,255,0,0.3];
		} else if(this.alarms[index][0] == -1){
			this.color = [0,0,0,0.3];
		} else if(this.alarms[index][0] == -2){
			this.color = [255,255,0,0.3];
		} else if(this.alarms[index][0] == -3){
			this.color = [0,0,255,0.5];
		} else {
			this.color = [255,0,0, Math.max(this.alarms[index][0], this.alarms[index][1], this.alarms[index][2])*0.7 + 0.3];
		}

		R = this.oldColor[0] + (this.color[0] - this.oldColor[0])*frame/this.nFrames;
		G = this.oldColor[1] + (this.color[1] - this.oldColor[1])*frame/this.nFrames;
		B = this.oldColor[2] + (this.color[2] - this.oldColor[2])*frame/this.nFrames;
		A = this.oldColor[3] + (this.color[3] - this.oldColor[3])*frame/this.nFrames;

		return 'rgba('+R+', '+G+', '+B+', '+A+')'
	};

    this.animate = function(){
        if(window.onDisplay == this.cvas /*|| window.freshLoad*/) animate(this, 0);
        else this.draw(this.nFrames);
    };

}function Clock(){
    var i, cellSize, clockStyle,
    that = this;
    window.clockPointer = that;

	this.wrapperID = window.parameters.wrapper;	    //ID of wrapping div
	this.canvasID = 'ClockCanvas';		            //ID of canvas to paint clock on
    this.linkWrapperID = 'ClockLinks';              //ID of div to contain clock view header
    this.sidebarID = 'ClockSidebar';                //ID of div to contain clock sidebar
    this.activeElt = 'clock0';
    this.noUniqueMaster = 0;
    this.masterFreq = 100;  //master steps down from 200MHz in the spec, but seems to be 100 in practice?  TBD.
    this.channelTitles = ['eSATA 0', 'eSATA 1', 'eSATA 2', 'eSATA 3', 'eSATA 4', 'eSATA 5', 'Left LEMO', 'Right LEMO'];

	this.wrapper = document.getElementById(this.wrapperID);

    //add top level nav button:
    injectDOM('button', 'ClockButton', 'statusLink', {
        'class' : 'navLink',
        'onclick' : function(){swapView('ClockLinks', 'ClockCanvas', 'clockMenus', 'ClockButton');},
        'innerHTML' : 'Clock'
    });

    //deploy right bar menu:
    deployMenu('clockMenus', ['summary', 'outs', 'CSAC'] , ['Clock Summary','Channel Outs','CSAC Parameters']);
    //inject table into div for summary tab:
    injectDOM('table', 'summaryContentTable', 'summaryContent', {'class' : 'sidebarTable'});
    for(i=1; i<10; i++){
        label = window.parameters.clockVariableNames[i];
        injectDOM('tr', 'summaryContentRow'+i, 'summaryContentTable', {});
        injectDOM('td', 'clockSummaryLabel'+i, 'summaryContentRow'+i, {'innerHTML' : label});
        injectDOM('td', 'clockSummaryValue'+i, 'summaryContentRow'+i, {'class' : (i==4) ? 'summaryContentCell' : ''});
    }    
    //inject table for CSAC tab:
    injectDOM('table', 'CSACContentTable', 'CSACContent', {'class' : 'sidebarTable'});
    for(i=43; i<54; i++){
        label = window.parameters.clockVariableNames[i];
        injectDOM('tr', 'CSACContentRow'+i, 'CSACContentTable', {});
        injectDOM('td', 'clockCSACLabel'+i, 'CSACContentRow'+i, {'innerHTML' : label});
        injectDOM('td', 'clockCSACValue'+i, 'CSACContentRow'+i, {});
    }
    //Channel outs packed as 8 badges, with master step down slider at the top:
    injectDOM('div', 'outsContentmasterStepdownSliderDiv', 'outsContent', {
        'style' : 'display:block;',
        'innerHTML' : 'Master Output Freq.<br>'
    });
    injectDOM('input', 'outsContentmasterStepdownSlider', 'outsContentmasterStepdownSliderDiv', {'type' : 'range'});
    injectDOM('label', 'outsContentLabel', 'outsContentmasterStepdownSliderDiv', {
        'style' : 'padding-left:0.5em;',
        'innerHTML' : ' MHz'
    });

    document.getElementById('outsContentLabel').setAttribute('for', 'outsContentmasterStepdownSlider');
    document.getElementById('outsContentmasterStepdownSlider').setAttribute('min', 1); 
    document.getElementById('outsContentmasterStepdownSlider').setAttribute('max', 10);
    document.getElementById('outsContentmasterStepdownSlider').setAttribute('value', 11-parseInt(window.localODB['clock'+findMaster()][11],10) );
    document.getElementById('outsContentLabel').innerHTML = (this.masterFreq / (1-(document.getElementById('outsContentmasterStepdownSlider').valueAsNumber - parseInt(document.getElementById('outsContentmasterStepdownSlider').max,10)-1))  ).toFixed(1) + ' MHz';
    document.getElementById('outsContentmasterStepdownSlider').onchange = function(){
        var stepdown = -(this.valueAsNumber - parseInt(this.max,10)-1),
            freqOut = window.clockPointer.masterFreq / (1+stepdown), 
            i, masterConfig=[];
            window.clockPointer.masterFreqOut = freqOut;

        document.getElementById('outsContentLabel').innerHTML = freqOut.toFixed(1) + ' MHz';
        for(i=0; i<8; i++){
            document.getElementById('frequencyOut'+i).innerHTML = freqOut.toFixed(1) + ' MHz out'
        }

        //commit new stepdown to ODB:
        for(i=0; i<window.localODB['clock0'].length; i++){
            masterConfig[i] = window.localODB[window.clockPointer.activeElt][i];
        }
        for(i=0; i<8; i++){
            masterConfig[11+4*i] = stepdown;
            masterConfig[12+4*i] = stepdown;
        }
        ODBSet('/Equipment/GRIF-Clk'+window.clockPointer.activeElt.slice(5, window.clockPointer.activeElt.length)+'/Variables/Output[*]', masterConfig);
        window.localODB[window.clockPointer.activeElt] = masterConfig;
    };
    for(i=0; i<8; i++){
        injectDOM('div', 'outsContentBadge'+i, 'outsContent', {'class':'clockOutputBadge', 'innerHTML':this.channelTitles[i]+'<br>'});
        //power toggles, don't apply to ch. 5 and 6 (LEMO)
        if(i!=6 && i!=7)
            toggleSwitch('outsContentBadge'+i, 'ch'+i+'Toggle', 'off', 'on', 'on', enableChannel.bind(null,i), disableChannel.bind(null,i), 0);

        //output frequency report
        injectDOM('p', 'frequencyOut'+i, 'outsContentBadge'+i, {'style':'margins:0px; margin-top:1em;'});

        //bypass reporting:
        injectDOM('p', 'bypassReport'+i, 'outsContentBadge'+i, {'style':'margin:0px; margin-top:1em'})

        if(i%2==1)
            injectDOM('br', 'break', 'outsContent', {});
    }
    document.getElementById('outsContentmasterStepdownSlider').onchange();

    //nav wrapper div
    injectDOM('div', this.linkWrapperID, this.wrapperID, {
        'class' : 'navPanel',
        'style' : 'text-align:center; width:50%; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;'
    })
    //nav header
    injectDOM('h1', 'ClockLinksBanner', this.linkWrapperID, {
        'class' : 'navPanelHeader',
        'style' : 'float:left; margin-top:0px;',
        'innerHTML' : ODB.topLevel.expName+' Clock Status'
    });

    //the clock view is done entirely with dom elements; most convenient to extend the central div to accommodate.
    cellSize = document.getElementById(this.linkWrapperID).offsetWidth / 100;
    //clock divs
    injectDOM('div', 'clockWrapper', this.linkWrapperID, {'style' : 'clear:left'});
    for(i=0; i<window.parameters.nClocks; i++){
        clockStyle = 'display:inline-block; margin-left:'+(2*cellSize)+'px; margin-right:'+(2*cellSize)+'px; margin-bottom:'+2*cellSize+'px; margin-top:'+2*cellSize+'px;'
        injectDOM('div', 'clock'+i, 'clockWrapper', {
            'class' : 'clock',
            'style' : clockStyle,
            'onclick' : function(){showClock(this.id)}
        });
        injectDOM('div', 'clock'+i+'title', 'clock'+i, {'innerHTML':'GRIF-Clk'+i});
        toggleSwitch('clock'+i, 'clock'+i+'Toggle', '', 'Master', 'Slave', setMaster.bind(null,i), setSlave.bind(null,i), parseInt(window.localODB['clock'+i][1],10));
        if(i%5==4)
            injectDOM('br', 'break', 'clockWrapper', {});
    }

	//deploy a canvas for the clock view; this is actually just a dummy to stay consistent with all the other views, so we can use the same transition functions easily.
    injectDOM('canvas', this.canvasID, this.wrapperID, {
        'class' : 'monitor',
        'width' : 1,
        'height': 1,
        'style' : 'top:' + ($('#ClockLinks').height() + 5) +'px;'
    });

    //update the text & alarms for each clock
    this.update = function(){
        var i, clock, clockData, flag, alarmString, clockAlarms = [];

        //check to make sure exactly one clock claims to be the master:
        this.noUniqueMaster = 0;
        for(i=0; i<window.parameters.nClocks; i++){
            if(window.localODB['clock'+i][1] == 1)
                this.noUniqueMaster++;
        }
        if(this.noUniqueMaster != 1)
            this.noUniqueMaster = 1;
        else
            this.noUniqueMaster = 0;

        //update text for whatever clock is showing:
        showClock(this.activeElt);

        //update alarm status
        //unset all stale alarms:
        for(i=0; i<window.parameters.nClocks; i++){
            unsetClockAlarm('clock'+i);
        }

        //no unique master alarm://////////////////////////////////////////////////
        if(this.noUniqueMaster){
            clockAlarms = [];
            //set master bin and all slaves claiming to be masters to red:
            for(i=0; i<window.parameters.nClocks; i++){
                if(parseInt(window.localODB['clock'+i][1],10)){
                    setClockAlarm('clock'+i);
                    clockAlarms[clockAlarms.length] = 'GRIF-Clk '+i;
                }
            }

            alarmString = 'Exactly one clock must claim to be the Master.  Currently, ';
            if(clockAlarms.length == 0){
                alarmString += 'none are claiming to be Master.';
                for(i=0; i<window.parameters.nClocks; i++){
                    setClockAlarm('clock'+i);
                }                
            }
            else{
                for(i=0; i<clockAlarms.length; i++){
                    alarmString += clockAlarms[i];
                    if(i==clockAlarms.length-2)
                        alarmString += ' and '
                    else if(i!=clockAlarms.length-1)
                        alarmString += ', '
                }
                if(clockAlarms.length == 2)
                    alarmString += ' are both claiming to be Master.<br>'
                else
                    alarmString += ' are all claiming to be Master.<br>'
            }
            window.AlarmServices.clockAlarms[window.AlarmServices.clockAlarms.length] = alarmString;
        }

        //consistency alarms////////////////////////////////////////////////////////
        for(i=0; i<window.parameters.nClocks; i++){
            clockData = window.localODB['clock'+i];
            if(clockData[1] == 1){  //check that something that says it's a master looks like a master
                flag = 0;
                if(clockData[2] != 1) flag = 1;     //Master has NIM input
                if(clockData[3] != 1) flag = 1;     //Master has NIM input
                //if(clockData[4] != 1) flag = 1;     //Master has NIM input
                if(clockData[13] != 0) flag = 1;    //Master should not bypass itelf on any channel:
                if(clockData[17] != 0) flag = 1;
                if(clockData[21] != 0) flag = 1;
                if(clockData[25] != 0) flag = 1;
                if(clockData[29] != 0) flag = 1;
                if(clockData[33] != 0) flag = 1;
                if(clockData[37] != 0) flag = 1;
                if(clockData[41] != 0) flag = 1;
            } else {  //check that something that says it's a slave looks like a slave.
                flag = 0;
                if(clockData[2] != 0) flag = 2;     //Master has NIM input
                if(clockData[3] != 0) flag = 2;     //Master has NIM input
                //if(clockData[4] != 0) flag = 2;     //Master has NIM input
                if(clockData[13] != 1) flag = 2;    //Master should not bypass itelf on any channel:
                if(clockData[17] != 1) flag = 2;
                if(clockData[21] != 1) flag = 2;
                if(clockData[25] != 1) flag = 2;
                if(clockData[29] != 1) flag = 2;
                if(clockData[33] != 1) flag = 2;
                if(clockData[37] != 1) flag = 2;
                if(clockData[41] != 1) flag = 2;
            }
            if(flag==1){
                alarmString = 'GRIF-Clk '+i+' claims to be a Master, but some of its parameters make it look like a Slave.<br>'  
                setClockAlarm('clock'+i);            
            } else if(flag==2){
                alarmString = 'GRIF-Clk '+i+' claims to be a Slave, but some of its parameters make it look like a Master.<br>'
                setClockAlarm('clock'+i);
            }
            if(flag!=0)
                window.AlarmServices.clockAlarms[window.AlarmServices.clockAlarms.length] = alarmString;
        }

    };

    //initial populate, and default the summary tab to open:
    this.update();
    document.getElementById('summaryarrow').onclick();
    //make sure no double counting in the alarm service:
    window.AlarmServices.wipeAlarms();

}

function setMaster(n){
    var i, masterConfig = []
    for(i=0; i<window.localODB['clock0'].length; i++){
        masterConfig[i] = window.localODB['clock'+n][i];
    }
    masterConfig[1] = 1;
    masterConfig[2] = 1;
    masterConfig[3] = 1;
    //masterConfig[4] = 1;
    masterConfig[13] = 0;
    masterConfig[17] = 0;
    masterConfig[21] = 0;
    masterConfig[25] = 0;
    masterConfig[29] = 0;
    masterConfig[33] = 0;
    masterConfig[37] = 0;
    masterConfig[41] = 0;

    ODBSet('/Equipment/GRIF-Clk'+n+'/Variables/Output[*]', masterConfig);
    window.localODB['clock'+n] = masterConfig;
    rePaint();
}

function setSlave(n){
    var i, slaveConfig = []
    for(i=0; i<window.localODB['clock0'].length; i++){
        slaveConfig[i] = window.localODB['clock'+n][i];
    }
    slaveConfig[1] = 0;
    slaveConfig[2] = 0;
    slaveConfig[3] = 0;
    //slaveConfig[4] = 0;
    slaveConfig[13] = 1;
    slaveConfig[17] = 1;
    slaveConfig[21] = 1;
    slaveConfig[25] = 1;
    slaveConfig[29] = 1;
    slaveConfig[33] = 1;
    slaveConfig[37] = 1;
    slaveConfig[41] = 1;

    ODBSet('/Equipment/GRIF-Clk'+n+'/Variables/Output[*]', slaveConfig);
    window.localODB['clock'+n] = slaveConfig;
    rePaint();
}

//turn on all four bits corresponding to the ith eSATA channel
function enableChannel(i){
    var newSettingWord = window.localODB[window.clockPointer.activeElt][0],
    clockNo = window.clockPointer.activeElt.slice(5, window.clockPointer.activeElt.length);
    newSettingWord = newSettingWord | (0xF << 4*i);
    //push to ODB
    ODBSet('/Equipment/GRIF-Clk'+clockNo+'/Variables/Output[0]', newSettingWord);
    //push to localODB:
    window.localODB['clock'+clockNo][0] = newSettingWord;
}

function disableChannel(i){
    var newSettingWord = window.localODB[window.clockPointer.activeElt][0],
    clockNo = window.clockPointer.activeElt.slice(5, window.clockPointer.activeElt.length);
    newSettingWord = newSettingWord & ~(0xF << 4*i);
    //push to ODB
    ODBSet('/Equipment/GRIF-Clk'+clockNo+'/Variables/Output[0]', newSettingWord);
    //push to localODB:
    window.localODB['clock'+clockNo][0] = newSettingWord;
}

//do something when a clock alarm is detected
function setClockAlarm(id){
    var clock =document.getElementById(id);
    clock.style.borderColor = "#FF0000";
}

//do something else when a clock alarm is unset
function unsetClockAlarm(id){
    var clock =document.getElementById(id);
    //clock.style['border-color'] = "#88FF88";  //okay in Chrome, does nothing in FF!
    clock.style.borderColor = "#88FF88";        //camel case versions of names are spec standard, Chrome and IE give CSS-literal option as a bonus.
    //$('#'+id).css('border-color', '#88FF88');  //Zepto works too

}

//set the master to use the LEMO as its reference
function masterLEMO(id){
    //push to the ODB:
    ODBSet('/Equipment/GRIF-Clk'+id.slice(5,id.length)+'/Variables/Output[4]', 1);
    //push to localODB so we don't actually have to re-fetch:
    window.localODB['clock'+id.slice(5,id.length)][4] = 1;
    //document.getElementById('clockSummaryValue3').innerHTML = '10 MHz'
    //document.getElementById('outsContentmasterStepdownSlider').onchange();
    //rePaint();
}

//set the master to use the atomic clock as its reference
function masterAC(id){
    //push to ODB:
    ODBSet('/Equipment/GRIF-Clk'+id.slice(5,id.length)+'/Variables/Output[4]', 0);
    //push to local ODB:
    window.localODB['clock'+id.slice(5,id.length)][4] = 0;
    //document.getElementById('clockSummaryValue3').innerHTML = '10 MHz';
    //document.getElementById('outsContentmasterStepdownSlider').onchange();
    //rePaint();
}

//deploy the input field for master input frequency:
function masterInputFrequency(targetID){
    document.getElementById(targetID).innerHTML = '10 MHz' //'<input id="summaryContentMasterLEMOfreq" type="number" min=0 value='+window.localODB.masterLEMOfreq+'></input>';
    /*
    document.getElementById('summaryContentMasterLEMOfreq').onchange = function(){
        ODBSet('/DashboardConfig/Clock/Master LEMO freq', parseInt(this.value,10) );
        window.localODB.masterLEMOfreq = parseInt(this.value,10);
        document.getElementById('outsContentmasterStepdownSlider').onchange();
    } 
    */   
}

//show the relevant clock information when clicked on
function showClock(id){
    var i, text, label, value, isOn, index;

    glowMe.apply(window.clockPointer, [id]);
    //only show CSAC tab for Master:
    index = parseInt(id.slice(5,id.length),10);
    if(parseInt(window.localODB['clock'+index][1],10) )
        document.getElementById('CSACTab').style.opacity = 1;
    else
        document.getElementById('CSACTab').style.opacity = 0;

    //keep track of which clock is highlit:
    window.clockPointer.activeElt = id;

    //clock summary parameters
    for(i=1; i<9; i++){
        value = humanReadableClock(i, window.localODB[id][i]);
        document.getElementById('clockSummaryValue'+i).innerHTML = value;
    }

    //master needs switch for LEMO or AC Ref. Clock:
    if(parseInt(window.localODB[id][1],10)){
        document.getElementById('clockSummaryLabel3').innerHTML = 'Ref. Clock';
        document.getElementById('clockSummaryValue3').innerHTML = '';
        toggleSwitch('clockSummaryValue3', 'masterRefToggle', 'AC', 'LEMO', 'LEMO', masterLEMO.bind(null,id), masterAC.bind(null,id), parseInt(window.localODB[id][4],10));

        //also, don't report FanSel for the master, replace with frequency info:
        document.getElementById('clockSummaryLabel4').innerHTML = 'Input Freq.:';
        document.getElementById('clockSummaryValue4').innerHTML = '10 MHz';
    } else{
        document.getElementById('clockSummaryLabel3').innerHTML = 'Clock Source';
        document.getElementById('clockSummaryLabel4').innerHTML = 'Ref. Clock';
        document.getElementById('clockSummaryValue4').innerHTML = 'N/A';
    }

    //master reports NIM clock, slave reports ESATA clock
    if(parseInt(window.localODB[id][1],10)){
        document.getElementById('clockSummaryLabel9').innerHTML = 'Last NIM Sync';
        document.getElementById('clockSummaryValue9').innerHTML = humanReadableClock(10, window.localODB[id][10]);
    } else {
        document.getElementById('clockSummaryLabel9').innerHTML = 'Last eSATA Sync';
        document.getElementById('clockSummaryValue9').innerHTML = humanReadableClock(9, window.localODB[id][9]);
    }

    //kick summary tab to make sure it's the right size
    document.getElementById('summaryTab').style.maxHeight = (document.getElementById('summaryContent').offsetHeight+50)+'px';

    //manage clock channel out tab
    //only need master slider for master view:
    if(parseInt(window.localODB[id][1],10)){
        document.getElementById('outsContentmasterStepdownSliderDiv').style.display='block';
    } else{
        document.getElementById('outsContentmasterStepdownSliderDiv').style.display='none';
    }


    //decode which channels are on / off:
    for(i=0; i<6; i++){
        isOn = (0xF << 4*i) & window.localODB[id][0];
        if( (document.getElementById('toggleSwitch'+'ch'+i+'Toggle').style.left=='0em' && isOn) || (document.getElementById('toggleSwitch'+'ch'+i+'Toggle').style.left=='1em' && !isOn) ){
            document.getElementById('toggleWrap'+'ch'+i+'Toggle').ready = 1;
            document.getElementById('toggleSwitch'+'ch'+i+'Toggle').onmouseup();
        }
    }

    document.getElementById('bypassReport0').innerHTML = 'Bypass: ' + humanReadableClock(13, window.localODB[id][13]);
    document.getElementById('bypassReport1').innerHTML = 'Bypass: ' + humanReadableClock(17, window.localODB[id][17]);
    document.getElementById('bypassReport2').innerHTML = 'Bypass: ' + humanReadableClock(21, window.localODB[id][21]);
    document.getElementById('bypassReport3').innerHTML = 'Bypass: ' + humanReadableClock(25, window.localODB[id][25]);
    document.getElementById('bypassReport4').innerHTML = 'Bypass: ' + humanReadableClock(29, window.localODB[id][29]);
    document.getElementById('bypassReport5').innerHTML = 'Bypass: ' + humanReadableClock(41, window.localODB[id][41]);
    document.getElementById('bypassReport6').innerHTML = 'Bypass: ' + humanReadableClock(33, window.localODB[id][33]);
    document.getElementById('bypassReport7').innerHTML = 'Bypass: ' + humanReadableClock(37, window.localODB[id][37]);

    //make sure the LEMO badges match width with the rest:
    document.getElementById('outsContentBadge6').style.minWidth = document.getElementById('outsContentBadge4').offsetWidth;
    document.getElementById('outsContentBadge7').style.minWidth = document.getElementById('outsContentBadge5').offsetWidth;

    //CSAC parameters
    for(i=43; i<54; i++){
        value = humanReadableClock(i, window.localODB[id][i]);
        document.getElementById('clockCSACValue'+i).innerHTML = value;
    }

}

function glowMe(id){
    document.getElementById(this.activeElt).style.boxShadow = '0 0 0px white';
    document.getElementById(id).style.boxShadow = '0 0 20px white';
}

//translate clock parameter i of value v into something a human can comprehend:
function humanReadableClock(i, v){
    if(i == 1)
        return (parseInt(v,10)) ? 'Master' : 'Slave';
    else if(i == 2)
        return (parseInt(v,10)) ? 'LEMO' : 'eSATA';
    else if(i == 3)
        return (parseInt(v,10)) ? 'LEMO' : 'eSATA';
    else if(i == 4)
        return (parseInt(v,10)) ? 'LEMO' : 'Atomic Clock'
    else if(i>4 && i<9)
        return (parseInt(v,10)) ? 'Present' : 'Absent';
    else if(i==9 || i==10)
        return Math.floor(v/3600) + ' h: ' + Math.floor((v%3600)/60) + ' m';
    else if(i==13 || i==17 || i==21 || i==25 || i==29 || i==33 || i==37 || i==41)
        return (parseInt(v,10)) ? 'Yes' : 'No';
    else if(i==43)
        return (parseInt(v,10)) ? 'Up' : 'Down';
    else
        return v;

}

//return the index of the first clock claiming to be master
function findMaster(){
    var i, masterIndex = 0;

    for(i=0; i<window.parameters.nClocks; i++){
        if(parseInt(window.localODB['clock'+i][1],10) == 1){
            masterIndex = i;
            break;
        }
    }
    return masterIndex;
}

/*
SYNC:
MASTER == NIM
SLAVE == ESATA
*/function Cycle(){
    var that = this,
    i, key;
    window.cyclePointer = that;

    this.wrapperID = window.parameters.wrapper; //ID of wrapping div
    this.canvasID = 'cycleCanvas';         //ID of canvas to paint filter on
    this.linkWrapperID = 'cycleLinks';        //ID of div to contain clock view header
    this.sidebarID = 'cycleSidebar';          //ID of sidebar div
    this.nCycleSteps = 0;
    this.nCycleSummarySteps = 0;
    this.helpMessage = 'Drag an action from the right here to define a command step, or leave as-is for a delay.';
    this.currentDrag = '';
    this.codex = {
        "beamOn"        : 1,    //0x00000001
        "wildcard1"     : 2,    //0x00000002
        "wildcard2"     : 4,    //0x00000004
        "wildcard3"     : 8,    //0x00000008
        "syncClocks"    : 16,   //0x00000010
        "clearScalars"  : 32,   //0x00000020
        "moveTape"      : 64,   //0x00000040
        "enableHPGe"    : 128,  //0x00000080
        "enableSCEPTAR" : 256,  //0x00000100
        "enablePACES"   : 512,  //0x00000200
        "enableDANTE"   : 1024, //0x00000400
        "enableDESCANT" : 2048, //0x00000800
        "enableZDS"     : 4096, //0x00001000
        "wildcard4"     : 8192, //0x00002000
        "wildcard5"     : 16384,//0x00004000
        "wildcard6"     : 32768,//0x00008000 
        "triggersOn"    : 8064  //0x00001F80  //as in ALL triggers on.
    };
    //keep an internal list of all available cycles:
    this.cycleNames = [];
    //generate initial cycle list:
    for(key in ODB.Cycles){
        if(ODB.Cycles.hasOwnProperty(key) && typeof ODB.Cycles[key] == 'object' && !Array.isArray(ODB.Cycles[key])){
            this.cycleNames[this.cycleNames.length] = key;
        }
    }

    this.wrapper = document.getElementById(this.wrapperID);

    //add top level nav button:
    injectDOM('button', 'CycleButton', 'statusLink', {
        'class' : 'navLink',
        'onclick' : function(){swapView('cycleSummary', 'cycleCanvas', 'cycleMenus', 'CycleButton');},
        'innerHTML' : 'Cycle'
    });

    //summary view//////////////////////////////////////////////////////
    injectDOM('div', 'cycleSummary', this.wrapperID, {'class':'navPanel', 'style':'min-width: 50%'});
    injectDOM('h1', 'cycleSummaryBanner', 'cycleSummary', {'class':'navPanelHeader', 'innerHTML':'Current Cycle'});
    injectDOM('br', 'break', 'cycleSummary', {});
    injectDOM('button', 'gotoCycleEdit', 'cycleSummary', {
        'class' : 'navLink',
        'onclick' : function(){swapView('cycleLinks', 'cycleCanvas', 'cycleMenus', 'CycleButton');},
        'innerHTML' : 'Edit Cycle',
        'style' : 'margin-bottom: 1em', 
        'type' : 'button'
    });
    injectDOM('div', 'cycleSummaryWrapper', 'cycleSummary', {'style' : 'text-align:center; width:100%'});

    //edit view/////////////////////////////////////////////////////////
    injectDOM('div', this.linkWrapperID, this.wrapperID, {'class':'navPanel'});
    //nav header
    injectDOM('h1', 'cycleLinksBanner', this.linkWrapperID, {'class' : 'navPanelHeader', 'innerHTML' : 'Edit Cycle'});
    injectDOM('br', 'break', this.linkWrapperID, {});

    //nav buttons & cycle save / load interface:
    injectDOM('button', 'showCycleSummary', this.linkWrapperID, {
        'class' : 'navLink',
        'onclick' : function(){swapView('cycleSummary', 'cycleCanvas', 'cycleMenus', 'CycleButton');},
        'innerHTML' : 'Return to Cycle Summary',
        'type' : 'button'
    });    
    injectDOM('button', 'commitCycle', this.linkWrapperID, {
        'class' : 'navLink',
        'style' : '-webkit-animation-name:x; -moz-animation-name:x;',
        'onclick' : commitCycle.bind(null),
        'innerHTML' : 'Deploy Cycle Now',
        'type' : 'button'
    });
    injectDOM('button', 'resetCycle', this.linkWrapperID, {
        'class' : 'navLink',
        'onclick' : reloadCycle.bind(null),
        'innerHTML' : 'Reload Active Cycle',
        'type' : 'button',
        'onclick' : function(){
            var dropdown = document.getElementById('cycleOptions'),
                currentCycle = ODB.Cycles['Active Name'],
                i;

            for(i=0; i<dropdown.childNodes.length; i++){
                if(dropdown.childNodes[i].innerHTML == currentCycle){
                    dropdown.selectedIndex = i;
                }
            }

            loadCycle();
        }
    });
    injectDOM('br', 'break', this.linkWrapperID, {});
    injectDOM('label', 'cycleNameLabel', this.linkWrapperID, {'style':'margin-left:10px;', 'innerHTML':'Name this Cycle: '});
    injectDOM('input', 'cycleName', this.linkWrapperID, {'type' : 'text', 'value' : 'newCycle'});
    injectDOM('button', 'saveCycle', this.linkWrapperID, {
        'class' : 'navLink',
        'onclick' : saveCycle.bind(null),
        'innerHTML' : 'Save Cycle Definition',
        'type' : 'button'
    });
    document.getElementById('cycleNameLabel').setAttribute('for', 'cycleName');
    injectDOM('br', 'break', this.linkWrapperID, {});
    injectDOM('label', 'loadCycleLabel', this.linkWrapperID, {'style':'margin-left:10px;', 'innerHTML':'Load Cycle: '});
    injectDOM('select', 'cycleOptions', this.linkWrapperID, {});
    document.getElementById('loadCycleLabel').setAttribute('for', 'cycleOptions');
    loadOptions(ODB.Cycles, 'cycleOptions');
    injectDOM('button', 'loadCycle', this.linkWrapperID, {
        'class' : 'navLink',
        'onclick' : loadCycle.bind(null),
        'innerHTML' : 'Load',
        'type' : 'button'
    });
    injectDOM('button', 'deleteOption', this.linkWrapperID, {
        'class' : 'navLink',
        'innerHTML' : 'Delete',
        'tpye' : 'button',
        'onclick' : function(){
            var i, name,
                dropdown = document.getElementById('cycleOptions'),
                cycleIndex = parseInt(dropdown.value, 10);

            for(i=0; i<dropdown.childNodes.length; i++){
                if(dropdown.childNodes[i].value == cycleIndex){
                    name = dropdown.childNodes[i].innerHTML;
                }
            }
            confirm('Delete Cycle Definition', 'Do you really want to delete '+name+'?', deleteOption.bind(null, '/DashboardConfig/Cycles/', 'cycleOptions'));
            document.getElementById('tempDiv').style.top = 200;
        }
    });


    //div structure for drag and drop area: right panel for detector palete, two-div column for Single Stream and Interstream Filters:
    injectDOM('div', 'cycleWrapper', this.linkWrapperID, {'style' : 'width:'+(270+0.48*$(this.wrapper).width())+'px; margin-top:1em; display:block'});
    injectDOM('div', 'cycleSteps', 'cycleWrapper', {'style' : 'width:'+0.48*$(this.wrapper).width()+'; padding:0.5em; float:left; text-align:center;'});
    injectDOM('div', 'cyclePalete', 'cycleWrapper', {
        'class' : 'cycleDiv',
        'style' : 'width:250px; float:right; text-align:center; padding-top:1em; position:relative; top:0px; max-height:'+( $('#leftSidebar').offset().top + $('#leftSidebar').offset().height - $('#cycleSteps').offset().top )+'; overflow:scroll; background-color:#222222;',
    });

    //inject options into palete
    this.badgeWidth = 100;
    this.badgeHeight = 100;

    //start display off with one drop target, filled with just an instruction on how to proceed:
    createCycleStep(this.helpMessage);
    this.nCycleSteps++;
    terminationBadge();

    //deploy a dummy canvas for the filter view:
    this.canvasWidth = 0// 0.48*$(this.wrapper).width();
    this.canvasHeight = 0 //1*$(this.wrapper).height();
    injectDOM('canvas', this.canvasID, this.wrapperID, {
        'class':'monitor', 
        'style':'top:' + ($('#cycleLinks').height() + 5) +'px;'
    });
    this.canvas = document.getElementById('cycleCanvas');
    this.context = this.canvas.getContext('2d');
    this.canvas.setAttribute('width', this.canvasWidth);
    this.canvas.setAttribute('height', this.canvasHeight);

    /*
    //right sidebar
    injectDOM('div', this.sidebarID, this.wrapperID, {'class':'collapsableSidebar', 'style':'float:right; height:80%;'});
    //deploy right bar menu:
    deployMenu('cycleMenus', ['Cycle'], ['Cycle Details']);    
    */
    injectDOM('div', this.sidebarID, this.wrapperID, {}); //dummy sidebar for transitions

    //Clear Scalars
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'clearScalarsPaleteBadge', 'cyclePalete', clearScalars, [0.5*this.badgeHeight, this.badgeWidth], 'Clear Scalars', true);
    //Move Tape
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'moveTapePaleteBadge', 'cyclePalete', moveTape, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Move Tape', true);
    //Trigers On
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'triggersOnPaleteBadge', 'cyclePalete', triggersOn, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Triggers On', true);
    //Beam On
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'beamOnPaleteBadge', 'cyclePalete', beamOn, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Beam On', true);
    //Sync Clocks
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'syncClocksPaleteBadge', 'cyclePalete', syncClocks, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Sync Clocks', true);
    //HPGe Trigger
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'HPGePaleteBadge', 'cyclePalete', tigress, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.3], 'HPGe Trig', true);
    //SCEPTAR Trigger
    if(ODB.SCEPTAR)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'SCEPTARPaleteBadge', 'cyclePalete', sceptar, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.3], 'SCEPTAR Trig', true);
    //PACES Trigger
    if(ODB.PACES)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'PACESPaleteBadge', 'cyclePalete', paces, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.2, this.badgeHeight*0.05], 'PACES Trig', true);
    //DANTE Trigger
    if(ODB.DANTE)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'DANTEPaleteBadge', 'cyclePalete', dante, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.2, '#999999'], 'DANTE Trig', true);
    //DESCANT Trigger
    if(ODB.DESCANT)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'DESCANTPaleteBadge', 'cyclePalete', descant, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.1], 'DESCANT Trig', true);
    //ZDS Trigger
    if(ODB.ZDS)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'ZDSPaleteBadge', 'cyclePalete', zds, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.3], 'ZDS Trig', true);
    //Wildcards 1-6:
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard1PaleteBadge', 'cyclePalete', wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 1', true);
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard2PaleteBadge', 'cyclePalete', wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 2', true);
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard3PaleteBadge', 'cyclePalete', wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 3', true);
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard4PaleteBadge', 'cyclePalete', wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 4', true);
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard5PaleteBadge', 'cyclePalete', wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 5', true);
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard6PaleteBadge', 'cyclePalete', wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 6', true);

    //modify the dragstart of the palete badges:
    document.getElementById('clearScalarsPaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('moveTapePaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('triggersOnPaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('beamOnPaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('syncClocksPaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('HPGePaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    if(ODB.SCEPTAR)document.getElementById('SCEPTARPaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    if(ODB.PACES)document.getElementById('PACESPaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    if(ODB.DANTE)document.getElementById('DANTEPaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    if(ODB.DESCANT)document.getElementById('DESCANTPaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    if(ODB.ZDS)document.getElementById('ZDSPaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('wildcard1PaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('wildcard2PaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('wildcard3PaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('wildcard4PaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('wildcard5PaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);
    document.getElementById('wildcard6PaleteBadgecyclePalete').addEventListener('dragstart', paleteDragStart, false);

    this.update = function(){
    };

    reloadCycle();
    suspendCycleRequest();

}


//functions for drag and drop event listeners to call////////////////////////////////////////////////////
function paleteDragStart(){
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', this.id.slice(0, this.id.indexOf('PaleteBadge')));
    window.cyclePointer.currentDrag = this.id;
}

//what to do when user drops a command on a spacer div:
function spacerDrop(event){
    event.stopPropagation();

    spacerDragLeave.apply(this);

    var targetIndex,
        payload = event.dataTransfer.getData('text/plain');
    //determine ID of right-hand spacer in the pair:
    targetIndex = this.id.slice(this.id.indexOf('Spacer')+6, this.id.length);

    //if a command was getting dragged, move it into position:
    if(payload.slice(0,9) == 'cycleStep'){
        moveCommand(payload.slice(9,payload.length), targetIndex);
    //otherwise handle a new command getting dropped in:
    } else{
        //make the cycle step per usual:
        createCycleStep(payload);
        //and move it to where it should go:
        moveCommand(window.cyclePointer.nCycleSteps, targetIndex);
        window.cyclePointer.nCycleSteps++;
    }

    //move a command from one place in the sequence to another:    
    function moveCommand(origin, destination){
        document.getElementById('cycleSteps').insertBefore(document.getElementById('cycleStep'+origin), document.getElementById('rightCycleSpacer' + destination).nextSibling);
        document.getElementById('cycleSteps').insertBefore(document.getElementById('cycleStepsBreak'+origin), document.getElementById('cycleStep'+origin).nextSibling);
        document.getElementById('cycleSteps').insertBefore(document.getElementById('leftCycleSpacer'+origin), document.getElementById('cycleStepsBreak'+origin).nextSibling );
        document.getElementById('cycleSteps').insertBefore(document.getElementById('rightCycleSpacer'+origin), document.getElementById('leftCycleSpacer'+origin).nextSibling );
    }

    askForCycleDeploy();

    return false;
}

//change border colors on drag enter and leave for timeline:
function spacerDragOver(){
    event.stopPropagation();
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';

    document.getElementById('rightCycleSpacer'+this.id.slice(this.id.indexOf('Spacer')+6, this.id.length)).style.borderColor = '#FFFFFF';

    return false;
}

function spacerDragLeave(){
    event.stopPropagation();

    document.getElementById('rightCycleSpacer'+this.id.slice(this.id.indexOf('Spacer')+6, this.id.length)).style.borderColor = '#999999';

    return false;
}

//cycle steps can append subcommands to themselves on drop:
function cycleDrop(event){
    event.stopPropagation();

    cycleDragLeave.apply(this);

    var contentBlock = document.getElementById(this.contentID),
        payload = event.dataTransfer.getData('text/plain')

    //do stuff with the payload data
    if(!(payload.slice(0,9)=='cycleStep')){
        if(contentBlock.innerHTML.indexOf(window.cyclePointer.helpMessage) != -1){
            contentBlock.innerHTML = '';
            contentBlock.setAttribute('class', 'cycleContent'); 
        }
        deployBadge.apply(window.cyclePointer, [payload, contentBlock.id]);
    }

    askForCycleDeploy();

    return false;   
}

function cycleDragOver(event){
    event.stopPropagation();
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';

    if(!(window.cyclePointer.currentDrag.slice(0,9)=='cycleStep'))
        this.style.borderColor = '#FFFFFF';
    return false;
}

function cycleDragLeave(){
    event.stopPropagation();

    this.style.borderColor = '#999999';

    return false;
}

//extended page elements/////////////////////////////////////////////////////////////////////////////////////////////

//create a cycle step div based on the <input> recieved from the drop event:
function createCycleStep(input){
    var stepDiv;

    //actual div
    injectDOM('div', 'cycleStep'+window.cyclePointer.nCycleSteps, 'cycleSteps', {'class':'cycleStep', 'style':'display:inline-block; margin-left:auto; margin-right:auto;'});
    stepDiv = document.getElementById('cycleStep'+window.cyclePointer.nCycleSteps);
    stepDiv.draggable = 'true';

    //the div's draggable data payload should be its id:
    stepDiv.addEventListener('dragstart', function(event){
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', this.id );
        //in their infinite wisdom, Standards appears to have made it impossible to access the data payload during dragover; store it with a global pointer to circumvent.
        window.cyclePointer.currentDrag = this.id;
    }, false);

    //content block:
    stepDiv.contentID = 'cycleContent'+window.cyclePointer.nCycleSteps
    injectDOM('div', stepDiv.contentID, 'cycleStep'+window.cyclePointer.nCycleSteps, {
        'class':'cycleContent',
        'style': 'max-width:'+0.2*$(window.cyclePointer.wrapper).width()
    });
    //deploy the div with something in it:
    //document.getElementById(stepDiv.contentID).innerHTML = input;
    deployBadge.apply(window.cyclePointer, [input, 'cycleContent'+window.cyclePointer.nCycleSteps]);

    //kill button
    injectDOM('button', 'deleteCycleStep'+window.cyclePointer.nCycleSteps, 'cycleStep'+window.cyclePointer.nCycleSteps, {
        'class' : 'deleteButton',
        'style' : 'position:static; float:right;',
        'innerHTML' : String.fromCharCode(0x2573),
        'type' : 'button',
        'onclick' : function(){
            //delete only if there's a button to make a new div:
            if(document.getElementById('terminateCycle')){
                //delete linebreak:
                var linebreak = document.getElementById('cycleStepsBreak'+this.id.slice(15, this.id.length));
                linebreak.parentNode.removeChild(linebreak);
                //delete timeline divs:
                var leftDiv = document.getElementById('leftCycleSpacer'+this.id.slice(15, this.id.length));
                leftDiv.parentNode.removeChild(leftDiv);
                var rightDiv = document.getElementById('rightCycleSpacer'+this.id.slice(15, this.id.length));
                rightDiv.parentNode.removeChild(rightDiv);
                //delete cycle div:
                var element = document.getElementById(this.id);
                element.parentNode.parentNode.removeChild(element.parentNode);
                askForCycleDeploy();
            }
        }
    });

    //duration block:
    durationBadge(window.cyclePointer.nCycleSteps, 'cycleStep'+window.cyclePointer.nCycleSteps);

    //cycleStep div listens for things to be dropped on it:
    stepDiv.addEventListener('dragover', cycleDragOver, false);
    stepDiv.addEventListener('dragleave', cycleDragLeave, false);
    stepDiv.addEventListener('drop', cycleDrop, false);
    
    injectDOM('br', 'cycleStepsBreak'+window.cyclePointer.nCycleSteps, 'cycleSteps', {});
    injectDOM('div', 'leftCycleSpacer'+window.cyclePointer.nCycleSteps, 'cycleSteps', {'style':'display:inline-block; height:50px; width:50%'});
    injectDOM('div', 'rightCycleSpacer'+window.cyclePointer.nCycleSteps, 'cycleSteps', {'style':'display:inline-block; border-left: 5px solid #999999; height:50px; width:50%'});

    //spacers listen for things to be dropped on them, so commands can be inserted mid-stream
    document.getElementById('leftCycleSpacer'+window.cyclePointer.nCycleSteps).addEventListener('dragover', spacerDragOver, false);
    document.getElementById('rightCycleSpacer'+window.cyclePointer.nCycleSteps).addEventListener('dragover', spacerDragOver, false);
    document.getElementById('leftCycleSpacer'+window.cyclePointer.nCycleSteps).addEventListener('drop', spacerDrop, false);
    document.getElementById('rightCycleSpacer'+window.cyclePointer.nCycleSteps).addEventListener('drop', spacerDrop, false);
    //spacers change color when something droppable this way comes, change it back when the drag leaves:
    document.getElementById('leftCycleSpacer'+window.cyclePointer.nCycleSteps).addEventListener('dragleave', spacerDragLeave, false);
    document.getElementById('rightCycleSpacer'+window.cyclePointer.nCycleSteps).addEventListener('dragleave', spacerDragLeave, false);

    //move the termination badge to the end:
    if(document.getElementById('terminateCycle'))   
        document.getElementById('cycleSteps').appendChild(document.getElementById('terminateCycle'));

}

//create a cycle summary step
function createCycleSummaryStep(encoding, duration, suppressFlow){
    var stepDiv, i, command, key, allowIndividualTrig, durationString;

    //determine duration:
    if(duration==0)
        durationString = 'Infinite';
    else if(duration > 60000)
        durationString = (duration/60000).toFixed(2) + ' min';
    else if(duration>1000)
        durationString = (duration/1000).toFixed(2) + ' s';
    else
        durationString = duration + ' ms';

    //step wrapper
    injectDOM('div', 'cycleSummaryStep'+window.cyclePointer.nCycleSummarySteps, 'cycleSummaryWrapper', {'class':'cycleStep', 'style':'display:inline-block; margin-left:auto; margin-right:auto;'});
    stepDiv = document.getElementById('cycleSummaryStep'+window.cyclePointer.nCycleSummarySteps);

    //content block:
    stepDiv.contentID = 'cycleSummaryContent'+window.cyclePointer.nCycleSummarySteps
    injectDOM('div', stepDiv.contentID, 'cycleSummaryStep'+window.cyclePointer.nCycleSummarySteps, {
        'class':'cycleContent',
        'style': 'max-width:'+0.2*$(window.cyclePointer.wrapper).width()
    });

    //duration block:
    injectDOM('p', 'cycleSummaryDuration'+window.cyclePointer.nCycleSummarySteps, 'cycleSummaryStep'+window.cyclePointer.nCycleSummarySteps, {
        'innerHTML':durationString,
        'class' : 'cycleSummaryDuration'
    });
    document.getElementById('cycleSummaryDuration'+window.cyclePointer.nCycleSummarySteps).style.top = $('#cycleSummaryStep'+window.cyclePointer.nCycleSummarySteps).height()*(-0.6);

    //populate content block
    command = parseCommand(encoding);
    //deploy the appropriate badges:
    //either all trigs is enabled, or allow individual system triggers:
    allowIndividualTrig = 0;
    if(command['triggersOn'] == 1)
        deployBadge.apply( window.cyclePointer, ['triggersOn', 'cycleSummaryContent'+(window.cyclePointer.nCycleSummarySteps)] );
    else
        allowIndividualTrig = 1;
    for(key in command){
        if(command[key] == 1 && key!='triggerOn' && !(key.slice(0,6)=='enable' && allowIndividualTrig==0 ) )
            deployBadge.apply(window.cyclePointer, [key, 'cycleSummaryContent'+(window.cyclePointer.nCycleSummarySteps)]);
    }        
    
    if(!suppressFlow){
        injectDOM('br', 'cycleSummaryStepsBreak'+window.cyclePointer.nCycleSummarySteps, 'cycleSummaryWrapper', {});
        injectDOM('div', 'leftCycleSummarySpacer'+window.cyclePointer.nCycleSummarySteps, 'cycleSummaryWrapper', {'style':'display:inline-block; height:50px; width:50%'});
        injectDOM('div', 'rightCycleSummarySpacer'+window.cyclePointer.nCycleSummarySteps, 'cycleSummaryWrapper', {'style':'display:inline-block; border-left: 5px solid #999999; height:50px; width:50%'});
    }

    window.cyclePointer.nCycleSummarySteps++;
}

//create a timeline termination badge that includes a button to create a new empty command:
function terminationBadge(){
    injectDOM('div', 'terminateCycle', 'cycleSteps', {'style':'background-color:#222222'});
    injectDOM('button', 'newCommand', 'terminateCycle', {
        'class' : 'navLink',
        'innerHTML' : 'New Command',
        'type' : 'button',
        'onclick' : function(){
            createCycleStep(window.cyclePointer.helpMessage);
            document.getElementById('cycleContent'+window.cyclePointer.nCycleSteps).setAttribute('class', 'delayCycleContent') 
            window.cyclePointer.nCycleSteps++;
            askForCycleDeploy();
        }
    });
}

//create a duration control badge for deployment in each cycle step
function durationBadge(index, parentID){
    var canvas, context;

    //wrapper div
    injectDOM('div', 'durationDiv'+index, parentID, {'style' : 'float:right; display:inline-block; text-align:center; margin-left:5px;'});
    //number input
    injectDOM('input', 'durationInput'+index, 'durationDiv'+index, {
        'class' : 'cycleDurationInput',
        'type' : 'number',
        'style' : 'background-color:#222222'
    });
    injectDOM('p', 'infiniteDuration'+index, 'durationDiv'+index, {
        'style' : 'display:none; font-size:230%; margin:0px;',
        'innerHTML' : String.fromCharCode(0x221E)
    });
    injectDOM('br', 'durationBreak'+index, 'durationDiv'+index, {});
    //unit
    createOptionScroll('durationDiv'+index, 'durationScroll'+index, ['millisec', 'seconds', 'minutes', 'infinite'], window.cyclePointer.badgeWidth*1.3,
        function(){
            if(document.getElementById('durationScroll'+index+'Selected').innerHTML == 'infinite'){
                document.getElementById('durationInput'+index).style.display = 'none';
                document.getElementById('durationSlider'+index).style.display = 'none';
                document.getElementById('durationBreak'+index).style.display = 'none';
                document.getElementById('infiniteDuration'+index).style.display = 'block';
            } else{
                document.getElementById('durationInput'+index).style.display = '';
                document.getElementById('durationSlider'+index).style.display = '';
                document.getElementById('durationBreak'+index).style.display = '';
                document.getElementById('infiniteDuration'+index).style.display = 'none';                
            }
            askForCycleDeploy();
        });
    //when infinite is selected, remove UI elements and just show infinite:
    injectDOM('br', 'break', 'durationDiv'+index, {});
    //slider
    injectDOM('input', 'durationSlider'+index, 'durationDiv'+index, {'style':'width:80%; margin:0px', 'type':'range'});
    document.getElementById('durationSlider'+index).min = 0;
    document.getElementById('durationSlider'+index).max = 1000;
    document.getElementById('durationSlider'+index).onchange = function(){
        document.getElementById('durationInput'+index).value = this.valueAsNumber;
        askForCycleDeploy();
    }
    document.getElementById('durationInput'+index).value = document.getElementById('durationSlider'+index).valueAsNumber;
    document.getElementById('durationInput'+index).min = 0;
    document.getElementById('durationInput'+index).max = 1000;
    document.getElementById('durationInput'+index).onchange = function(){
        document.getElementById('durationSlider'+index).value = this.valueAsNumber;
        askForCycleDeploy();
    }
}

//insert the appropriate badge into the command div:
function deployBadge(badge, commandID){


    if(badge == 'clearScalars')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'clearScalarsPaleteBadge', commandID, clearScalars, [this.badgeHeight*0.5, this.badgeWidth], 'Clear Scalars', false);
    else if(badge == 'moveTape')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'moveTapePaleteBadge', commandID, moveTape, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Move Tape', false);
    else if(badge == 'triggersOn')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'triggersOnPaleteBadge', commandID, triggersOn, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Triggers On', false);
    else if(badge == 'beamOn')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'beamOnPaleteBadge', commandID, beamOn, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Beam On', false);
    else if(badge == 'syncClocks')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'syncClocksPaleteBadge', commandID, syncClocks, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Sync Clocks', false);
    else if(badge == 'HPGe')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'HPGePaleteBadge', commandID, tigress, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.3], 'HPGe', false);
    else if(badge == 'SCEPTAR')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'SCEPTARPaleteBadge', commandID, sceptar, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.3], 'SCEPTAR', false);
    else if(badge == 'PACES')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'PACESPaleteBadge', commandID, paces, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.2, this.badgeHeight*0.05], 'PACES', false);
    else if(badge == 'DANTE')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'DANTEPaleteBadge', commandID, dante, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.2, '#999999'], 'DANTE', false);
    else if(badge == 'DESCANT')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'DESCANTPaleteBadge', commandID, descant, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.1], 'DESCANT', false);
    else if(badge == 'ZDS')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'ZDSPaleteBadge', commandID, zds, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.3], 'ZDS', false);
    else if(badge == 'wildcard1')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard1PaleteBadge', commandID, wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 1', false);
    else if(badge == 'wildcard2')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard2PaleteBadge', commandID, wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 2', false);
    else if(badge == 'wildcard3')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard3PaleteBadge', commandID, wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 3', false);
    else if(badge == 'wildcard4')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard4PaleteBadge', commandID, wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 4', false);
    else if(badge == 'wildcard5')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard5PaleteBadge', commandID, wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 5', false);
    else if(badge == 'wildcard6')
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'wildcard6PaleteBadge', commandID, wildcard, [this.badgeWidth, this.badgeHeight, this.badgeWidth/2, this.badgeHeight*0.35], 'Wildcard 6', false);
    else{
        document.getElementById(commandID).innerHTML = badge;
        document.getElementById(commandID).setAttribute('class', 'delayCycleContent');
    }
}

//step through the cycle, and construct the appropriate command and duration arrays
function buildCycle(){
    var i, j, commandNode, contentNode, actionNode, stepCode, duration, timeUnit,
        //nCycleSteps = (document.getElementById('cycleSteps').childNodes.length-1)/4, //-1 for the termination badge, /4 for command+2spacers+linebreak.
        commands = [],
        durations = [];

        for(i=0; i<window.cyclePointer.nCycleSteps; i++){
            commandNode = document.getElementById('cycleStep'+i);
            if(commandNode){
                contentNode = document.getElementById('cycleContent'+i);
                stepCode = 0;
                if(contentNode.childNodes.length != 1 || contentNode.childNodes[0].nodeType != Node.TEXT_NODE){
                    for(j=0; j<contentNode.childNodes.length; j++){
                        actionNode = contentNode.childNodes[j];
                        if(actionNode.id.indexOf('cycleContent') != -1){
                            stepCode = stepCode | window.cyclePointer.codex[actionNode.id.slice(0, actionNode.id.indexOf('Palete'))];
                        }
                    }
                }
                //first 16 bits mirror last 16 bits for redundancy:
                stepCode = stepCode | (stepCode<<16)
                commands[commands.length] = stepCode;
                //extract duration in ms:
                duration = document.getElementById('durationInput'+i).valueAsNumber;
                timeUnit = document.getElementById('durationScroll'+i+'Selected').innerHTML;
                if(timeUnit == 'seconds')
                    duration *= 1000;
                else if(timeUnit == 'minutes')
                    duration *= 1000*60;
                else if(timeUnit == 'infinite')
                    duration = 0;
                durations[durations.length] = duration;                
            }     


        }

        return [commands, durations];
}

//parse a 32bit command word into its component actions:
function parseCommand(command){
    var key,
        actions = JSON.parse(JSON.stringify(window.cyclePointer.codex));

    for(key in window.cyclePointer.codex){
        if(command & window.cyclePointer.codex[key])
            actions[key] = 1;
        else
            actions[key] = 0;
    }

    return actions;
}

//deploy a command step as defined by its command word and duration:
function deployCommand(command, duration){
    var key, time, units, durationBadge, allowIndividualTrig,
        actions = parseCommand(command);

    //use the new command button to insert a new command:
    document.getElementById('newCommand').onclick();
    for(key in actions){
        if(actions[key] == 1){
            document.getElementById('cycleContent'+(window.cyclePointer.nCycleSteps-1)).setAttribute('class', 'cycleContent');
            document.getElementById('cycleContent'+(window.cyclePointer.nCycleSteps-1)).innerHTML = '';
            break;
        }
    }

    //deploy the appropriate badges:
    //either all trigs is enabled, or allow individual system triggers:
    allowIndividualTrig = 0;
    if(actions['triggersOn'] == 1)
        deployBadge.apply( window.cyclePointer, ['triggersOn', 'cycleContent'+(window.cyclePointer.nCycleSteps-1)] );
    else
        allowIndividualTrig = 1;
    for(key in actions){
        if(actions[key] == 1 && key!='triggerOn' && !(key.slice(0,6)=='enable' && allowIndividualTrig==0 ) )
            deployBadge.apply(window.cyclePointer, [key, 'cycleContent'+(window.cyclePointer.nCycleSteps-1)]);
    }

    //set the duration badge:
    if(duration >= 60000){
        time = Math.floor(duration/60000);
        unit = 'minutes';
    } else if(duration >= 1000){
        time = Math.floor(duration/1000);
        unit = 'seconds';
    } else if(duration == 0){
        time = duration;
        unit = 'infinite';
    } else{
        time = duration;
        unit = 'millisec';
    }
    durationBadge = document.getElementById('durationDiv'+(window.cyclePointer.nCycleSteps-1));
    if(time!=0){
        durationBadge.childNodes[0].value = time;
        durationBadge.childNodes[5].value = time;
    }
    while(durationBadge.childNodes[3].childNodes[1].innerHTML != unit)
         durationBadge.childNodes[3].childNodes[2].onclick();

}

//fetch the top-level subkeys from an ODB directory as a set of dropdown options, for use in Filters and Cycles:
function loadOptions(location, dropdown){
    var key, i=0,
        option = [];

    for(key in location){
        if(location.hasOwnProperty(key) && typeof location[key] == 'object' && !Array.isArray(location[key]) ){
            option[i] = document.createElement('option');
            option[i].text = key;
            option[i].value = i;
            document.getElementById(dropdown).add(option[i], null);
            i++;
        }
    }
}

//write the defined cycle to the ODB for later use
function saveCycle(){
    
    var deleteCode, option, cycle = buildCycle();
        name = document.getElementById('cycleName').value,

    //remove old instance of this cycle, in case this is an edit:
    deleteCode = JSON.parse(ODBMDelete(['/DashboardConfig/Cycles/'+name]));
    //recreate:
    ODBMCreate(['/DashboardConfig/Cycles/'+name, '/DashboardConfig/Cycles/'+name+'/Code', '/DashboardConfig/Cycles/'+name+'/Duration'], [TID_KEY, TID_INT, TID_INT]);
    //insert data:
    ODBSet('/DashboardConfig/Cycles/'+name+'/Code[*]', cycle[0]);
    ODBSet('/DashboardConfig/Cycles/'+name+'/Duration[*]', cycle[1]);

    //regrab parameter store; performant enough or update local copy by hand to avoid traffic? TBD.
    fetchODB();

    //include in dropdown if new
    if(deleteCode[0] == 312){
        option = document.createElement('option');
        option.text = name;
        option.value = window.cyclePointer.cycleNames.length;
        window.cyclePointer.cycleNames[window.cyclePointer.cycleNames.length] = name;
        document.getElementById('cycleOptions').add(option, null);
    }
}

//delete a Filter or Cycle option:
function deleteOption(ODBpointer, dropdown){
    var i,
        dropdown = document.getElementById(dropdown),
        cycleIndex = parseInt(dropdown.value, 10),
        name;
        //find name and remove from dropdown
        for(i=0; i<dropdown.childNodes.length; i++){
            if(dropdown.childNodes[i].value == cycleIndex){
                name = dropdown.childNodes[i].innerHTML;
                dropdown.childNodes[i].parentNode.removeChild(dropdown.childNodes[i]);
            }            
        }

    //remove from ODB
    ODBMDelete([ODBpointer+name]);
    //technically the cycle is still floating around in memory now until page refresh.
}

//load the defined cycle into the ODB for present use:
function commitCycle(){

    var cycle = buildCycle(),
        i;

    ODBMDelete(['/DashboardConfig/Cycles/Active Pattern', '/DashboardConfig/Cycles/Active Duration']);
    ODBMCreate(['/DashboardConfig/Cycles/Active Pattern', '/DashboardConfig/Cycles/Active Duration'], [TID_INT, TID_INT]);

    ODBSet('/DashboardConfig/Cycles/Active Pattern[*]', cycle[0]);
    ODBSet('/DashboardConfig/Cycles/Active Duration[*]', cycle[1]);
    ODBSet('/DashboardConfig/Cycles/Active Name', document.getElementById('cycleName').value);

    //regrab ODB
    fetchODB();

    //load the active cycle from the ODB:
    window.cyclePointer.nCycleSummarySteps = 0;
    document.getElementById('cycleSummaryWrapper').innerHTML = '';
    for(i=0; i<ODB.Cycles['Active Pattern'].length; i++){
        createCycleSummaryStep(ODB.Cycles['Active Pattern'][i], ODB.Cycles['Active Duration'][i], Math.floor((i+1)/ODB.Cycles['Active Pattern'].length));
    }

    suspendCycleRequest();
}

//load whatever the ODB has currently registered as the active cycle
function reloadCycle(){
    var i;

    //dump whatever's displayed currently:
    resetCycle();
    //load the active cycle from the ODB:
    for(i=0; i<ODB.Cycles['Active Pattern'].length; i++){
        deployCommand(ODB.Cycles['Active Pattern'][i], ODB.Cycles['Active Duration'][i] );
        if(i==0){
            window.cyclePointer.nCycleSummarySteps = 0;
            document.getElementById('cycleSummaryWrapper').innerHTML = '';
        }
        createCycleSummaryStep(ODB.Cycles['Active Pattern'][i], ODB.Cycles['Active Duration'][i], Math.floor((i+1)/ODB.Cycles['Active Pattern'].length));
    }

    document.getElementById('cycleName').value = ODB.Cycles['Active Name'];

    suspendCycleRequest();
}

//load the chosen cycle
function loadCycle(){
    var i, nSteps, startIndex,
        cycleIndex = parseInt(document.getElementById('cycleOptions').value, 10),  //which cycle has been requested?
        name = document.getElementById('cycleOptions').childNodes[cycleIndex].text;

    //write the name of the cycle in the cycle name box
    document.getElementById('cycleName').value = name;

    //dump whatever's displayed currently:
    resetCycle();

    //weirdness with one-entry array, workaround for now:
    if(ODB.Cycles[name].Code.length > 1){
        for(i=0; i<ODB.Cycles[name].Code.length; i++){
            deployCommand(parseInt(ODB.Cycles[name].Code[i],10), parseInt(ODB.Cycles[name].Duration[i],10));
        }
    } else {
        deployCommand(parseInt(ODB.Cycles[name].Code,10), parseInt(ODB.Cycles[name].Duration,10));
    }

    //if reloading the active cycle, dismiss any requests for cycle deployment:
    if(name == ODB.Cycles['Active Name'])
        suspendCycleRequest();
}

//dump all commands:
function resetCycle(){
    document.getElementById('cycleSteps').innerHTML = ''
    window.cyclePointer.nCycleSteps = 0;
    terminationBadge();
}

//start the deploy cycle button flashing:
function askForCycleDeploy(){
    document.getElementById('commitCycle').style.webkitAnimationName = 'alertBorder';
    document.getElementById('commitCycle').style.mozAnimationName = 'alertBorder';
}

//suspend request for cycle deployment
function suspendCycleRequest(){
    document.getElementById('commitCycle').style.webkitAnimationName = 'x';
    document.getElementById('commitCycle').style.mozAnimationName = 'x';    
}
DANTE.prototype = Object.create(Subsystem.prototype);

function DANTE(){
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'DANTE';
    var that = this;
    Subsystem.call(this);
    this.dataBus = new DANTEDS();
    //make a pointer at window level back to this object, so we can pass by reference to the nav button onclick
    window.DANTEpointer = that;

    //member variables///////////////////////////////////
    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['BGO', 'LaBrTAC', 'LaBrPMT'];

    //set up scale adjust dialog:
    this.canvas.onclick = function(event){
        var y = event.pageY - that.canvas.offsetTop - that.monitor.offsetTop,
            limitIndex = (window.state.subdetectorView < 3) ? window.state.subdetectorView : window.state.subdetectorView-2;
        if(y > that.canvasHeight - that.scaleHeight)
            parameterDialogue(that.name, [ ['LaBrPMT', ODB[that.name][that.constructMinMaxKey('LaBrPMT')][0], ODB[that.name][that.constructMinMaxKey('LaBrPMT')][1], window.parameters.subdetectorUnit[limitIndex], '/DashboardConfig/DANTE/LaBrPMT'+scaleType()+'[0]', '/DashboardConfig/DANTE/LaBrPMT'+scaleType()+'[1]'], ['LaBrTAC', ODB[that.name][that.constructMinMaxKey('LaBrTAC')][0], ODB[that.name][that.constructMinMaxKey('LaBrTAC')][1], window.parameters.subdetectorUnit[limitIndex], '/DashboardConfig/DANTE/LaBrTAC'+scaleType()+'[0]', '/DashboardConfig/DANTE/LaBrTAC'+scaleType()+'[1]'],  ['BGO', ODB[that.name][that.constructMinMaxKey('BGO')][0], ODB[that.name][that.constructMinMaxKey('BGO')][1], window.parameters.subdetectorUnit[limitIndex], '/DashboardConfig/DANTE/BGO'+scaleType()+'[0]', '/DashboardConfig/DANTE/BGO'+scaleType()+'[1]'] ], window.parameters.subdetectorColors[limitIndex]);
    }

    //drawing parameters/////////////////////////////////
    this.centerX = this.canvasWidth/2;
    this.centerY = this.canvasHeight/2;
    this.leftRingCenter = this.canvasWidth*0.25;
    this.rightRingCenter = this.canvasWidth*0.75;
    this.ringRadius = this.canvasHeight*0.2;
    this.detectorRadius = this.canvasWidth*0.03;
    this.shieldInnerRadius = this.canvasWidth*0.05;
    this.shieldOuterRadius = this.canvasWidth*0.06;

    //member functions///////////////////////////////////////////////////////////////////

    this.draw = function(frame){

    	var j, ringCenter, x0, y0, name, fill;
    	this.context.strokeStyle = '#999999';

    	this.context.beginPath();
    	this.context.arc(this.leftRingCenter, this.canvasHeight*0.4, this.ringRadius, 0, 2*Math.PI);
    	this.context.stroke();
    	this.context.beginPath();
    	this.context.arc(this.rightRingCenter, this.canvasHeight*0.4, this.ringRadius, 0, 2*Math.PI);
    	this.context.stroke();

        //once for the display canvas....
    	for(j=0; j<8; j++){
    		if(j<4) ringCenter = this.leftRingCenter;
    		else ringCenter = this.rightRingCenter;

    		x0 = ringCenter + this.ringRadius*Math.cos(Math.PI/2*j);
    		y0 = this.canvasHeight*0.4 - this.ringRadius*Math.sin(Math.PI/2*j);

            //suppressors
            name = 'DAS0'+(j+1)+'XN00X';
            fill = colors(name, this.dataBus.DANTE, frame, this.nFrames);
            this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
    		this.context.beginPath();
    		this.context.arc(x0,y0,this.shieldOuterRadius,0,2*Math.PI);
    		this.context.closePath();
    		this.context.fill();
    		this.context.stroke();

    		this.context.fillStyle = '#333333';
    		this.context.beginPath();
    		this.context.arc(x0,y0,this.shieldInnerRadius,0,2*Math.PI);
    		this.context.closePath();
    		this.context.fill();
    		this.context.stroke();

            //LaBr
            //PMT
            if(window.state.subdetectorView < 3)
                name = 'DAL0'+(j+1)+'XN00X';
            //TAC
            else
                name = 'DAL0'+(j+1)+'XT00X'
            fill = colors(name, this.dataBus.DANTE, frame, this.nFrames);
            this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
    		this.context.beginPath();
    		this.context.arc(x0,y0,this.detectorRadius,0,2*Math.PI);
    		this.context.closePath();
    		this.context.fill();    		
    		this.context.stroke();
    	}
        if(!this.TTlayerDone){
            //....and again for the tooltip encoding
            for(j=0; j<8; j++){
                if(j<4) ringCenter = this.leftRingCenter;
                else ringCenter = this.rightRingCenter;

                x0 = ringCenter + this.ringRadius*Math.cos(Math.PI/2*j);
                y0 = this.canvasHeight*0.4 - this.ringRadius*Math.sin(Math.PI/2*j);

                //hack around to defeat antialiasing problems, fix once there's an option to suppress aa
                this.TTcontext.fillStyle = '#123456';
                this.TTcontext.beginPath();
                this.TTcontext.arc(x0,y0,1.05*this.shieldOuterRadius,0,2*Math.PI);
                this.TTcontext.closePath();
                this.TTcontext.fill();
                //end hack around 

                //suppressors
                name = 'DAS0'+(j+1)+'XN00X';
                this.TTcontext.fillStyle = 'rgba('+this.dataBus.DANTE[name].index+','+this.dataBus.DANTE[name].index+','+this.dataBus.DANTE[name].index+',1)';
                this.TTcontext.beginPath();
                this.TTcontext.arc(x0,y0,this.shieldOuterRadius,0,2*Math.PI);
                this.TTcontext.closePath();
                this.TTcontext.fill();

                this.TTcontext.fillStyle = '#123456';
                this.TTcontext.beginPath();
                this.TTcontext.arc(x0,y0,this.shieldInnerRadius,0,2*Math.PI);
                this.TTcontext.closePath();
                this.TTcontext.fill();

                //LaBr
                //PMT
                if(window.state.subdetectorView < 3)
                    name = 'DAL0'+(j+1)+'XN00X';
                //TAC
                else
                    name = 'DAL0'+(j+1)+'XT00X'
                this.TTcontext.fillStyle = 'rgba('+this.dataBus.DANTE[name].index+','+this.dataBus.DANTE[name].index+','+this.dataBus.DANTE[name].index+',1)';
                this.TTcontext.beginPath();
                this.TTcontext.arc(x0,y0,this.detectorRadius,0,2*Math.PI);
                this.TTcontext.closePath();
                this.TTcontext.fill();            
            }
            this.TTlayerDone = 1;
        }
		
        if(frame==this.nFrames || frame==0) {
            //scale
            this.drawScale(this.context);
    	    //titles
            this.context.clearRect(0,0.75*this.canvasHeight,this.canvasWidth,0.25*this.canvasHeight - this.scaleHeight);
            this.context.fillStyle = '#999999';
            this.context.font="24px 'Orbitron'";
            this.context.fillText('West Ring', this.leftRingCenter - this.context.measureText('West Ring').width/2, 0.8*this.canvasHeight);
            this.context.fillText('East Ring', this.rightRingCenter - this.context.measureText('East Ring').width/2, 0.8*this.canvasHeight);
        }

    };

    this.detectorType = function(name){
        if(name.slice(0,3) == 'DAS') return 'BGO';
        else if(name.slice(6,7) == 'N') return 'LaBrPMT';
        else if(name.slice(6,7) == 'T') return 'LaBrTAC';
    };

    //do an initial populate:
    //this.update();
}function DAQ(canvas, detailCanvas, prefix, postfix){
	var i, j, k, m, nBars, key;

	var that = this;
    //make a pointer at window level back to this object, so we can pass by reference to the nav button onclick
    window.DAQpointer = that;

    //member variables//////////////////////////////////////////////////////////////////////////////////////////////////////////////
    this.monitorID = window.parameters.wrapper;  //div ID of wrapper div
    this.canvasID = 'DAQcanvas';			     //ID of canvas to draw DAQ on
    this.detailCanvasID = 'DAQdetailCanvas';     //ID of canvas to draw detailed view on
    this.linkWrapperID = 'DAQlinks'              //ID of wrapper div for DAQ links
    this.topNavID = 'DAQbutton'                  //ID of button to navigate here in the top nav menu
    this.sidebarID = 'DAQsidebar'                //ID of right sidebar to associate with this object
    this.TTcanvasID = 'DAQTTcanvas'
    this.TTdetailCanvasID = 'DAQdetailTTcanvas'
    this.detailShowing = 0;                      //is the detail canvas showing?
    window.codex = new DAQcodex();               //builds a map of the DAQ

    this.nCollectorGroups = 0;  //fixed for now
    this.nCollectors = window.codex.nCollectors;
    this.nDigitizerGroups = 0;  //fixed for now
    this.nDigitizers = window.codex.nDigitizers;

    this.DAQcolor = 3;

    //scale & insert DAQ canvases & navigation//////////////////////////////////////////////////////////////////////////////////////
    this.monitor = document.getElementById(this.monitorID);
    this.canvasWidth = 0.48*$(this.monitor).width();
    this.collectorWidth = 0.9*(this.canvasWidth-10) / 16;

    //height adjusts to accomodate bar chart in master node:
    nBars = 0;
    for(key in window.codex.detSummary){
        if(window.parameters.validDetectors.indexOf(key) != -1)
            nBars++
    }

    this.canvasHeight = 0.7*$(this.monitor).height() + this.collectorWidth/2*nBars;

    //navigation
    //top level nav button
    injectDOM('button', this.topNavID, 'statusLink', {
        'class' : 'navLink',
        'innerHTML' : 'DAQ',
        'type' : 'button',
        'onclick' : function(){swapView('DAQlinks', 'DAQcanvas', 'DAQsidebar', window.DAQpointer.topNavID); rePaint();}
    });
    //nav wrapper div
    injectDOM('div', this.linkWrapperID, this.monitorID, {'class':'navPanel'});
    //nav header
    injectDOM('h1', 'DAQlinksBanner', this.linkWrapperID, {'class':'navPanelHeader', 'innerHTML':ODB.topLevel.expName+' DAQ Status'});
    injectDOM('br', 'break', this.linkWrapperID, {});
    //nav buttons
    injectDOM('button', 'DAQToplink', 'DAQlinks', {
        'class' : 'navLinkDown',
        'innerHTML' : 'Master',
        'type' : 'button',
        'onclick' : function(){window.DAQpointer.detailShowing=0; window.DAQdetail=-1; swapFade('DAQToplink', window.DAQpointer, 0);}
    });
    injectDOM('br', 'break', this.linkWrapperID, {});
    //p to label row of collector buttons
    injectDOM('p', 'DAQcollectorTitle', 'DAQlinks', {'style':'display:inline; color:#999999; margin-right:5px;', 'innerHTML':'Collector'});
    //deploy collector buttons
    for(i=0; i<this.nCollectors; i++){
        injectDOM('button', 'Collector'+i, this.linkWrapperID, {
            'class' : 'navLink',
            'innerHTML' : ((ODB.DAQ.config == 'GRIFFIN') ? i : i+1),
            'type' : 'button',
            'onclick' : function(){
                window.DAQpointer.detailShowing=1; 
                swapFade(this.id, window.DAQpointer, 0); 
                window.DAQdetail=this.collectorNumber;
                animateDetail(window.DAQpointer, 0); 
            }
        });
        $('#Collector'+i).width( ( 0.95*this.canvasWidth - $('#DAQcollectorTitle').width()) / this.nCollectors );
        document.getElementById('Collector'+i).collectorNumber = i;
    }

    //right sidebar
    //injectDOM('div', this.sidebarID, this.monitorID, {'class':'RightSidebar'});
    injectDOM('div', this.sidebarID, this.monitorID, {}); //dummy sidebar for transitions

    //display canvases
    //top view
    injectDOM('canvas', this.canvasID, this.monitorID, {'class':'monitor', 'style':'top: '+ ($('#DAQlinks').offset().top + $('#DAQlinks').height() + 5) +'px;'});
    this.canvas = document.getElementById(canvas);
    this.context = this.canvas.getContext('2d');
    this.canvas.setAttribute('width', this.canvasWidth);
    this.canvas.setAttribute('height', this.canvasHeight);
    //detailed view
    injectDOM('canvas', this.detailCanvasID, this.monitorID, {'class':'monitor', 'style':'top: '+ ($('#DAQlinks').offset().top + $('#DAQlinks').height() + 5) +'px;'});
    this.detailCanvas = document.getElementById(detailCanvas);
    this.detailContext = this.detailCanvas.getContext('2d');
    this.detailCanvas.setAttribute('width', this.canvasWidth);
    this.detailCanvas.setAttribute('height', this.canvasHeight);
    //Tooltip for summary level
    injectDOM('canvas', this.TTcanvasID, this.monitorID, {'class':'monitor', 'style':'top:' + ($('#DAQlinks').offset().top + $('#DAQlinks').height()*1.25 + 5) +'px;'});
    this.TTcanvas = document.getElementById(this.TTcanvasID);
    this.TTcontext = this.TTcanvas.getContext('2d');
    this.TTcanvas.setAttribute('width', this.canvasWidth);
    this.TTcanvas.setAttribute('height', this.canvasHeight);    
    //hidden Tooltip map layer for detail
    injectDOM('canvas', this.TTdetailCanvasID, this.monitorID, {'class':'monitor', 'style':'top:' + ($('#DAQlinks').offset().top + $('#DAQlinks').height()*1.25 + 5) +'px;'});
    this.TTdetailCanvas = document.getElementById(this.TTdetailCanvasID);
    this.TTdetailContext = this.TTdetailCanvas.getContext('2d');
    this.TTdetailCanvas.setAttribute('width', this.canvasWidth);
    this.TTdetailCanvas.setAttribute('height', this.canvasHeight);    


    //interactions & tooltip setup////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    this.scaleHeight = this.canvasHeight*0.2;

    //onclick switch between top and detail view:
    this.detailCanvas.onclick = function(event){
                                    var y;
                                    y = event.pageY - that.canvas.offsetTop - that.monitor.offsetTop;
                                    if(y>that.canvasHeight - that.scaleHeight){
                                        parameterDialogue('DAQ', [ ['Transfer Rate', ODB.DAQ.transferMinDetailView, ODB.DAQ.transferMaxDetailView, 'Bps', '/DashboardConfig/DAQ/transferMinDetailView', '/DashboardConfig/DAQ/transferMaxDetailView' ], ['Trigger Rate', ODB.DAQ.rateMinDetailView, ODB.DAQ.rateMaxDetailView, 'Hz', '/DashboardConfig/DAQ/rateMinDetailView', '/DashboardConfig/DAQ/rateMaxDetailView']  ], window.parameters.colorScale[window.DAQpointer.DAQcolor]);
                                    } else {
                                        that.detailShowing = 0;
                                        swapFade('DAQToplink', that, 0);
                                    }
                                };
    this.canvas.onclick =   function(event){
                                //use TT layer to decide which collector user clicked on
                                var collectorClicked = -1;
                                var x,y;
                                x = event.pageX - that.canvas.offsetLeft - that.monitor.offsetLeft;
                                y = event.pageY - that.canvas.offsetTop - that.monitor.offsetTop;
                                collectorClicked = that.findCell(x,y);
                                //draw and swap out if user clicked on a valid collector
                                if(collectorClicked > -1 && collectorClicked < 255){
                                    window.DAQdetail = collectorClicked;
                                    that.drawDetail(that.detailContext, that.nFrames);
                                    that.detailShowing = 1;
                                    swapFade('Collector'+(window.DAQdetail), that, 0)
                                }
                                //set up scale range dialogue:
                                if(y>that.canvasHeight - that.scaleHeight){
                                    parameterDialogue('DAQ', [ ['Transfer Rate', ODB.DAQ.transferMinTopView, ODB.DAQ.transferMaxTopView, 'Bps', '/DashboardConfig/DAQ/transferMinTopView', '/DashboardConfig/DAQ/transferMaxTopView' ], ['Trigger Rate', ODB.DAQ.rateMinTopView, ODB.DAQ.rateMaxTopView, 'Hz', '/DashboardConfig/DAQ/rateMinTopView', '/DashboardConfig/DAQ/rateMaxTopView']  ], window.parameters.colorScale[window.DAQpointer.DAQcolor]);
                                } else if(y<that.masterBottom){
                                    parameterDialogue('Device Summary',[ ['Trig Requests', ODB.DAQ.rateMinMaster, ODB.DAQ.transferMaxMaster, 'Hz', '/DashboardConfig/DAQ/rateMinMaster', '/DashboardConfig/DAQ/rateMaxMaster'], ['Data Rate', ODB.DAQ.transferMinMaster, ODB.DAQ.transferMaxMaster, 'Bps', '/DashboardConfig/DAQ/transferMinMaster', '/DashboardConfig/DAQ/transferMaxMaster']  ], false, true);
                                }
                            };

    //Dirty trick to implement tooltip on obnoxious geometry: make another canvas of the same size hidden beneath, with the 
    //detector drawn on it, but with each element filled in with rgba(0,0,n,1), where n is the channel number; fetching the color from the 
    //hidden canvas at point x,y will then return the appropriate channel index.
    //summary level:
    //paint whole hidden canvas with R!=G!=B to trigger TT suppression:
    this.TTcontext.fillStyle = '#123456';
    this.TTcontext.fillRect(0,0,this.canvasWidth, this.canvasHeight);
    //set up summary tooltip:
    this.tooltip = new Tooltip(this.canvasID, 'DAQTT', this.monitorID, prefix, postfix);
    this.tooltip.obj = that;
    //detail level tt:
    //paint whole hidden canvas with R!=G!=B to trigger TT suppression:
    this.TTdetailContext.fillStyle = 'rgba(50,100,150,1)';
    this.TTdetailContext.fillRect(0,0,this.canvasWidth, this.canvasHeight);
    //set up detail tooltip:
    this.detailTooltip = new Tooltip(this.detailCanvasID, 'DAQTTdetail', this.monitorID, prefix, postfix);
    this.detailTooltip.obj = that;


    //drawing parameters////////////////////////////////////////////////////////////////////////////////////////////////////////


    this.cellColor = '#4C4C4C';
    this.lineweight = 5;

    this.margin = this.canvasWidth*0.05;
    this.collectorGutter = 0.1*this.collectorWidth;


       
    this.masterTop = 5;
    this.masterBottom = this.masterTop + (2+nBars)*this.canvasHeight*0.1;
    this.cableLength = 2*(this.canvasHeight*0.7 - (this.masterBottom-this.masterTop) - this.canvasHeight*0.1);
    this.masterGroupLinkTop = this.masterBottom;
    this.masterGroupLinkBottom = this.masterGroupLinkTop + this.cableLength/2;
    this.masterLinkTop = this.masterGroupLinkBottom;
    this.masterLinkBottom = this.masterLinkTop + this.cableLength/2;
    this.collectorTop = this.masterLinkBottom;
    this.collectorBottom = this.canvasHeight*0.78;

    this.masterWidth = this.canvasWidth-2*this.margin;
    this.collectorHeight = this.collectorBottom - this.collectorTop;

    //animation parameters
    this.FPS = 30;
    this.duration = 0.5;
    this.nFrames = this.FPS*this.duration;

    this.inboundCollector = -1;
    this.presentCollector = -1;

    //member functions////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //decide which view to transition to when this object is navigated to
    this.view = function(){
        if(this.detailShowing == 1)
            return this.detailCanvasID;
        else if(this.detailShowing == 0)
            return this.canvasID;
    }

	//update the info for each cell in the monitor
	this.update = function(){
		var i;

        //this.fetchNewData();
        window.codex.update();

        this.tooltip.update();
        this.detailTooltip.update();

        //animate if DAQ is showing:
        this.animate();

	};

    this.draw = function(frame){
        var color, oldColor, i, j, x0, x1, branchColor, combWidth, combColors = [], masterChannel, masterChannelID,
            codex = window.codex,
            headerString, headerHeight, detectors=0, key; 

        this.context.lineWidth = this.lineweight;

        //master node//////////////////////////////////////////////////////
        color = interpolateColor(parseHexColor(codex.DAQmap.oldMasterColor), parseHexColor(codex.DAQmap.masterColor), frame / this.nFrames);
        this.drawMasterNode(this.context, this.TTcontext, color);

        
        if(ODB.DAQ.config == 'TIGRESS'){
            //TIGRESS uses simple 1-1 connectors:
            for(i=0; i<codex.nCollectors; i++){
                //master-collector links///////////////////////////////////////////////
                x0 = this.margin + (i+0.5)*(this.masterWidth / codex.nCollectors);
                context.strokeStyle = '#000000';
                context.beginPath();
                context.moveTo(x0, this.masterBottom);
                context.lineTo(x0, this.masterLinkBottom);
                context.stroke();

                //collectors///////////////////////////////////////////////////////////
                for(j=0; j<codex.nCollectors; j++){
                    this.drawCollectorNode(this.context, this.TTcontext, 0, '#000000', x0 - this.collectorWidth/2, this.masterLinkBottom);
                }

            }
        } else if(ODB.DAQ.config == 'GRIFFIN'){
            //draw combs for each 1-4 connection from master to collectors:
            combWidth = this.masterWidth / (codex.nMasterGroups*1.3 + 0.3);
            for(i=0; i<codex.nMasterGroups; i++){
                //horizontal coord of branch / comb join:
                x1 = this.margin + (i+0.5)*combWidth + (i+1)*0.3*combWidth;
                //collectors///////////////////////////////////////////////////////////
                for(j=0; j<4; j++){
                    //step through all 4 possible master channels on this master group, check if they exist, and if so, draw a collector.
                    masterChannel = (4*parseInt(codex.masterGroupID[i].slice(11, codex.masterGroupID[i].length),10) + j);
                    masterChannelID = 'master' + masterChannel;
                
                    if(codex.DAQmap[masterChannelID]){
                        color = codex.DAQmap[masterChannelID].collectorColor;
                        oldColor = codex.DAQmap[masterChannelID].oldCollectorColor;
                        color = interpolateColor(   parseHexColor(oldColor),
                                                    parseHexColor(color),
                                                    frame/this.nFrames);

                        this.drawCollectorNode(this.context, this.TTcontext, masterChannel, color, x1 - combWidth/2 + j*combWidth/3 - this.collectorWidth/2, this.masterLinkBottom);
                        //determine the master channel color for this connector:
                        color = codex.DAQmap[masterChannelID].masterChannelColor;
                        oldColor = codex.DAQmap[masterChannelID].oldMasterChannelColor;
                        combColors[j] = interpolateColor(   parseHexColor(oldColor),
                                                            parseHexColor(color),
                                                            frame/this.nFrames);
                    } else {
                         combColors[j] = '#000000';                      
                    }
                }
                //master-collector links///////////////////////////////////////////////
                //horizontal coord of branch root:
                //x0 = this.margin + (i+0.5)*(this.masterWidth / codex.nMasterGroups);
                //color of branch and comb spine:
                branchColor = interpolateColor( parseHexColor(codex.DAQmap[codex.masterGroupID[i]].oldMasterGroupColor),
                                                parseHexColor(codex.DAQmap[codex.masterGroupID[i]].masterGroupColor),
                                                frame/this.nFrames
                                            );
                drawBranch(this.context, combColors, combWidth, this.masterLinkBottom - this.masterLinkTop, branchColor, x1, this.masterBottom, x1, this.masterGroupLinkBottom);

                //terminate any dangling wire with a red X:
                for(j=0; j<4; j++){
                    masterChannel = (4*parseInt(codex.masterGroupID[i].slice(11, codex.masterGroupID[i].length),10) + j);
                    masterChannelID = 'master' + masterChannel;
                    if(!codex.DAQmap[masterChannelID]){
                        this.context.strokeStyle = '#FF0000';
                        this.context.beginPath();
                        this.context.moveTo(x1 - combWidth/2 + j*combWidth/3 -10, this.masterLinkBottom -10);
                        this.context.lineTo(x1 - combWidth/2 + j*combWidth/3 +10, this.masterLinkBottom +10);
                        this.context.moveTo(x1 - combWidth/2 + j*combWidth/3 +10, this.masterLinkBottom -10);
                        this.context.lineTo(x1 - combWidth/2 + j*combWidth/3 -10, this.masterLinkBottom +10);
                        this.context.stroke(); 
                    }
                }
            }
        }

        if(frame == 0){
            this.context.clearRect(0, 0, this.margin-3, this.canvasHeight - this.scaleHeight);
            this.drawScale(this.context);

            //labels:
            this.context.fillStyle = '#FFFFFF';
            fontSize = fitFont(this.context, 'Collectors', this.collectorHeight + this.cableLength/2);
            this.context.font = fontSize + 'px Raleway';
            this.context.save();
            this.context.rotate(-Math.PI/2);
            this.context.fillText('Collectors', -(this.collectorTop + this.context.measureText('Collectors').width/2 ),0.7*this.margin);
            this.context.restore();

            fontSize = fitFont(this.context, 'Master', this.collectorHeight + this.cableLength/2);
            this.context.font = fontSize + 'px Raleway';
            this.context.save();
            this.context.rotate(-Math.PI/2);
            this.context.fillText('Master', -( (this.masterBottom-this.masterTop)/2 + this.context.measureText('Master').width/2 ),0.7*this.margin);
            this.context.restore();
        }

        //rate chart
        rateChart(frame, window.codex.detSummary, this.context, this.canvasWidth*0.2, this.masterBottom*0.8, this.canvasWidth*0.6, this.collectorWidth );

        //trigger & event builder reporting:
        //decide how many valid keys are in the det summary:
        for(key in window.codex.detSummary){
            if(window.parameters.validDetectors.indexOf(key) != -1)
                detectors++;
        }
        headerString = 'TRIGGER: Events: ' + parseFloat(window.codex.triggerRate).toFixed(0) + ' Hz; Data: ' + parseFloat(window.codex.triggerDataRate/1000).toFixed(0) + ' Mb/s  EVENT BUILDER: ' + parseFloat(window.codex.EBrate).toFixed(0) + ' Hz; Data: ' + parseFloat(window.codex.EBdataRate/1000).toFixed(0) + ' Mb/s'
        headerHeight = (this.masterBottom*0.8 - detectors*this.collectorWidth - this.masterTop)/2 + this.masterTop;
        this.context.fillStyle = '#FFFFFF';
        this.context.font = fitFont(this.context, headerString, this.canvasWidth*0.8)+'px Raleway';
        this.context.fillText(headerString, this.canvasWidth/2 - this.context.measureText(headerString).width/2, headerHeight);
    };

    this.drawScale = function(context){

        var i, j, string, unit, transferTitle, triggerTitle; 

        context.clearRect(0, this.canvasHeight - this.scaleHeight, this.canvasWidth, this.canvasHeight);

        //titles
        context.fillStyle = '#999999';
        context.font="24px 'Orbitron'";
        context.textBaseline = 'middle';
        if(window.parameters.detectorLogMode.DAQbutton){
            transferTitle = 'log(Transfer Rate)';
            triggerTitle = 'log(Trigger Rate)';
        } else {
            transferTitle = 'Transfer Rate';
            triggerTitle = 'Trigger Rate';
        }
        context.fillText(transferTitle, this.canvasWidth/2 - context.measureText(transferTitle).width/2, this.canvasHeight-this.scaleHeight/2 - 15);
        context.fillText(triggerTitle, this.canvasWidth/2 - context.measureText(triggerTitle).width/2, this.canvasHeight-this.scaleHeight/2 + 20 + 20);
        context.textBaseline = 'alphabetic';

        //tickmark;
        context.strokeStyle = '#999999';
        context.lineWidth = 1;
        context.font="12px 'Raleway'";

        //transfer rate
        //determine unit
        unit = ((context == this.detailContext) ? ODB.DAQ.transferMaxDetailView : ODB.DAQ.transferMaxTopView);
        if(unit > 1000000) unit = ' MBps';
        else if(unit > 1000) unit = ' kBps';
        else unit = ' Bps';
        if(window.parameters.detectorLogMode.DAQbutton) unit = ' log(Bps)';

        context.beginPath();
        context.moveTo(this.canvasWidth*0.05+1, this.canvasHeight - this.scaleHeight/2);
        context.lineTo(this.canvasWidth*0.05+1, this.canvasHeight - this.scaleHeight/2-10);
        context.stroke();
        if(window.parameters.detectorLogMode.DAQbutton) string = Math.log( ((context == this.detailContext) ? ODB.DAQ.transferMinDetailView : ODB.DAQ.transferMinTopView) ) + ' log(Bps)';
        else string = ((context == this.detailContext) ? ODB.DAQ.transferMinDetailView : ODB.DAQ.transferMinTopView) + ' Bps';
        context.fillText( string, this.canvasWidth*0.05 - context.measureText(string).width/2, this.canvasHeight-this.scaleHeight/2-15);

        context.beginPath();
        context.moveTo(this.canvasWidth*0.95-1, this.canvasHeight - this.scaleHeight/2);
        context.lineTo(this.canvasWidth*0.95-1, this.canvasHeight - this.scaleHeight/2-10); 
        context.stroke();  

        string = ((context == this.detailContext) ? ODB.DAQ.transferMaxDetailView : ODB.DAQ.transferMaxTopView);
        if(window.parameters.detectorLogMode.DAQbutton){
            string = Math.log(string).toFixed(1) + unit;
        } else{
            if(string > 1000000) string = string/1000000 + unit;
            else if(string > 1000) string = string/1000 + unit;
            else string = string + unit;
        }            
        context.fillText(string, this.canvasWidth*0.95 - context.measureText(string).width/2, this.canvasHeight-this.scaleHeight/2-15);


        //trigger rate
        //determine unit:
        unit = ((context == this.detailContext) ? ODB.DAQ.rateMaxDetailView : ODB.DAQ.rateMaxTopView);
        if(unit > 1000000) unit = ' MHz';
        else if(unit > 1000) unit = ' kHz';
        else unit = ' Hz';
        if(window.parameters.detectorLogMode.DAQbutton) unit = ' log(Hz)';

        context.beginPath();
        context.moveTo(this.canvasWidth*0.05+1, this.canvasHeight - this.scaleHeight/2 + 20);
        context.lineTo(this.canvasWidth*0.05+1, this.canvasHeight - this.scaleHeight/2 + 20 + 10);
        context.stroke();
        if(window.parameters.detectorLogMode.DAQbutton) string = Math.log( ((context == this.detailContext) ? ODB.DAQ.rateMinDetailView : ODB.DAQ.rateMinTopView) ) + ' log(Hz)';
        else string = ((context == this.detailContext) ? ODB.DAQ.rateMinDetailView : ODB.DAQ.rateMinTopView) + ' Hz';
        context.fillText( string, this.canvasWidth*0.05 - context.measureText(string).width/2, this.canvasHeight-this.scaleHeight/2 + 45);

        context.beginPath();
        context.moveTo(this.canvasWidth*0.95-1, this.canvasHeight - this.scaleHeight/2 + 20);
        context.lineTo(this.canvasWidth*0.95-1, this.canvasHeight - this.scaleHeight/2 + 20 + 10); 
        context.stroke();

        string = ((context == this.detailContext) ? ODB.DAQ.rateMaxDetailView : ODB.DAQ.rateMaxTopView);
        if(window.parameters.detectorLogMode.DAQbutton){
            string = Math.log(string).toFixed(1) + unit;
        } else {
            if(string > 1000000) string = string/1000000 + unit;
            else if(string > 1000) string = string/1000 + unit;
            else string = string + unit;
        }
        context.fillText(string, this.canvasWidth*0.95 - context.measureText(string).width/2, this.canvasHeight-this.scaleHeight/2 + 45);

        for(i=0; i<3000; i++){
            context.fillStyle = scalepickr(0.001*(i%1000), window.parameters.colorScale[this.DAQcolor])//redScale(0.001*(i%1000));
            context.fillRect(this.canvasWidth*0.05 + this.canvasWidth*0.9/1000*(i%1000), this.canvasHeight-this.scaleHeight/2, this.canvasWidth*0.9/1000, 20);
        }

        //make a tooltip hook for the scale; leave a 5px border to kick the cursor back to normal without an onmouseout
        if(context == this.context){
            this.TTcontext.fillStyle = 'rgba(254,254,254,1)';
            this.TTcontext.fillRect(5, this.canvasHeight - this.scaleHeight+5, this.canvasWidth-10, this.canvasHeight-10);
        } else{
        //same for the detail view
            this.TTdetailContext.fillStyle = 'rgba(254,254,254,1)';
            this.TTdetailContext.fillRect(5, this.canvasHeight - this.scaleHeight+5, this.canvasWidth-10, this.canvasHeight-10);
        }

    };

    this.drawMasterNode = function(context, TTcontext, color){

    	context.strokeStyle = color;
    	context.fillStyle = this.cellColor;		
		roundBox(context, this.margin, this.masterTop, this.canvasWidth-2*this.margin, this.masterBottom - this.masterTop, 5);
		context.fill();
        context.stroke();

        //tooltip encoding level:
        TTcontext.fillStyle = 'rgba(255, 255, 255, 1)';
        TTcontext.fillRect(Math.round(this.margin), Math.round(this.masterTop), Math.round(this.masterWidth), Math.round(this.masterBottom - this.masterTop));

    };

    this.drawCollectorNode = function(context, TTcontext, index, color, x0, y0){

    	context.strokeStyle = color;
    	context.fillStyle = this.cellColor;
        roundBox(context, x0, y0, this.collectorWidth, this.collectorBottom - this.collectorTop, 5);
        context.fill();
		context.stroke();

        //tooltip encoding level:
        TTcontext.fillStyle = 'rgba('+index+', '+index+', '+index+', 1)';
        TTcontext.fillRect(Math.round(x0), Math.round(y0), Math.round(this.collectorWidth), Math.round(this.collectorBottom - this.collectorTop) );
    };

    this.drawDetail = function(context, frame){
        var codex = window.codex,   
            masterID = 'master'+window.DAQdetail,
            collectorChannel, collectorChannelID, collectorGroupID, x1, branchColor, combColors = [], combWidth, color, oldColor,
            channelCode = [], triggers = [], transfers = [], oldTriggers = [], oldTransfers = [],
            topMargin = 30;

        context.lineWidth = this.lineweight;

        //white out last frame
        context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
        this.TTdetailContext.fillStyle = '#123456';
        this.TTdetailContext.fillRect(0,0,this.canvasWidth,this.canvasHeight);

        //collector node//////////////////////////////////////////////////////
        color = codex.DAQmap[masterID].collectorColor;
        oldColor = codex.DAQmap[masterID].oldCollectorColor;
        this.drawMasterNode(context, this.TTdetailContext, color); //(use drawMasterNode, looks the same on this view)

        if(ODB.DAQ.config == 'TIGRESS'){  //TBD: test and route colors
            //wires
            combWidth = 0.9*this.masterWidth;
            x1 = this.canvasWidth/2;
            branchColor = '#000000';
            for(i=0; i<codex.nCollectors; i++){
                combColors[i] = '#000000';
            }
            drawBranch(context, combWidth, this.masterBottom - this.masterLinkTop, branchColor, x1, this.masterBottom+parseFloat(context.lineWidth)/2, x1, this.masterGroupLinkBottom);
            //digitizers
            //for(i=0; i<codex.nCollectors; i++){
            for(key in codex.DAQmap[masterID]){
                if(codex.dataKeys.indexOf(key) != -1 || key.indexOf('Group') != -1) continue;
                collectorChannel = parseInt( key.slice(9) ,10);
                color = '#000000';
                this.drawCollectorNode(context, this.TTdetailContext, collectorChannel, color, x1 - combWidth/2 + j*combWidth/(codex.nCollectors-1) - this.collectorWidth/2, this.masterLinkBottom);
            }
        } else if(ODB.DAQ.config == 'GRIFFIN'){
            combWidth = this.masterWidth / (codex.collectorGroupID[masterID].length*1.3 + 0.3);
            //loop over collector groups
            for(i=0; i<codex.collectorGroupID[masterID].length; i++){
                collectorGroupID = codex.collectorGroupID[masterID][i];
                //collector-digitizer links///////////////////////////////////////////////
                //horizontal coord of branch / comb join:
                x1 = this.margin + (i+0.5)*combWidth + (i+1)*0.3*combWidth;
                //color of branch and comb spine reflects total data rate leaving the group of digitizers:
                branchColor = interpolateColor( parseHexColor(codex.DAQmap[masterID][collectorGroupID].oldCollectorGroupColor), 
                                                parseHexColor(codex.DAQmap[masterID][collectorGroupID].collectorGroupColor), 
                                                frame/this.nFrames);
                //step through the collectors in this group, interpolate their color and assign it to combColors if the collector exists.
                for(j=0; j<4; j++){
                    collectorChannelID = 'collector'+( 4*parseInt(codex.collectorGroupID[masterID][i].slice(14),10) + j);
                    if(codex.DAQmap[masterID][collectorChannelID]){
                        oldColor = codex.DAQmap[masterID][collectorChannelID].oldCollectorChannelColor;
                        color = codex.DAQmap[masterID][collectorChannelID].collectorChannelColor;
                        combColors[j] = interpolateColor(parseHexColor(oldColor), parseHexColor(color), frame/this.nFrames);
                    } else
                        combColors[j] = '#000000';
                }

                drawBranch(context, combColors, combWidth, this.masterLinkBottom - this.masterLinkTop, branchColor, x1, this.masterBottom+parseFloat(context.lineWidth)/2, x1, this.masterGroupLinkBottom);
                
                //digitizers///////////////////////////////////////////////////////////
                for(j=0; j<4; j++){
                    //step through all 4 possible collector channels on this collector group, check if they exist, and if so, draw a digitizer.
                    collectorChannel = (4*parseInt(codex.collectorGroupID[masterID][i].slice(14),10) + j);
                    collectorChannelID = 'collector' + collectorChannel;
                
                    if(codex.DAQmap[masterID][collectorChannelID]){
                        color = interpolateColor(parseHexColor(codex.DAQmap[masterID][collectorChannelID].oldDigiColor), parseHexColor(codex.DAQmap[masterID][collectorChannelID].digiColor), frame/this.nFrames);
                        this.drawCollectorNode(context, this.TTdetailContext, collectorChannel, color, x1 - combWidth/2 + j*combWidth/3 - this.collectorWidth/2, this.masterLinkBottom);        
                    } else {
                        //terminate an empty cable with a red X
                        context.strokeStyle = '#FF0000';
                        context.beginPath();
                        context.moveTo(x1 - combWidth/2 + j*combWidth/3 -10, this.masterLinkBottom -10);
                        context.lineTo(x1 - combWidth/2 + j*combWidth/3 +10, this.masterLinkBottom +10);
                        context.moveTo(x1 - combWidth/2 + j*combWidth/3 +10, this.masterLinkBottom -10);
                        context.lineTo(x1 - combWidth/2 + j*combWidth/3 -10, this.masterLinkBottom +10);
                        context.stroke();                        
                    }

                }
                
            }
        }

        //draw scale
        this.drawScale(this.detailContext);
        //generate collector chart:
        //make list of digitizer codes:
        for(key in window.codex.DAQmap['master'+window.DAQdetail]){
            if(codex.dataKeys.indexOf(key) != -1 || key.indexOf('Group') != -1) continue;
            channelCode[channelCode.length] = key;
            triggers[triggers.length] = codex.DAQmap['master'+window.DAQdetail][key].trigRequestRate;
            transfers[transfers.length] = codex.DAQmap['master'+window.DAQdetail][key].dataRate;
            oldTriggers[oldTriggers.length] = codex.DAQmap['master'+window.DAQdetail][key].oldTrigRequestRate;
            oldTransfers[oldTransfers.length] = codex.DAQmap['master'+window.DAQdetail][key].oldDataRate;
        }
        collectorChart(frame,this.detailContext, this.margin + 0.1*(this.canvasWidth-2*this.margin), this.masterBottom*0.9, channelCode, triggers, transfers, oldTriggers, oldTransfers);

        //title
        this.detailContext.fillStyle = '#FFFFFF';
        this.detailContext.textBaseline = 'alphabetic'
        fontSize = fitFont(this.detailContext, 'Digitizers', this.collectorHeight + this.cableLength/2)*1.2;
        this.detailContext.font = fontSize + 'px Raleway';
        this.detailContext.save();
        this.detailContext.rotate(-Math.PI/2);
        this.detailContext.fillText('Digitizers', -this.collectorTop - this.detailContext.measureText('Digitizers').width/2,0.7*this.margin);
        this.detailContext.restore();  

        fontSize = fitFont(this.detailContext, 'Collector '+(window.DAQdetail+1), this.collectorHeight + this.cableLength/2);
        this.detailContext.font = fontSize + 'px Raleway';
        this.detailContext.save();
        this.detailContext.rotate(-Math.PI/2);
        this.detailContext.fillText('Collector '+window.DAQdetail, -( 0.40*this.canvasHeight/2 + topMargin + this.detailContext.measureText('Collector '+window.DAQdetail).width/2 ),0.7*this.margin);
        this.detailContext.restore();
        
    };

    this.findCell = function(x, y){
        var imageData 
        if(this.detailShowing == 1){
            imageData = this.TTdetailContext.getImageData(x,y,1,1);
        } else{
            imageData = this.TTcontext.getImageData(x,y,1,1);
        }
        var index = -1;
        if(imageData.data[0] == imageData.data[1] && imageData.data[0] == imageData.data[2]) index = imageData.data[0];

        return index;
    };

    this.defineText = function(cell){
        //tooltip target encoding:
            //top level view: 
                //master = 255
                //master channel n = n
            //detail level view:
                //collector = 255
                //collector channel n = n

        var toolTipContent, key, data = {}, objects = [], masterKey, collectorKey, channelCodes = [], split = [0],
            table, mezRow, mezCell0, mezCell1,
            keys = ['detector','trigRequestRate', 'dataRate'],
            encodingType = (ODB.DAQ.config == 'GRIFFIN') ? 'MSC' : 'FSPC';

        //top level view////////////////////////////////////////////////////////////////////////
        if(window.onDisplay == this.canvasID){
            if(cell == 255){
                masterSummary();
            } else if(cell == 254){
                toolTipContent = 'Click to adjust scale.'
                document.getElementById(this.tooltip.ttDivID).innerHTML = toolTipContent;
            } else {
                collectorSummary(cell, 'DAQTT');
            }
        //detail level view/////////////////////////////////////////////////////////////////////
        } else if(window.onDisplay == this.detailCanvasID){
            masterKey = 'master' + window.DAQdetail;
            collectorKey = 'collector' + cell;
            //collector:
            if(cell == 255){
                collectorSummary(window.DAQdetail, 'DAQTTdetail');
            //digitizers:
            } else if(cell == 254){
                toolTipContent = 'Click to adjust scale.'
                document.getElementById(this.detailTooltip.ttDivID).innerHTML = toolTipContent;
            } else if(cell >= 0 && cell < 254) {
                //title and summary
                toolTipContent = '<h3>Digitizer on Master Ch. ' + window.DAQdetail + ', Collector Ch. ' + cell + '</h3><br>';
                toolTipContent += 'Total Trigger Rate: ' + window.codex.DAQmap[masterKey][collectorKey].trigRequestRate.toFixed() + ' Hz<br>';
                toolTipContent += 'Total Inbound Data Rate: ' + window.codex.DAQmap[masterKey][collectorKey].dataRate.toFixed() + ' Bps<br><br>';
                document.getElementById(this.detailTooltip.ttDivID).innerHTML = toolTipContent;

                //build up arrays and objects to pass to tooltip table builder in the format it expects:
                for(key in window.codex.DAQmap[masterKey][collectorKey]){
                    if(window.codex.dataKeys.indexOf(key) == -1){
                        data[key] = window.codex.DAQmap[masterKey][collectorKey][key];
                        objects[objects.length] = key;
                        channelCodes[channelCodes.length] = hexString(window.codex.DAQmap[masterKey][collectorKey][key].DAQcode, 4);
                        //stick the first 32 things in the first super column
                        //==everything is one column except TIG64's, which have 1 col per mezannine.
                        if(split[0] < 32) split[0]++;
                        else if(split.length == 1){
                            split[1] = 1;
                            window.state.staticTT = 1; //giant TT can run off of small screens, keep fixed and centered
                        }
                        else split[1]++;
                    }
                }
                TTtable('DAQTTdetail', data, objects, keys, channelCodes, '', [encodingType,'Device','Trig Request Rate [Hz]', 'Outbound Data Rate [Bps]'], split);
                //fudge in a title row for mezzanines:
                if(split.length>1){
                    table = document.getElementById('DAQTTdetailtable');
                    mezRow = table.insertRow(0);
                    mezCell0 = mezRow.insertCell(0);
                    mezCell1 = mezRow.insertCell(1);
                    mezCell0.innerHTML = '<h3>Mezzanine 1</h3>';
                    mezCell1.innerHTML = '<h3>Mezzanine 2</h3>';
                    mezCell0.setAttribute('colspan', 4);
                    mezCell1.setAttribute('colspan', 4);
                }
            }
        }

        return 0
    };

    this.animate = function(){
        if(window.onDisplay == this.canvasID) animate(this, 0);
        if(window.onDisplay == this.detailCanvasID) animateDetail(this, 0);
    };
}

//factor out the collector tooltip construction since it is used in both top level and detail level views:
function collectorSummary(masterCh, ttID){
    var masterKey = 'master' + masterCh,
        keys = ['trigRequestRate', 'dataRate'],
        key, data = {}, objects = [], channelCodes = [], split = [0];

    //title and summary
    toolTipContent = '<h3>Collector on Master Ch. ' + masterCh + '</h3><br>';
    toolTipContent += 'Total Trigger Rate: ' + window.codex.DAQmap[masterKey].trigRequestRate.toFixed() + ' Hz<br>';
    toolTipContent += 'Total Inbound Data Rate: ' + window.codex.DAQmap[masterKey].dataRate.toFixed() + ' Bps<br><br>';                
    document.getElementById(ttID).innerHTML = toolTipContent;

    //make a table of all the collector summaries
    //build up arrays and objects to pass to tooltip table builder in the format it expects:
    for(key in window.codex.DAQmap[masterKey]){
        if(window.codex.dataKeys.indexOf(key) == -1 && key.indexOf('Group') == -1 ){
            data[key] = window.codex.DAQmap[masterKey][key];
            objects[objects.length] = key;
            channelCodes[channelCodes.length] = key.slice(9,key.length);
            //stick the first 32 things in the first super column
            //==everything is one column except TIG64's, which have 1 col per mezannine.
            if(split[0] < 32) split[0]++;
            else if(split.length == 1){
                split[1] = 1;
                window.state.staticTT = 1; //giant TT can run off of small screens, keep fixed and centered
            }
            else split[1]++;
        }
    }

    TTtable(ttID, data, objects, keys, channelCodes, '', ['Collector Ch.','Trig Request Rate [Hz]', 'Outbound Data Rate [Bps]'], split);
}

//TODO: this is almost the same as collectorSummary(), combine?
function masterSummary(){
    var keys = ['trigRequestRate', 'dataRate'],
        key, data = {}, objects = [], channelCodes = [], split = [0];

    //title and summary
    toolTipContent = '<h3>DAQ Master</h3><br>';
    toolTipContent += 'Total Trigger Rate: ' + window.codex.DAQmap.trigRequestRate.toFixed() + ' Hz<br><br>';                
    document.getElementById('DAQTT').innerHTML = toolTipContent;

    //make a table of all the collector summaries
    //build up arrays and objects to pass to tooltip table builder in the format it expects:
    for(key in window.codex.DAQmap){
        if(window.codex.dataKeys.indexOf(key) == -1 && key.indexOf('Group') == -1 ){
            data[key] = window.codex.DAQmap[key];
            objects[objects.length] = key;
            channelCodes[channelCodes.length] = key.slice(6,key.length);
            //stick the first 32 things in the first super column
            //==everything is one column except TIG64's, which have 1 col per mezannine.
            if(split[0] < 32) split[0]++;
            else if(split.length == 1){
                split[1] = 1;
                window.state.staticTT = 1; //giant TT can run off of small screens, keep fixed and centered
            }
            else split[1]++;
        }
    }

    TTtable('DAQTT', data, objects, keys, channelCodes, '', ['Master Ch.','Trig Request Rate [Hz]', 'Outbound Data Rate [Bps]'], split);   
}

//vertical bar chart for digitizer data; x0 y0 represents origin of chart
function collectorChart(frame, context, x0, y0, FSPC, triggers, transfers, oldTriggers, oldTransfers){
    var chartWidth = (window.DAQpointer.canvasWidth - 2*window.DAQpointer.margin)*0.8,
    chartHeight = window.DAQpointer.masterBottom*0.7,
    nDigitizers = FSPC.length,
    barWidth = chartWidth / (nDigitizers*2) *0.95,
    tickmarkLength = 5,
    innerMargin = (window.DAQpointer.canvasWidth - chartWidth - 2*window.DAQpointer.margin)/2,
    i, key;

    context.font = Math.min( 12, fitFont(context, '9.9kBps', innerMargin/1.1 ) ) +'px Raleway';
    //label horizontal axis & draw bars
    context.textBaseline = 'top';
    for(i=0; i<nDigitizers; i++){
        context.fillStyle = '#FFFFFF';
        context.lineWidth = 1;
        context.fillText(FSPC[i], x0+barWidth+i*chartWidth/nDigitizers-context.measureText(FSPC[i]).width/2, y0+2);
        triggerBar(frame, oldTriggers[i], triggers[i], x0+i*chartWidth/nDigitizers, y0);
        transferBar(frame, oldTransfers[i], transfers[i], x0+barWidth+i*chartWidth/nDigitizers+1, y0);
    }

    //draw frame
    context.lineWidth = 1;
    context.fillStyle = '#FFFFFF'
    context.strokeStyle = '#FFFFFF';
    context.beginPath();
    context.moveTo(x0-tickmarkLength,y0 - chartHeight);
    context.lineTo(x0, y0-chartHeight);
    context.lineTo(x0,y0);
    context.moveTo(x0-tickmarkLength,y0);
    context.lineTo(x0+chartWidth+tickmarkLength, y0);
    context.moveTo(x0+chartWidth, y0);
    context.lineTo(x0+chartWidth, y0 - chartHeight);
    context.lineTo(x0+chartWidth+tickmarkLength, y0-chartHeight);
    context.stroke();

    //label vertical axes
    context.textBaseline = 'middle';
    context.fillText(ODB.DAQ.transferMinDetailView/1000 + ' kBps', x0-tickmarkLength-context.measureText(ODB.DAQ.transferMinDetailView/1000 + ' kBps').width, y0 );
    context.fillText(ODB.DAQ.transferMaxDetailView/1000 + ' kBps', x0-tickmarkLength-context.measureText(ODB.DAQ.transferMaxDetailView/1000 + ' kBps').width, y0-chartHeight );
    context.fillText(ODB.DAQ.rateMinDetailView/1000 + ' kHz', x0+chartWidth+tickmarkLength, y0);
    context.fillText(ODB.DAQ.rateMaxDetailView/1000 + ' kHz', x0+chartWidth+tickmarkLength, y0-chartHeight);
    context.save();
    context.translate(x0-innerMargin/2, y0-chartHeight/2)
    context.rotate(-Math.PI/2);
    context.fillText('Transfer', -context.measureText('Transfer').width/2,0);
    context.fillStyle = '#222222';
    context.strokeStyle = '#0000FF';
    context.fillRect(-context.measureText('Transfer').width/2 - innerMargin/5-3,-innerMargin/5/2,innerMargin/5,innerMargin/5);
    context.strokeRect(-context.measureText('Transfer').width/2 - innerMargin/5-3,-innerMargin/5/2,innerMargin/5,innerMargin/5);
    context.restore();
    context.save();
    context.translate(x0+chartWidth+innerMargin/2, y0-chartHeight/2)
    context.rotate(Math.PI/2);
    context.fillText('Triggers', -context.measureText('Triggers').width/2,0);
    context.fillStyle = '#222222';
    context.strokeStyle = '#00FF00';
    context.fillRect(-context.measureText('Triggers').width/2 - innerMargin/5-3,-innerMargin/5/2,innerMargin/5,innerMargin/5);
    context.strokeRect(-context.measureText('Triggers').width/2 - innerMargin/5-3,-innerMargin/5/2,innerMargin/5,innerMargin/5);
    context.restore();

    function transferBar(frame, oldLevel, level, x0, y0){
        var height = (oldLevel - ODB.DAQ.transferMinDetailView) / (ODB.DAQ.transferMaxDetailView - ODB.DAQ.transferMinDetailView)*chartHeight + (  (level - ODB.DAQ.transferMinDetailView)/(ODB.DAQ.transferMaxDetailView - ODB.DAQ.transferMinDetailView) - (oldLevel - ODB.DAQ.transferMinDetailView) / (ODB.DAQ.transferMaxDetailView - ODB.DAQ.transferMinDetailView) )*chartHeight*frame/window.DAQpointer.nFrames;
        if(height>chartHeight) height = chartHeight;
        if(height<0) height = 0;
        context.strokeStyle = '#0000FF';
        context.fillStyle = '#222222';
        context.fillRect(x0,y0-height,barWidth,height)
        context.strokeRect(x0,y0-height,barWidth,height);
        context.save();
        context.translate(x0+barWidth/2, y0-height-2);
        context.rotate(-Math.PI/2);
        context.textBaseline = 'middle';
        context.fillStyle = '#FFFFFF';
        context.fillText(level.toFixed(0) + ' Bps', 0,0);
        context.restore();
    }

    function triggerBar(frame, oldLevel, level, x0, y0){
        var height = (oldLevel - ODB.DAQ.rateMinDetailView) / (ODB.DAQ.rateMaxDetailView - ODB.DAQ.rateMinDetailView)*chartHeight + (  (level - ODB.DAQ.rateMinDetailView)/(ODB.DAQ.rateMaxDetailView - ODB.DAQ.rateMinDetailView) - (oldLevel - ODB.DAQ.rateMinDetailView) / (ODB.DAQ.rateMaxDetailView - ODB.DAQ.rateMinDetailView) )*chartHeight*frame/window.DAQpointer.nFrames;
        if(height>chartHeight) height = chartHeight;
        if(height<0) height = 0;
        context.strokeStyle = '#00FF00';
        context.fillStyle = '#222222';
        context.fillRect(x0,y0-height,barWidth,height);
        context.strokeRect(x0,y0-height,barWidth,height);   
        context.save();
        context.translate(x0+barWidth/2, y0-height-2);
        context.rotate(-Math.PI/2);
        context.textBaseline = 'middle';
        context.fillStyle = '#FFFFFF';
        context.fillText(level.toFixed(0) + ' Hz', 0,0);
        context.restore();     
    }
}


//horizontal bar chart for DAQ data, x0 y0 represent bottom left corner of rendered area:
function rateChart(frame, data, context, x0, y0, maxLength, barWidth){

    var fontSize = 0.8*barWidth,
    legendFont = Math.min(fontSize, 16),
    row = 0,  //counts up from bottom
    key,
    rateScaleMin = ODB.DAQ.rateMinMaster,
    dataScaleMin = ODB.DAQ.transferMinMaster;    
    rateScaleMax = ODB.DAQ.rateMaxMaster,
    dataScaleMax = ODB.DAQ.transferMaxMaster;

    context.font = fontSize+'px Raleway';
    context.lineWidth = 1;

    //draw chart
    for(key in data){
        
        if(window.parameters.validDetectors.indexOf(key) != -1){  //only accept reports from actual devices listed in the parameters
            context.fillStyle = '#FFFFFF';
            context.textBaseline = 'middle';
            context.font = fontSize+'px Raleway';
            context.fillText(key+':', x0 - context.measureText(key+':').width, y0 - (barWidth+4)*(row+1/2) );
            drawTrigBar(key, frame);
            drawDataBar(key, frame);

            row++;
        }
        
    }

    function drawTrigBar(key, frame){
        var length = (data[key].prevTrigReqRate-rateScaleMin)/(rateScaleMax-rateScaleMin)*maxLength + ((data[key].totalTrigRequestRate-rateScaleMin)/(rateScaleMax-rateScaleMin) - (data[key].prevTrigReqRate-rateScaleMin)/(rateScaleMax-rateScaleMin))*maxLength*frame/window.DAQpointer.nFrames;
        if(length > maxLength) length = maxLength;
        if(length < 0) length = 0;
        context.strokeStyle = '#00FF00';
        context.fillStyle = '#222222';
        context.fillRect(1.1*x0, y0 - (barWidth+4)*(row+1), length, barWidth/2-2);
        context.strokeRect(1.1*x0, y0 - (barWidth+4)*(row+1), length, barWidth/2-2);
        context.fillStyle = '#FFFFFF';
        context.font = fontSize*0.6+'px Raleway';
        var text = (data[key].totalTrigRequestRate/1000 > 9999) ? (data[key].totalTrigRequestRate/1000).toExponential(0) : (data[key].totalTrigRequestRate/1000).toFixed(0);
        text += ' kHz';
        context.fillText( text, 1.1*x0 + length + 5,  y0 - (barWidth+4)*(row+1) + barWidth/4 - 1);
    }

    function drawDataBar(key, frame){
        var length = (data[key].prevDataRate-dataScaleMin)/(dataScaleMax-dataScaleMin)*maxLength + ((data[key].totalDataRate-dataScaleMin)/(dataScaleMax-dataScaleMin) - (data[key].prevDataRate-dataScaleMin)/(dataScaleMax-dataScaleMin))*maxLength*frame/window.DAQpointer.nFrames;
        if(length > maxLength) length = maxLength;
        if(length < 0) length = 0;
        context.strokeStyle = '#0000FF';
        context.fillStyle = '#222222';
        context.fillRect(1.1*x0, y0 - (barWidth+4)*(row+1) + barWidth/2+2, length, barWidth/2-2);
        context.strokeRect(1.1*x0, y0 - (barWidth+4)*(row+1) + barWidth/2+2, length, barWidth/2-2);
        context.fillStyle = '#FFFFFF';
        context.font = fontSize*0.6+'px Raleway';

        var text = (data[key].totalDataRate/1000 > 9999) ? (data[key].totalDataRate/1000).toExponential(0) : (data[key].totalDataRate/1000).toFixed(0);
        text += ' kBps';
        context.fillText( text, 1.1*x0 + length + 5,  y0 - (barWidth+4)*(row+1) + barWidth/2+2 + barWidth/4 - 1);
    }

    //draw decorations:
    context.strokeStyle = '#FFFFFF';
    context.fillStyle = '#FFFFFF';
    context.beginPath();
    context.moveTo(1.1*x0-2, y0 - (barWidth+4)*row);
    context.lineTo(1.1*x0-2, y0);
    context.lineTo(1.1*x0+maxLength, y0);
    context.lineTo(1.1*x0+maxLength, y0+5);
    context.stroke();
    context.beginPath();
    context.moveTo(1.1*x0-2, y0);
    context.lineTo(1.1*x0-2, y0+5);
    context.stroke();

    context.font = legendFont*0.7+'px Raleway';
    //trig request labels
    context.fillText('Trig Requests: '+(rateScaleMin/1000).toFixed(0)+' kHz', 1.1*x0-2 - context.measureText('Trig Requests: 0 kHz').width/2, y0+5+legendFont*0.7 );
    context.fillText('Trig Requests: '+(rateScaleMax/1000).toFixed(0)+' kHz', 1.1*x0+maxLength - context.measureText('Trig Requests: '+(rateScaleMax/1000).toFixed(0)+' kHz').width/2, y0+5+legendFont*0.7 );
    context.fillStyle = '#222222';
    context.strokeStyle = '#00FF00';
    context.fillRect(1.1*x0+maxLength - context.measureText('Trig Requests: '+(rateScaleMax/1000).toFixed(0)+' kHz').width/2 - legendFont*0.7*1.5, y0+5+legendFont*0.35, legendFont*0.7, legendFont*0.7);
    context.strokeRect(1.1*x0+maxLength - context.measureText('Trig Requests: '+(rateScaleMax/1000).toFixed(0)+' kHz').width/2 - legendFont*0.7*1.5, y0+5+legendFont*0.35, legendFont*0.7, legendFont*0.7);
    context.fillRect(1.1*x0-2 - context.measureText('Trig Requests: '+(rateScaleMin/1000).toFixed(0)+' kHz').width/2 - legendFont*0.7*1.5, y0+5+legendFont*0.35, legendFont*0.7, legendFont*0.7);
    context.strokeRect(1.1*x0-2 - context.measureText('Trig Requests: '+(rateScaleMin/1000).toFixed(0)+' kHz').width/2 - legendFont*0.7*1.5, y0+5+legendFont*0.35, legendFont*0.7, legendFont*0.7);

    //data rate labels, left aligned with trig request labels
    context.fillStyle = '#FFFFFF';
    context.fillText('Data Rate: '+(dataScaleMin/1000).toFixed(0)+' kBps', 1.1*x0-2 - context.measureText('Trig Requests: 0 kHz').width/2, y0+10+2*legendFont*0.7 );
    context.fillText('Data Rate: '+(dataScaleMax/1000).toFixed(0)+' kBps', 1.1*x0+maxLength - context.measureText('Trig Requests: '+(rateScaleMax/1000).toFixed(0)+' kHz').width/2, y0+10+2*legendFont*0.7 );
    context.fillStyle = '#222222';
    context.strokeStyle = '#0000FF';
    context.fillRect(1.1*x0+maxLength - context.measureText('Trig Requests: '+(rateScaleMax/1000).toFixed(0)+' kHz').width/2 - legendFont*0.7*1.5, y0+10+legendFont*1.05, legendFont*0.7, legendFont*0.7);
    context.strokeRect(1.1*x0+maxLength - context.measureText('Trig Requests: '+(rateScaleMax/1000).toFixed(0)+' kHz').width/2 - legendFont*0.7*1.5, y0+10+legendFont*1.05, legendFont*0.7, legendFont*0.7);
    context.fillRect(1.1*x0-2 - context.measureText('Trig Requests: '+(rateScaleMin/1000).toFixed(0)+' kHz').width/2 - legendFont*0.7*1.5, y0+10+legendFont*1.05, legendFont*0.7, legendFont*0.7);
    context.strokeRect(1.1*x0-2 - context.measureText('Trig Requests: '+(rateScaleMin/1000).toFixed(0)+' kHz').width/2 - legendFont*0.7*1.5, y0+10+legendFont*1.05, legendFont*0.7, legendFont*0.7);
}








//Codex imports a table from which the DAQ is mapped
DAQcodex = function(){
    var i, j, k, masterKey, collectorKey, digiKey, collectorGroupKey;

    //Parse DAQ Assets///////////////////////////////////////////////////////////////////////
    //pull the FSPC (TIGRESS) or MSC (GRIFFIN) table info in from the ODB
    if(ODB.DAQ.config == 'TIGRESS'){
        this.DAQpath = ['/Analyzer/Parameters/Cathode/Config/Name[*]', '/Analyzer/Parameters/Cathode/Config/FSCP[*]'];       
        this.DAQtable = ODBMGet(this.DAQpath);
    } else {
        this.DAQpath = ['/DashboardConfig/DAQ/Channel', '/DashboardConfig/DAQ/MSC'];
        this.DAQtable = JSON.parse(ODBMCopy(this.DAQpath));
        this.DAQtable[0] = this.DAQtable[0]['Channel'] //crush the metadata
        this.DAQtable[1] = this.DAQtable[1]['MSC']
    }
    this.Name        = this.DAQtable[0];
    this.encodedDAQ  = this.DAQtable[1];
    this.nRows       = this.DAQtable[0].length;

    //parse into DAQ levels, and sort:    
    this.table = [];
    this.masterChannel = [];  //channel master is recieving this data on
    this.collectorChannel = [];   //channel collector is recieving on
    this.digiChannel = [];    //individual digitizer channel
    //this.DAQmap = {};
    //this.detSummary = {};

    if(ODB.DAQ.config == 'TIGRESS'){
        for(i=0; i<this.nRows; i++){
            this.masterChannel = (this.encodedDAQ[i] & 0xFF00000) >> 20;
            this.collectorChannel = (this.encodedDAQ[i] & 0xFFF00) >> 8;
            this.digiChannel = this.encodedDAQ[i] & 0xFF;
            this.table.push({
                master: this.masterChannel[i],
                collector: this.collectorChannel[i],
                digi: this.digiChannel[i],
                Name: this.Name[i],
                encoded: this.encodedDAQ[i]
            });
        }
    } else { //GRIFFIN
        for(i=0; i<this.nRows; i++){
            this.masterChannel[i] = (this.encodedDAQ[i] & 0xF000) >> 12; //corresponds to 'M' in GRIFFIN MSC, the master channel
            this.collectorChannel[i] = (this.encodedDAQ[i] & 0x0F00) >> 8; //corresponds to 'S' in GRIFFIN MSC, the collector channel
            this.digiChannel[i] = this.encodedDAQ[i] & 0x00FF; //corresponds to 'C' in GRIFFIN MSC, the individual digitizer
            this.table.push({
                master : this.masterChannel[i],
                collector : this.collectorChannel[i],
                digi : this.digiChannel[i],
                Name : this.Name[i],
                encoded : this.encodedDAQ[i]
            });             
        }
    }

    function sortDAQ(a, b){
        if(a.master == b.master){
            if(a.collector == b.collector){
                if(a.digi == b.digi){
                    return -9999; //this should never happen, indicates a channel appearing in the ODB DAQ table twice.
                } else {
                    if (a.digi > b.digi) return 1;
                    if (a.digi < b.digi) return -1;
                    else return 0;                        
                }                 
            } else {
                if (a.collector > b.collector) return 1;
                if (a.collector < b.collector) return -1;
                else return 0;                    
            }
        } else {
            if (a.master > b.master) return 1;
            if (a.master < b.master) return -1;
            else return 0;                
        }
    } 

    this.table.sort(sortDAQ);  
    this.master = []; this.collector = []; this.digi = []; this.Name = [], this.encoded = [];

    for(i=0; i<this.table.length; i++){
        this.master[i] = this.table[i].master;
        this.collector[i] = this.table[i].collector;
        this.digi[i] = this.table[i].digi;
        this.Name[i] = this.table[i].Name.slice(0,10).toUpperCase();
        this.encoded[i] = this.table[i].encoded;
    }
    this.nRows = this.table.length;

    //loop over all rows, creating an object that reflects the structure of the DAQ:
    this.DAQmap = {};
    this.detSummary = {};
    this.nMasterGroups = 0;
    this.nCollectorGroups = 0;
    for(i=0; i<this.nRows; i++){

        //build keys
        masterKey = 'master'+this.master[i];
        collectorKey  = 'collector'+this.collector[i];
        digiKey   = 'digi'+this.digi[i];
        //GRIFFIN uses 4-1 cables to plug 4 digitizers into one channel on the collector, will need its own color:
        collectorGroupKey = 'collectorGroup' + Math.floor(this.collector[i]/4);
        //...and similarly for 4-1 cables between collectors and master:
        masterGroupKey = 'masterGroup' + Math.floor(this.master[i]/4);

        //navigate through the DAQmap to declare the data object for each channel, creating new child objects as necessary.
        //DAQmap structure is 
        //DAQmap{
        //    masterXX : {
        //        collectorYY : {
        //            digiZZ : {<raw data>},
        //            <more digitizers>, 
        //            collectorYY summary data: <data>
        //            collectorYY colors
        //        },
        //        <more collector channels>,
        //        masterXX summary data: <data>,
        //        <collector groups for GRIFFIN>
        //        masterXX colors
        //    },
        //    <more master channels>,
        //    top level summary data: <data>
        //    <master groups for GRIFFIN>
        //}

        if(this.DAQmap[masterKey]){
            //data pointers
            this.DAQmap[masterKey].trigRequestRate = 0; //how many trig requests are arriving at master on this master channel?
            this.DAQmap[masterKey].dataRate = 0; //what is the data rate arriving at master on this master channel?
            //colors
            this.DAQmap[masterKey].oldCollectorColor = '#00FF00';
            this.DAQmap[masterKey].collectorColor = '#00FF00';
            this.DAQmap[masterKey].oldMasterChannelColor = '#00FF00';
            this.DAQmap[masterKey].masterChannelColor = '#00FF00';
            if(this.DAQmap[masterKey][collectorKey]){
                //data pointers
                this.DAQmap[masterKey][collectorKey].trigRequestRate = 0;  //how many trig requests are arriving at this collector on this channel?
                this.DAQmap[masterKey][collectorKey].dataRate = 0;         //what is the inbound data rate to this collector on this channel?              
                this.DAQmap[masterKey][collectorKey][digiKey] = {'detector' : this.Name[i], 'DAQcode' : this.encoded[i], 'trigRequestRate' : 0, 'dataRate' : 0};
                this.detSummary[this.Name[i].slice(0,3)] = {'totalTrigRequestRate' : 0, 'prevTrigReqRate' : 0, 'totalDataRate' : 0, 'prevDataRate' : 0};
                //colors
                this.DAQmap[masterKey][collectorKey].oldDigiColor = '#00FF00';
                this.DAQmap[masterKey][collectorKey].digiColor = '#00FF00';
                this.DAQmap[masterKey][collectorKey].oldCollectorChannelColor = '#00FF00';
                this.DAQmap[masterKey][collectorKey].collectorChannelColor = '#00FF00';               
            } else{
                this.DAQmap[masterKey][collectorKey] = {};
                i--;
            }
            //GRIFFIN uses 1-4 connectors between digitizers and collectors:
            if(this.DAQmap[masterKey][collectorGroupKey]){
                //data pointer
                this.DAQmap[masterKey][collectorGroupKey].dataRate = 0;
                //colors
                this.DAQmap[masterKey][collectorGroupKey].oldCollectorGroupColor = '#00FF00';
                this.DAQmap[masterKey][collectorGroupKey].collectorGroupColor = '#00FF00';
            } else{
                this.DAQmap[masterKey][collectorGroupKey] = {};
                this.nCollectorGroups++;
            }
            
        } else{
            this.DAQmap[masterKey] = {};
            i--;
        }
        //GRIFFIN uses 1-4 connectors between master and collectors:
        if(this.DAQmap[masterGroupKey]){
            //data pointer
            this.DAQmap[masterGroupKey].dataRate = 0;
            //colors
            this.DAQmap[masterGroupKey].oldMasterGroupColor = '#00FF00';
            this.DAQmap[masterGroupKey].masterGroupColor = '#00FF00';
        } else{
            this.DAQmap[masterGroupKey] = {};
            this.nMasterGroups++;
        }
        
    }
    this.DAQmap.trigRequestRate = 0; //what is the total trigger request rate to master?
    this.DAQmap.oldMasterColor = '#00FF00';
    this.DAQmap.masterColor = '#00FF00';

    //keep track of all the key names in the DAQmap that contain data directly, and aren't part of the hierarchy, so we can ignore them when traversing the DAQ tree:
    this.dataKeys = [ 'detector', 'DAQcode', 'trigRequestRate', 'dataRate', 'oldTrigRequestRate', 'oldDataRate',
                      'oldCollectorColor', 'collectorColor', 'oldMasterChannelColor', 'masterChannelColor', 
                      'oldDigiColor', 'digiColor', 'oldCollectorChannelColor', 'collectorChannelColor',
                      'oldCollectorGroupColor', 'collectorGroupColor', 'oldMasterGroupColor', 'masterGroupColor',
                      'oldMasterColor', 'masterColor'];
    //construct some convenient summaries of keys and structures//////////////////////////////////////////////////
    //count how many collectors are present == number of distinct master channels
    this.nCollectors = 0;
    for(masterKey in this.DAQmap){
        if(this.dataKeys.indexOf(masterKey) == -1 && masterKey.indexOf('Group') == -1)
            this.nCollectors++;
    }
    //count how many digitizers are present in total and also on each collector:
    this.nDigitizers = 0;
    this.nDigitizersPerCollector = [];
    i = 0;
    for(masterKey in this.DAQmap){
        if(this.dataKeys.indexOf(masterKey) == -1){
            this.nDigitizersPerCollector[i] = 0;
            for(collectorKey in this.DAQmap[masterKey]){
                if(this.dataKeys.indexOf(collectorKey) == -1){
                    this.nDigitizers++;
                    this.nDigitizersPerCollector[i]++;
                }
            }
            i++;
        }
    }
    //make an array of all the master groups present
    this.masterGroupID = [];
    for(i=0; i<Object.keys(this.DAQmap).length; i++){
        if(Object.keys(this.DAQmap)[i].indexOf('Group') != -1)
            this.masterGroupID[this.masterGroupID.length] = Object.keys(this.DAQmap)[i];
    }
    //make an object containing all the collector groups present as arrays pointed at by their corresponding masterID:
    this.collectorGroupID = {};
    i=0;
    k=0;
    while(k<this.nCollectors){
        if(this.DAQmap['master'+i]){
            this.collectorGroupID['master'+i] = [];
            for(j=0; j<Object.keys(this.DAQmap['master'+i]).length; j++){
                if(Object.keys(this.DAQmap['master'+i])[j].indexOf('Group') != -1)
                    this.collectorGroupID['master'+i][this.collectorGroupID['master'+i].length] = Object.keys(this.DAQmap['master'+i])[j];
            }
            k++;          
        }
        i++;
    }

    //member functions////////////////////////////////////////////////////////////////////////////////////////////////
    //parse scalar into a color on a color scale bounded by min and max 
    this.parseColor = function(scalar, min, max){
        //how far along the scale are we?
        var scale 
        if(window.parameters.detectorLogMode.DAQbutton){
            scale = (Math.log(scalar) - Math.log(min)) / (Math.log(max) - Math.log(min));
        } else {
            scale = (scalar - min) / (max - min);
        }
        if(scale<0) scale = 0;
        if(scale>1) scale = 1;

        //return redScale(scale);
        return scalepickr(scale, window.parameters.colorScale[window.DAQpointer.DAQcolor])
    };

    //populate this.DAQmap with all the relevant information from the JSONPstore.
    this.update = function(){
        
        var key, masterKey, collectorKey, digiKey, collectorGroupKey, masterGroupKey, name;

        //get summary data from ODB
        this.triggerRate = parseFloat(window.localODB.TrigEPS).toFixed(1);
        this.triggerDataRate = parseFloat(window.localODB.TrigDPS).toFixed(1);
        this.EBrate = parseFloat(window.localODB.EBEPS).toFixed(1);
        this.EBdataRate = parseFloat(window.localODB.EBDPS).toFixed(1);


        //zero out the detector totals from last iteration:
        for(key in this.detSummary){
            this.detSummary[key].prevTrigReqRate = this.detSummary[key].totalTrigRequestRate;
            this.detSummary[key].totalTrigRequestRate = 0;

            this.detSummary[key].prevDataRate = this.detSummary[key].totalDataRate;
            this.detSummary[key].totalDataRate = 0;            
        }

        //sort data from JSON post into the DAQmap every update///////////////////////////////////////////
        //reset the master level summary:
        this.DAQmap.trigRequestRate = 0;
        //loop over the DAQmap:
        for(masterKey in this.DAQmap){
            //reset any GRIFFIN-style master group link summaries:
            if(masterKey.indexOf('Group') != -1)
                this.DAQmap[masterKey].dataRate = 0;  

            //bail out if this key isn't a master, collector or digitizer
            if(this.dataKeys.indexOf(masterKey) != -1 || masterKey.indexOf('Group') != -1) continue;

            //construct which master group we're in (only matters for GRIFFIN)
            masterGroupKey = 'masterGroup' + Math.floor(parseInt(masterKey.slice(6,masterKey.length),10)/4);

            //reset all the master-link level summaries:
            this.DAQmap[masterKey].trigRequestRate = 0;
            this.DAQmap[masterKey].dataRate = 0;

            //move on to per-collector link level:
            for(collectorKey in this.DAQmap[masterKey]){
                //reset any GRIFFIN-style collector group link summaries:
                if(collectorKey.indexOf('Group') != -1)
                    this.DAQmap[masterKey][collectorKey].dataRate = 0;

                //bail out if this key isn't a master, collector or digitizer
                if(this.dataKeys.indexOf(collectorKey) != -1 || collectorKey.indexOf('Group') != -1 ) continue;

                //construct which collector group we're in (only matters for GRIFFIN)
                collectorGroupKey = 'collectorGroup' + Math.floor(parseInt(collectorKey.slice(9,collectorKey.length),10)/4);

                //reset all the collector-link level summaries:
                this.DAQmap[masterKey][collectorKey].oldTrigRequestRate = this.DAQmap[masterKey][collectorKey].trigRequestRate;
                this.DAQmap[masterKey][collectorKey].oldDataRate = this.DAQmap[masterKey][collectorKey].dataRate;                
                this.DAQmap[masterKey][collectorKey].trigRequestRate = 0;
                this.DAQmap[masterKey][collectorKey].dataRate = 0;

                //move on to per-digitzer level:
                for(digiKey in this.DAQmap[masterKey][collectorKey]){
                    //bail out if this key isn't a master, collector or digitizer
                    if(this.dataKeys.indexOf(digiKey) != -1) continue;

                    //codename of the detector we're pointing at
                    name = this.DAQmap[masterKey][collectorKey][digiKey].detector; 

                    //get the base per channel data from the JSON store if it exists:
                    if(window.JSONPstore['scalar'] && window.JSONPstore['scalar'][name]){
                        this.DAQmap[masterKey][collectorKey][digiKey].trigRequestRate = window.JSONPstore['scalar'][name]['TRIGREQ'];
                        this.DAQmap[masterKey][collectorKey][digiKey].dataRate = window.JSONPstore['scalar'][name]['dataRate'];
                    }

                    //add the triggers and data rates from each digitizer to the downstream objects they contribute to:
                    //digitizer trigger rate:
                    this.DAQmap[masterKey][collectorKey].trigRequestRate += this.DAQmap[masterKey][collectorKey][digiKey].trigRequestRate;
                    //outbound digitizer link:
                    this.DAQmap[masterKey][collectorKey].dataRate += this.DAQmap[masterKey][collectorKey][digiKey].dataRate;
                    //collector group data rate (the 1 side of GRIFFIN 4-1 cables)
                    this.DAQmap[masterKey][collectorGroupKey].dataRate += this.DAQmap[masterKey][collectorKey][digiKey].dataRate;
                    //collector trigger rate:
                    this.DAQmap[masterKey].trigRequestRate += this.DAQmap[masterKey][collectorKey][digiKey].trigRequestRate;
                    //collector outbound data rate:
                    this.DAQmap[masterKey].dataRate += this.DAQmap[masterKey][collectorKey][digiKey].dataRate;
                    //master group data rate (the 1 side of GRIFFIN 4-1 cables)
                    this.DAQmap[masterGroupKey].dataRate += this.DAQmap[masterKey][collectorKey][digiKey].dataRate;
                    //master triger rate
                    this.DAQmap.trigRequestRate += this.DAQmap[masterKey][collectorKey][digiKey].trigRequestRate;

                    //also add these numbers to the per-subsystem summary statistics:
                    this.detSummary[ name.slice(0,3) ].totalTrigRequestRate += this.DAQmap[masterKey][collectorKey][digiKey].trigRequestRate;
                    this.detSummary[ name.slice(0,3) ].totalDataRate += this.DAQmap[masterKey][collectorKey][digiKey].dataRate;
                }
                //use the totals to pick a color for the digitizer:
                this.DAQmap[masterKey][collectorKey].oldDigiColor = this.DAQmap[masterKey][collectorKey].digiColor;
                this.DAQmap[masterKey][collectorKey].digiColor = this.parseColor(this.DAQmap[masterKey][collectorKey].trigRequestRate, ODB.DAQ.rateMinDetailView, ODB.DAQ.rateMaxDetailView);
                //pick a color for the outbound digitizer to collector link:
                this.DAQmap[masterKey][collectorKey].oldCollectorChannelColor = this.DAQmap[masterKey][collectorKey].collectorChannelColor;
                this.DAQmap[masterKey][collectorKey].collectorChannelColor = this.parseColor(this.DAQmap[masterKey][collectorKey].dataRate, ODB.DAQ.transferMinDetailView, ODB.DAQ.transferMaxDetailView);
            }
            //loop over collector groups and assign their colors
            for(collectorKey in this.DAQmap[masterKey]){
                //bail out if this key isn't a collector group
                if(collectorKey.indexOf('Group') == -1 ) continue;
                //pick a color for the collector group link (GRIFFIN)
                this.DAQmap[masterKey][collectorKey].oldCollectorGroupColor = this.DAQmap[masterKey][collectorKey].collectorGroupColor;
                this.DAQmap[masterKey][collectorKey].collectorGroupColor = this.parseColor(this.DAQmap[masterKey][collectorKey].dataRate, ODB.DAQ.transferMinDetailView, ODB.DAQ.transferMaxDetailView);
            }
            //use the totals to pick a color for the collector:
            this.DAQmap[masterKey].oldCollectorColor = this.DAQmap[masterKey].collectorColor;
            this.DAQmap[masterKey].collectorColor = this.parseColor(this.DAQmap[masterKey].trigRequestRate, ODB.DAQ.rateMinTopView, ODB.DAQ.rateMaxTopView);
            //pick a color for the outbound collector to master link:
            this.DAQmap[masterKey].oldMasterChannelColor = this.DAQmap[masterKey].masterChannelColor;
            this.DAQmap[masterKey].masterChannelColor = this.parseColor(this.DAQmap[masterKey].dataRate, ODB.DAQ.transferMinTopView, ODB.DAQ.transferMaxTopView);
            //pick a color for the master group link (GRIFFIN)
            this.DAQmap[masterGroupKey].oldMasterGroupColor = this.DAQmap[masterGroupKey].masterGroupColor;
            this.DAQmap[masterGroupKey].masterGroupColor = this.parseColor(this.DAQmap[masterGroupKey].dataRate, ODB.DAQ.transferMinTopView, ODB.DAQ.transferMaxTopView);
        }
        //use the totals to pick a color for the master:
        this.DAQmap.oldMasterColor = this.DAQmap.masterColor;
        this.DAQmap.masterColor = this.parseColor(this.DAQmap.trigRequestRate, ODB.DAQ.rateMinMaster, ODB.DAQ.rateMaxMaster);
    };

}





DESCANT.prototype = Object.create(Subsystem.prototype);

function DESCANT(){
    var i, j;
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'DESCANT';
    var that = this;
    Subsystem.call(this);
    this.dataBus = new DESCANTDS();
    window.DESCANTpointer = that;

    //member variables///////////////////////////////////
    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['DESCANT'];

    //drawing parameters//////////////////////////////////////////////////////////////////////////////////
	//center of DESCANT
	this.centerX = $(this.canvas).width() / 2;
	this.centerY = $(this.canvas).height()*0.43;

	//scale at which to draw DESCANT in pixels relative mm in blueprint:
	this.scale = 0.28;

	//pixels to explode DESCANT view by:
	this.explode = 10;

	//linewidth
	this.context.lineWidth = 3;

	//side length of pentagon hole:
	this.pentagonSide = 83*this.scale;
	//shortest distance from center of pentagon to side
	this.pentagonNormal = this.pentagonSide / 2 / Math.tan(36/180 * Math.PI);
	//longest distance from center of pentagon to side
	this.pentagonVertex = this.pentagonSide / 2 / Math.sin(36/180 * Math.PI);

	//member functions//////////////////////////////////////////////////////


	this.draw = function(frame){

		var i, j, key, fill;
		this.context.clearRect(0,0,this.canvasWidth, this.canvasHeight-this.scaleHeight);

        for(key in this.dataBus.DESCANT){
            //i = this.dataBus.DESCANT[key].index - 1;
            i = this.chMap(this.dataBus.DESCANT[key].index);
			this.context.save();
			this.context.translate(this.centerX, this.centerY);
			this.context.rotate(this.drawRules[i][3]);
			fill = colors(key, this.dataBus.DESCANT, frame, this.nFrames);
			this.context.fillStyle =  (fill == 0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;

			if(this.drawRules[i][0] == 'white')whiteDetector(this.context, this.drawRules[i][1], this.drawRules[i][2], this.scale, 0, 0);
			else if(this.drawRules[i][0] == 'red') redDetector(this.context, this.drawRules[i][1], this.drawRules[i][2], this.scale, 0, this.drawRules[i][4], 0);
			else if(this.drawRules[i][0] == 'blue') blueDetector(this.context, this.drawRules[i][1], this.drawRules[i][2], this.scale, 0, this.drawRules[i][4], 0);
			else if(this.drawRules[i][0] == 'greenLeft') greenLeftDetector(this.context, this.drawRules[i][1], this.drawRules[i][2], this.scale, 0, this.drawRules[i][4], 0);
			else if(this.drawRules[i][0] == 'greenRight') greenRightDetector(this.context, this.drawRules[i][1], this.drawRules[i][2], this.scale, 0, this.drawRules[i][4], 0);

			this.context.restore();
		}

		if(!this.TTlayerDone){
			//and the same again for the hidden TT info canvas:
			this.TTcontext.fillStyle = '#123456'
			this.TTcontext.fillRect(0,0,this.canvasWidth, this.canvasHeight);
			for(key in this.dataBus.DESCANT){
	            //i = this.dataBus.DESCANT[key].index - 1;
	            i = this.chMap(this.dataBus.DESCANT[key].index);
				this.TTcontext.save();
				this.TTcontext.translate(this.centerX, this.centerY);
				this.TTcontext.rotate(this.drawRules[i][3]);

				this.TTcontext.fillStyle = 'rgba('+this.dataBus.DESCANT[key].index+','+this.dataBus.DESCANT[key].index+','+this.dataBus.DESCANT[key].index+',1)';

				if(this.drawRules[i][0] == 'white')whiteDetector(this.TTcontext, this.drawRules[i][1], this.drawRules[i][2], this.scale, 0, 1);
				else if(this.drawRules[i][0] == 'red') redDetector(this.TTcontext, this.drawRules[i][1], this.drawRules[i][2], this.scale, 0, this.drawRules[i][4], 1);
				else if(this.drawRules[i][0] == 'blue') blueDetector(this.TTcontext, this.drawRules[i][1], this.drawRules[i][2], this.scale, 0, this.drawRules[i][4], 1);
				else if(this.drawRules[i][0] == 'greenLeft') greenLeftDetector(this.TTcontext, this.drawRules[i][1], this.drawRules[i][2], this.scale, 0, this.drawRules[i][4], 1);
				else if(this.drawRules[i][0] == 'greenRight') greenRightDetector(this.TTcontext, this.drawRules[i][1], this.drawRules[i][2], this.scale, 0, this.drawRules[i][4], 1);

				this.TTcontext.restore();
				this.TTlayerDone = 1;
			}
		}
		

        if(frame==this.nFrames || frame==0) {
            //scale
            this.drawScale(this.context);
        }

	};

	//array of rules for drawing DESCANT channels.  Array index should correspond to real channel number; packed as [type, center x, center y, canvas rotation, element rotation]
	this.drawRules = [];
	for(i=0; i<5; i++){
		this.drawRules[1+0 + i*8] = ['white', 0, 0 - this.pentagonNormal-71.9*this.scale, (i-1)*72/180*Math.PI];
		this.drawRules[1+1 + i*8] = ['white', 0, 0 - this.pentagonNormal-(223.4 + this.explode/0.4)*this.scale, (i-1)*72/180*Math.PI];
		this.drawRules[1+2 + i*8] = ['white', 0, 0 - this.pentagonNormal-(374.9 + 2*this.explode/0.4)*this.scale, (i-1)*72/180*Math.PI];
		this.drawRules[1+3 + i*8] = ['white', 0, 0 - this.pentagonNormal-(526.4 + 3*this.explode/0.4)*this.scale, (i-1)*72/180*Math.PI];
		this.drawRules[1+4 + i*8] = ['greenLeft',  0, 0 - this.pentagonNormal - this.scale*(706.25 + this.explode), (i*72 - 60)/180*Math.PI, 10/180*Math.PI];
		this.drawRules[1+5 + i*8] = ['greenLeft',  0, 0 - this.pentagonNormal - this.scale*(681.25 + this.explode), (i*72 - 45)/180*Math.PI, 0];
		this.drawRules[1+6 + i*8] = ['greenRight', 0, 0 - this.pentagonNormal - this.scale*(681.25 + this.explode), (i*72 - 27)/180*Math.PI, -3/180*Math.PI];
		this.drawRules[1+7 + i*8] = ['greenRight', 0, 0 - this.pentagonNormal - this.scale*(706.25 + this.explode), (i*72 - 12)/180*Math.PI, -13/180*Math.PI];
		this.drawRules[1+40 + i*3] = ['red', 0, 0 - this.pentagonVertex - this.scale*(167.9 + this.explode), (i*72 + 324)/180*Math.PI, Math.PI/2];
		this.drawRules[1+41 + i*3] = ['red', 0, 0 - this.pentagonNormal - this.scale*(516.25 + this.explode), (i*72 - 55)/180*Math.PI, Math.PI/2 + 15/180*Math.PI]
		this.drawRules[1+42 + i*3] = ['red', 0, 0 - this.pentagonNormal - this.scale*(516.25 + this.explode), (i*72 - 16)/180*Math.PI, Math.PI/2 - 15/180*Math.PI]
		this.drawRules[1+55 + i*3] = ['blue',0, 0 - this.pentagonNormal - this.scale*(356.25 + this.explode), (i*72 - 49)/180*Math.PI, -Math.PI*22/180]
		this.drawRules[1+56 + i*3] = ['blue',0, 0 - this.pentagonNormal - this.scale*(356.25 + this.explode), (i*72 - 23)/180*Math.PI, Math.PI*22/180]
		this.drawRules[1+57 + i*3] = ['blue',0, 0 - this.pentagonNormal - this.scale*(516.25 + this.explode), (i*72 - 36)/180*Math.PI, Math.PI*90/180]
	}

    //do an initial populate:
    //this.update();

    //they changed the detector numbering on me.  Here's a function to map from the new numbering scheme to the old one used in the rest of the code.
    this.chMap = function(newIndex){
    	var oldIndex;

    	if(newIndex < 6)
    		oldIndex = newIndex + (newIndex-1)*7;
    	else if(newIndex < 16){
    		if(newIndex%2 == 0)
    			oldIndex = 2 + (newIndex-6)/2*8;
    		else
    			oldIndex = 41 + (newIndex-7)/2*3;
    	} else if(newIndex < 31){
    		if( newIndex%3 == 1 )
    			oldIndex = 3 + (newIndex-16)/3*8;
    		else
    			oldIndex = 57 + newIndex-18;
    	} else if(newIndex < 51){
    		if( newIndex%4 == 3 )
    			oldIndex = 4 + (newIndex-31)/4*8;
    		else if( newIndex%4 == 0 )
    			oldIndex = 42 + (newIndex-32)/4*3;
    		else if( newIndex%4 == 1 )
    			oldIndex = 58 + (newIndex-33)/4*3;
    		else
    			oldIndex = 43 + (newIndex-34)/4*3;
    	} else{
    		if( newIndex==51 ) oldIndex = 40;
    		else
    			oldIndex = newIndex - 47 + 4*Math.floor((newIndex-52)/4)
    	}
    	return oldIndex;
    }

}








DSSD.prototype = Object.create(Subsystem.prototype);

function DSSD(){
    var i, j;
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'DSSD';
    var that = this;
    Subsystem.call(this);
    this.dataBus = new DSSDDS();
    window.DSSDpointer = that;
    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['DSSD'];

    //drawing parameters//////////////////////////////////////////////////////////////////////////////////

    //3 rows by 4 column grid
    this.gutterSize = 0.1*this.canvasHeight*0.8;
    this.DSSDside = 0.2*this.canvasHeight*0.8;
    this.stripWidth = this.DSSDside/16;
    this.margin = (this.canvasWidth - 1.1*this.canvasHeight*0.8)/2;

    this.context.strokeStyle = '#999999';

    //member functions////////////////////////////////////////////////////////////////////////////////////
    this.draw = function(frame){
        this.context.font = '14px Raleway'
        this.context.clearRect(0,0,this.canvasWidth,this.canvasHeight*0.8);
        
        //DSSDs:
        //column 1:
        this.drawStrips('MAD01DP', this.margin, this.gutterSize, frame);
        this.drawStrips('MAD01DN', this.margin, 2*this.gutterSize+this.DSSDside, frame);

        //column 2:
        this.drawStrips('MAD02DP', this.margin+this.gutterSize+this.DSSDside, this.gutterSize, frame);
        this.drawStrips('MAD02DN', this.margin+this.gutterSize+this.DSSDside, 2*this.gutterSize+this.DSSDside, frame);

        //column 3:
        this.drawStrips('MAD03DP', this.margin+2*this.gutterSize+2*this.DSSDside, this.gutterSize, frame);
        this.drawStrips('MAD03DN', this.margin+2*this.gutterSize+2*this.DSSDside, 2*this.gutterSize+this.DSSDside, frame);

        //column 4:
        this.drawStrips('MAD04DP', this.margin+3*this.gutterSize+3*this.DSSDside, this.gutterSize, frame);
        this.drawStrips('MAD04EP', this.margin+3*this.gutterSize+3*this.DSSDside, 2*this.gutterSize+this.DSSDside, frame);
        this.drawStrips('MAD04EN', this.margin+3*this.gutterSize+3*this.DSSDside, 3*this.gutterSize+2*this.DSSDside, frame);

        //Pads:
        var pads = ['MAD01ENXXX', 'MAD02ENXXX', 'MAD03ENXXX'], key;
        for(var i=0; i<3; i++){
            key = pads[i];
            //if(window.JSONPstore['scalar'][key]){
                //choose fill color:
                if(window.state.subdetectorView == 0) this.context.fillStyle = interpolateColor(parseHexColor(this.dataBus.DSSD[key].oldHVcolor), parseHexColor(this.dataBus.DSSD[key].HVcolor), frame/this.nFrames);
                else if(window.state.subdetectorView == 1) this.context.fillStyle = interpolateColor(parseHexColor(this.dataBus.DSSD[key].oldThresholdColor), parseHexColor(this.dataBus.DSSD[key].thresholdColor), frame/this.nFrames);
                else if(window.state.subdetectorView == 2) this.context.fillStyle = interpolateColor(parseHexColor(this.dataBus.DSSD[key].oldRateColor), parseHexColor(this.dataBus.DSSD[key].rateColor), frame/this.nFrames); 
                if(this.context.fillStyle == 0xDEADBEEF) this.context.fillStyle = this.context.createPattern(window.parameters.warningFill, 'repeat');
                this.TTcontext.fillStyle = 'rgba('+this.dataBus.DSSD[key].index+','+this.dataBus.DSSD[key].index+','+this.dataBus.DSSD[key].index+',1)';

                this.context.fillRect(this.margin+i*(this.DSSDside+this.gutterSize), 3*this.gutterSize+2*this.DSSDside, this.DSSDside, this.DSSDside );
                this.context.strokeRect(this.margin+i*(this.DSSDside+this.gutterSize), 3*this.gutterSize+2*this.DSSDside, this.DSSDside, this.DSSDside );
                this.TTcontext.fillRect(this.margin+i*(this.DSSDside+this.gutterSize), 3*this.gutterSize+2*this.DSSDside, this.DSSDside, this.DSSDside );

                //draw title
                this.context.textBaseline = 'top';
                this.context.fillStyle = '#999999';
                this.context.clearRect(this.margin+i*(this.DSSDside+this.gutterSize), 3*this.gutterSize+3*this.DSSDside+2 , this.DSSDside, this.gutterSize*0.8);
                this.context.fillText(pads[i], this.margin+i*(this.DSSDside+this.gutterSize)+this.DSSDside/2 - this.context.measureText(pads[i]).width/2, 3*this.gutterSize+3*this.DSSDside+5 );
                this.context.closePath();
            //}
        }        

        //titles
        this.context.clearRect(0,0,this.canvasWidth, 0.98*this.gutterSize);
        for(i=0; i<4; i++){
            this.context.font = '16px Raleway';
            this.context.textBaseline = 'alphabetic';
            this.context.fillText('MAD0'+(i+1), this.margin + this.DSSDside/2 + i*(this.DSSDside+this.gutterSize) - this.context.measureText('MAD0'+(i+1)).width/2, this.gutterSize*0.85 )
        }

        //draw a frame around the DSSDs:
        this.context.strokeRect(this.margin-5, this.gutterSize-5, this.DSSDside+10, 2*this.DSSDside+this.gutterSize+5+25);
        this.context.strokeRect(this.margin-5 + this.DSSDside+this.gutterSize, this.gutterSize-5, this.DSSDside+10, 2*this.DSSDside+this.gutterSize+5+25);
        this.context.strokeRect(this.margin-5 + 2*this.DSSDside+2*this.gutterSize, this.gutterSize-5, this.DSSDside+10, 2*this.DSSDside+this.gutterSize+5+25);
        this.context.strokeRect(this.margin-5 + 3*this.DSSDside+3*this.gutterSize, this.gutterSize-5 + this.DSSDside+this.gutterSize, this.DSSDside+10, 2*this.DSSDside+this.gutterSize+5+25);

        if(frame==this.nFrames || frame==0) {
            //scale
            this.drawScale(this.context);
        }

    };

    //draw a DSSD array
    this.drawStrips = function(DSSDid, x0, y0, frame){
        var i=0, j,
        key, x, y,
        keys = this.genKeys(DSSDid);

        //draw strips
        for(j=0; j<keys.length; j++){
            key = keys[j];
            //choose fill color:
            if(window.state.subdetectorView == 0) this.context.fillStyle = interpolateColor(parseHexColor(this.dataBus.DSSD[key].oldHVcolor), parseHexColor(this.dataBus.DSSD[key].HVcolor), frame/this.nFrames);
            else if(window.state.subdetectorView == 1) this.context.fillStyle = interpolateColor(parseHexColor(this.dataBus.DSSD[key].oldThresholdColor), parseHexColor(this.dataBus.DSSD[key].thresholdColor), frame/this.nFrames);
            else if(window.state.subdetectorView == 2) this.context.fillStyle = interpolateColor(parseHexColor(this.dataBus.DSSD[key].oldRateColor), parseHexColor(this.dataBus.DSSD[key].rateColor), frame/this.nFrames);
            if(this.context.fillStyle == 0xDEADBEEF) this.context.fillStyle = this.context.createPattern(window.parameters.warningFill, 'repeat');
            
            //also for TT layer:
            this.TTcontext.fillStyle = 'rgba('+this.dataBus.DSSD[key].index+','+this.dataBus.DSSD[key].index+','+this.dataBus.DSSD[key].index+',1)';

            if(DSSDid[6] == 'N'){
                x = x0;
                y = y0+this.stripWidth*i;
                this.context.fillRect(x,y,this.DSSDside,this.stripWidth);
                this.context.strokeRect(x,y,this.DSSDside,this.stripWidth);
                this.TTcontext.fillRect(x,y,this.DSSDside,this.stripWidth);
            } else if(DSSDid[6] == 'P'){
                x = x0+this.stripWidth*i;
                y = y0;
                this.context.fillRect(x,y,this.stripWidth,this.DSSDside);
                this.context.strokeRect(x,y,this.stripWidth,this.DSSDside);
                this.TTcontext.fillRect(x,y,this.stripWidth,this.DSSDside);
            }

            i++;
        }

        //draw title
        this.context.textBaseline = 'top';
        this.context.fillStyle = '#999999';
        this.context.clearRect(x0, y0+this.DSSDside+2 , this.DSSDside, this.gutterSize*0.8);
        this.context.fillText(DSSDid, x0+this.DSSDside/2 - this.context.measureText(DSSDid).width/2, y0+this.DSSDside+5 );
    };

    //generate the keys for one set of 16 DSSD strips from minimal info, return in an array:
    this.genKeys = function(DSSD){
        var i, keys = [];

        for(i=0; i<16; i++){
            keys[i] = DSSD + ((i<10) ? ('0'+i) : i ) + 'X';
        }

        return keys;
    };




}function Dashboard(){

    var subsPresent, subsNames, key, that = this;

	this.wrapperID = window.parameters.wrapper;             //ID of wrapping div
	this.canvasID = 'DashboardCanvas';	                    //ID of canvas to paint dashboard on
    this.linkWrapperID = 'DashboardLinks';                  //ID of div to contain clock view header
    this.sidebarID = 'dashboardMenus';                      //ID of dashboard sidebar div
    this.labels = [ODB.topLevel.HPGeArray, ODB.topLevel.HPGeArray, ODB.topLevel.HPGeArray, 0, 0, 0, 'DUMP']      //names of corona, downstream lamp, upstream lamp, corona auxilary, chamber ds, chamber us, beamdump detectors
    this.pointers = []; //global pointers to subsystems, to fetch the correct total rate for each section
    //colors:
    this.USLcolor = '#000000';
    this.USLoldColor = '#000000';
    this.coronaColor = '#000000';
    this.coronaOldColor = '#000000';
    this.auxCoronaColor = '#000000';
    this.auxCoronaOldColor = '#000000';
    this.DSLcolor = '#000000';
    this.DSLoldColor = '#000000';
    this.DSchamberColor = '#000000';
    this.DSchamberOldColor = '#000000';
    this.USchamberColor = '#000000';
    this.USchamberOldColor = '#000000';
    this.dumpColor = '#000000';
    this.dumpOldColor = '#000000';

    //determine which detectors go where:
    //HPGe, overwritten below if absent:
    this.pointers[0] = window.HPGepointer;
    this.pointers[1] = window.HPGepointer;
    this.pointers[2] = window.HPGepointer;
    //corona auxilary
    if(ODB.DANTE){
        this.labels[3] = 'DANTE';
        this.pointers[3] = window.DANTEpointer;
    }
    //chamber
    if(ODB.BAMBINO && ODB.BAMBINO.USdeploy){  //upstream BAMBINO
        this.labels[5] = 'BAMBINO';
        this.pointers[5] = window.BAMBINOpointer;
    }
    if(ODB.BAMBINO && ODB.BAMBINO.DSdeploy){  //downstream BAMBINO
        this.labels[4] = 'BAMBINO';
        this.pointers[5] = window.BAMBINOpointer;
    }
    if(ODB.SHARC){
        this.labels[4] = 'SHARC';
        this.pointers[4] = window.SHARCpointer;
    }
    if(ODB.TIPwall){
        this.labels[4] = 'TIP Wall';
        this.pointers[4] = window.TIPwallpointer;
    }
    if(ODB.TIPball){
        this.labels[4] = 'TIP Ball';
        this.pointers[4] = window.TIPballpointer;
    }
    if(ODB.SCEPTAR && ODB.SCEPTAR.USdeploy){ //upstream SCEPTAR
        this.labels[5] = 'SCEPTAR';
        this.pointers[5] = window.SCEPTARpointer;
    }
    if(ODB.SCEPTAR &&  ODB.SCEPTAR.DSdeploy == 1){ //downstream SCEPTAR
        this.labels[4] = 'SCEPTAR';
        this.pointers[4] = window.SCEPTARpointer;
    }
    if(ODB.SCEPTAR && ODB.SCEPTAR.DSdeploy == 2){ //ZDS
        this.labels[4] = 'ZDS';
        this.pointers[4] = window.ZDSpointer;
    }
    if(ODB.PACES){
        this.labels[5] = 'PACES';
        this.pointers[5] = window.PACESpointer;
    }
    if(ODB.SPICE){
        this.labels[5] = 'SPICE';
        this.pointers[5] = window.SPICEpointer;
    }
    //downstream lampshade
    if(ODB.DESCANT){
        this.labels[1] = 'DESCANT';
        this.pointers[1] = window.DESCANTpointer;
    }
    //upstream lampshade
    if(ODB.SPICE){
        this.labels[2] = 0;
        this.pointers[2] = window.SPICEpointer;
    }

	this.wrapper = document.getElementById(this.wrapperID);
    
/*  --redeploy sidebar when I decide what to actually use it for :)
    //right sidebar menus
    subsPresent = [ODB.topLevel.HPGeArray];
    subsNames = [ODB.topLevel.HPGeArray];
    for(key in window.parameters.deployment){
        if(window.parameters.deployment[key] && key!='HPGe'){
            subsPresent[subsPresent.length] = key;
            if(key == 'TIPwall')
                subsNames[subsNames.length] = 'TIP Wall';
            else if(key == 'TIPball')
                subsNames[subsNames.length] = 'TIP Ball'
            else
                subsNames[subsNames.length] = key;
        }
    }
    deployMenu(this.sidebarID, subsPresent , subsNames);
*/
    injectDOM('div', this.sidebarID, this.wrapperID, {}); //dummy sidebar for transitions

    //add top level nav button:
    injectDOM('button', 'DashboardButton', 'statusLink', {
        'class' : 'navLinkDown',
        'innerHTML' : 'Dashboard',
        'type' : 'button',
        'onclick' : function(){swapView('DashboardLinks', 'DashboardCanvas', 'dashboardMenus', 'DashboardButton'); rePaint();}
    });

    //nav wrapper div
    injectDOM('div', this.linkWrapperID, this.wrapperID, {'class':'navPanel'});
    //dashboard is the initial view, put the navbar on top:
    document.getElementById(this.linkWrapperID).setAttribute('style', 'z-index:1; opacity:1;')

    //nav header
    injectDOM('h1', 'DashboardLinksBanner', this.linkWrapperID, {'class':'navPanelHeader', 'innerHTML':ODB.topLevel.expName+' Dashboard'});
    injectDOM('br', 'break', this.linkWrapperID, {});

	//deploy a canvas for the dashboard view:
    this.canvasWidth = 0.48*$(this.wrapper).width();
    this.canvasHeight = 0.9*$(this.wrapper).height();
    injectDOM('canvas', this.canvasID, this.wrapperID, {'class':'monitor', 'style':'position:absolute; left:24%; top:' + ($('#DashboardLinks').offset().top + $('#DashboardLinks').height() + 5) +'px;'});
    this.canvas = document.getElementById('DashboardCanvas');
    this.context = this.canvas.getContext('2d');
    this.canvas.setAttribute('width', this.canvasWidth)
    this.canvas.setAttribute('height', this.canvasHeight)
    this.scaleHeight = 0.2*this.canvasHeight;

    this.canvas.onclick =   function(event){
                                var y,
                                    coords = this.relMouseCoords(event);
                                y = coords.y;
                                if(y>that.canvasHeight - that.scaleHeight){
                                    parameterDialogue('Dashboard', [ ['Rate', parseFloat(ODB.Dashboard.dashboardMin), parseFloat(ODB.Dashboard.dashboardMax), 'Hz', '/DashboardConfig/Dashboard/dashboardMin', '/DashboardConfig/Dashboard/dashboardMax' ]  ], 'Sunset' );
                                }
                            };

    this.canvas.onmousemove =   function(event){
                                    var x, y,
                                        coords = this.relMouseCoords(event);
                                    x = coords.x;
                                    y = coords.y;
                                    if(y>that.canvasHeight - that.scaleHeight && y<that.canvasHeight - 5 && x>5 && x<that.canvasWidth-5){
                                        document.body.style.cursor = 'pointer';
                                    } else
                                        document.body.style.cursor = 'auto';
                                }

    //drawing parameters:
    this.x0 = this.canvasWidth / 2;
    this.y0 = this.canvasHeight*0.4;
    this.outerRad = this.canvasHeight*0.36;
    this.innerRad = this.canvasHeight*0.2;
    this.gapArc = Math.PI/180 * 5;
    this.lampshadeArc = Math.PI/180 * 25;
    this.coronaArc = Math.PI/180 * 60;
    this.auxCoronaArc = Math.PI/180 * 10;
    this.beampipeArc = Math.PI - this.coronaArc - 2*this.auxCoronaArc - 4*this.gapArc - 2*this.lampshadeArc;



    //establish animation parameters////////////////////////////////////////////////////////////////////
    this.FPS = 30;
    this.duration = 0.5;
    this.nFrames = this.FPS*this.duration;

    //data buffers///////////////////////////

    //member functions/////////////////////////////////////////////

    this.draw = function(frame){
        var fill;

        this.context.strokeStyle = '#999999';
        this.context.lineWidth = 1;

        this.context.clearRect(0,0,this.canvasWidth, this.canvasHeight-this.scaleHeight);

        //downstream lampshade
        fill = interpolateColor(parseHexColor(this.DSLoldColor), parseHexColor(this.DSLcolor), frame/this.nFrames);
        this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
        //port side
        this.context.beginPath();
        this.context.arc(this.x0, this.y0, this.outerRad, -this.coronaArc/2 - 2*this.gapArc - this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, -this.coronaArc/2 - 2*this.gapArc - this.auxCoronaArc - this.lampshadeArc - this.beampipeArc, false);
        this.context.arc(this.x0, this.y0, this.innerRad, -this.coronaArc/2 - 2*this.gapArc - this.auxCoronaArc - this.lampshadeArc - this.beampipeArc, -this.coronaArc/2 - 2*this.gapArc - this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, true);
        this.context.closePath();
        this.context.fill();
        this.context.stroke();
        //starboard side
        this.context.beginPath();
        this.context.arc(this.x0, this.y0, this.outerRad, -this.coronaArc/2 - 2*this.gapArc - this.auxCoronaArc - this.lampshadeArc, -this.coronaArc/2 - 2*this.gapArc - this.auxCoronaArc, false);
        this.context.arc(this.x0, this.y0, this.innerRad, -this.coronaArc/2 - 2*this.gapArc - this.auxCoronaArc, -this.coronaArc/2 - 2*this.gapArc - this.auxCoronaArc - this.lampshadeArc, true);
        this.context.closePath();
        this.context.fill();
        this.context.stroke();      

        if(this.labels[2]){
            //upstream lampshade  
            fill = interpolateColor(parseHexColor(this.USLoldColor), parseHexColor(this.USLcolor), frame/this.nFrames);
            this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
            //port side
            this.context.beginPath();
            this.context.arc(this.x0, this.y0, this.outerRad, -1.5*this.coronaArc - 6*this.gapArc - 3*this.auxCoronaArc - 3*this.lampshadeArc - this.beampipeArc, -1.5*this.coronaArc - 6*this.gapArc - 3*this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, false);
            this.context.arc(this.x0, this.y0, this.innerRad, -1.5*this.coronaArc - 6*this.gapArc - 3*this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, -1.5*this.coronaArc - 6*this.gapArc - 3*this.auxCoronaArc - 3*this.lampshadeArc - this.beampipeArc, true);
            this.context.closePath();
            this.context.fill();
            this.context.stroke();
            //starboard side
            this.context.beginPath();
            this.context.arc(this.x0, this.y0, this.outerRad, this.coronaArc/2 + 2*this.gapArc + this.auxCoronaArc, this.coronaArc/2 + 2*this.gapArc + this.auxCoronaArc + this.lampshadeArc, false);
            this.context.arc(this.x0, this.y0, this.innerRad, this.coronaArc/2 + 2*this.gapArc + this.auxCoronaArc + this.lampshadeArc, this.coronaArc/2 + 2*this.gapArc + this.auxCoronaArc, true);
            this.context.closePath();
            this.context.fill();
            this.context.stroke();  
        }

        if(this.labels[3]){
            //downstream auxillary corona
            fill = interpolateColor(parseHexColor(this.auxCoronaOldColor), parseHexColor(this.auxCoronaColor), frame/this.nFrames);
            this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
            //port side
            this.context.beginPath();
            this.context.arc(this.x0, this.y0, this.outerRad, -this.coronaArc/2 - 3*this.gapArc - 2*this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, -this.coronaArc/2 - 3*this.gapArc - this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, false);
            this.context.arc(this.x0, this.y0, this.innerRad, -this.coronaArc/2 - 3*this.gapArc - this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, -this.coronaArc/2 - 3*this.gapArc - 2*this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, true);
            this.context.closePath();
            this.context.fill();
            this.context.stroke();
            //starboard side
            this.context.beginPath();
            this.context.arc(this.x0, this.y0, this.outerRad, -this.coronaArc/2 - this.gapArc - this.auxCoronaArc, -this.coronaArc/2 - this.gapArc, false);
            this.context.arc(this.x0, this.y0, this.innerRad, -this.coronaArc/2 - this.gapArc, -this.coronaArc/2 - this.gapArc - this.auxCoronaArc, true);
            this.context.closePath();
            this.context.fill();
            this.context.stroke();      

            //upstream auxilary corona
            //port side
            this.context.beginPath();
            this.context.arc(this.x0, this.y0, this.outerRad, -1.5*this.coronaArc - 5*this.gapArc - 3*this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, -1.5*this.coronaArc - 5*this.gapArc - 2*this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, false);
            this.context.arc(this.x0, this.y0, this.innerRad, -1.5*this.coronaArc - 5*this.gapArc - 2*this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, -1.5*this.coronaArc - 5*this.gapArc - 3*this.auxCoronaArc - 2*this.lampshadeArc - this.beampipeArc, true);
            this.context.closePath();
            this.context.fill();
            this.context.stroke();
            //starboard side
            this.context.beginPath();
            this.context.arc(this.x0, this.y0, this.outerRad, this.coronaArc/2 + this.gapArc, this.coronaArc/2 + this.gapArc + this.auxCoronaArc, false);
            this.context.arc(this.x0, this.y0, this.innerRad, this.coronaArc/2 + this.gapArc + this.auxCoronaArc, this.coronaArc/2 + this.gapArc, true);
            this.context.closePath();
            this.context.fill();
            this.context.stroke();      
        }

        //corona
        fill = interpolateColor(parseHexColor(this.coronaOldColor), parseHexColor(this.coronaColor), frame/this.nFrames);
        this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
        //port corona
        this.context.beginPath();
        this.context.arc(this.x0, this.y0, this.outerRad, -Math.PI -0.5*this.coronaArc, -Math.PI + 0.5*this.coronaArc, false);
        this.context.arc(this.x0, this.y0, this.innerRad, -Math.PI + 0.5*this.coronaArc, -Math.PI - 0.5*this.coronaArc, true);
        this.context.closePath();
        this.context.fill();
        this.context.stroke();
        //starboard corona
        this.context.beginPath();
        this.context.arc(this.x0, this.y0, this.outerRad, -0.5*this.coronaArc, 0.5*this.coronaArc, false);
        this.context.arc(this.x0, this.y0, this.innerRad, 0.5*this.coronaArc, -0.5*this.coronaArc, true);
        this.context.closePath();
        this.context.fill();
        this.context.stroke();

        //target chamber
        if(this.labels[4]){
            //downstream
            fill = interpolateColor(parseHexColor(this.DSchamberOldColor), parseHexColor(this.DSchamberColor), frame/this.nFrames);
            this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
            this.context.fillRect(this.x0 - 0.75*this.innerRad/2, this.y0-this.innerRad/2, 0.75*this.innerRad, this.innerRad/10);
            this.context.strokeRect(this.x0 - 0.75*this.innerRad/2, this.y0-this.innerRad/2, 0.75*this.innerRad, this.innerRad/10);
        }
        if(this.labels[5]){
            //upstream
            fill = interpolateColor(parseHexColor(this.USchamberOldColor), parseHexColor(this.USchamberColor), frame/this.nFrames);
            this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
            this.context.fillRect(this.x0 - 0.75*this.innerRad/2, this.y0+this.innerRad/2 - this.innerRad/10, 0.75*this.innerRad, this.innerRad/10);
            this.context.strokeRect(this.x0 - 0.75*this.innerRad/2, this.y0+this.innerRad/2 - this.innerRad/10, 0.75*this.innerRad, this.innerRad/10);
        }

        //beamdump
        fill = interpolateColor(parseHexColor(this.dumpOldColor), parseHexColor(this.dumpColor), frame/this.nFrames);
        this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
        this.context.fillRect(this.x0 - this.canvasHeight*0.08, this.canvasHeight*0.008, this.canvasHeight*0.16, this.canvasHeight*0.4 - this.outerRad - 2*this.canvasHeight*0.008);
        this.context.strokeRect(this.x0 - this.canvasHeight*0.08, this.canvasHeight*0.008, this.canvasHeight*0.16, this.canvasHeight*0.4 - this.outerRad - 2*this.canvasHeight*0.008);

        //beam arrow
        this.context.lineWidth = 2;
        this.context.beginPath();
        this.context.moveTo(this.x0, this.canvasHeight*0.98*0.8);
        this.context.lineTo(this.x0, this.canvasHeight*0.78*0.8);
        this.context.lineTo(this.x0 - this.canvasHeight*0.02*0.8, this.canvasHeight*0.78*0.8 + this.canvasHeight*0.02*0.8);
        this.context.stroke();

        //labels
        this.context.font = Math.min(20,fitFont(this.context, this.labels[3], this.outerRad*(this.gapArc+this.auxCoronaArc)))+'px Orbitron';
        this.context.fillStyle = '#999999';
        this.context.textBaseline = 'alphabetic';
        //corona
        curveText(this.labels[0], this.context, this.x0, this.y0, this.outerRad*1.02, -Math.PI/2 - this.context.measureText(this.labels[0]).width/2/this.outerRad*1.02);
        curveText(this.labels[0], this.context, this.x0, this.y0, this.outerRad*1.02, Math.PI/2 - this.context.measureText(this.labels[0]).width/2/this.outerRad*1.02);
        //downstream auxilary corona
        curveText(this.labels[3], this.context, this.x0, this.y0, this.outerRad*1.02, -(this.beampipeArc/2+this.lampshadeArc+this.gapArc+this.auxCoronaArc/2) - this.context.measureText(this.labels[3]).width/2/this.outerRad*1.02);
        curveText(this.labels[3], this.context, this.x0, this.y0, this.outerRad*1.02, this.beampipeArc/2+this.lampshadeArc+this.gapArc+this.auxCoronaArc/2 - this.context.measureText(this.labels[3]).width/2/this.outerRad*1.02);        
        //upstream auxilary corona
        curveText(this.labels[3], this.context, this.x0, this.y0, this.outerRad*1.02, Math.PI-(this.beampipeArc/2+this.lampshadeArc+this.gapArc+this.auxCoronaArc/2) - this.context.measureText(this.labels[3]).width/2/this.outerRad*1.02);
        curveText(this.labels[3], this.context, this.x0, this.y0, this.outerRad*1.02, Math.PI+this.beampipeArc/2+this.lampshadeArc+this.gapArc+this.auxCoronaArc/2 - this.context.measureText(this.labels[3]).width/2/this.outerRad*1.02); 
        //downstream lampshade
        curveText(this.labels[1], this.context, this.x0, this.y0, this.outerRad*1.02, -(this.beampipeArc + this.lampshadeArc)/2 - this.context.measureText(this.labels[1]).width/2/this.outerRad*1.02);
        curveText(this.labels[1], this.context, this.x0, this.y0, this.outerRad*1.02, (this.beampipeArc + this.lampshadeArc)/2 - this.context.measureText(this.labels[1]).width/2/this.outerRad*1.02);
        //upstream lampshade
        curveText(this.labels[2], this.context, this.x0, this.y0, this.outerRad*1.02, Math.PI-(this.beampipeArc + this.lampshadeArc)/2 - this.context.measureText(this.labels[2]).width/2/this.outerRad*1.02);
        curveText(this.labels[2], this.context, this.x0, this.y0, this.outerRad*1.02, Math.PI+(this.beampipeArc + this.lampshadeArc)/2 - this.context.measureText(this.labels[2]).width/2/this.outerRad*1.02);  
        //target chamber (downstream)
        if(this.labels[4]){
            this.context.font = Math.min(20,fitFont(this.context, this.labels[4], this.innerRad*1.9))+'px Orbitron';
            this.context.textBaseline = 'top';
            this.context.fillText(this.labels[4], this.x0 - this.context.measureText(this.labels[4]).width/2, this.y0 - 0.34*this.innerRad);
        }
        //target chamber (upstream)        
        if(this.labels[5]){
            this.context.font = Math.min(20,fitFont(this.context, this.labels[5], this.innerRad*1.9))+'px Orbitron';
            this.context.textBaseline = 'bottom';
            this.context.fillText(this.labels[5], this.x0 - this.context.measureText(this.labels[5]).width/2, this.y0 + 0.4*this.innerRad);
        }
        //beam dump
        this.context.font = Math.min(20,fitFont(this.context, this.labels[6], this.canvasHeight*0.16*0.8))+'px Orbitron';
        this.context.textBaseline = 'top';
        this.context.fillText(this.labels[6], this.x0 - this.context.measureText(this.labels[6]).width/2, this.canvasHeight*0.4 - this.outerRad); 

        if(frame==0)
            this.drawScale();       
    };

    this.animate = function(){
        if(window.onDisplay == this.canvasID) animate(this, 0);
        else this.draw(this.nFrames);
    };


    this.update = function(){
        this.fetchNewData();

        this.animate();
    };

    //parse the count rates into colors for each sector:
    this.fetchNewData = function(){
        this.USLoldColor = this.USLcolor;
        this.coronaOldColor = this.coronaColor;
        this.auxCoronaOldColor = this.auxCoronaColor;
        this.DSLoldColor = this.DSLcolor;
        this.DSchamberOldColor = this.DSchamberColor;
        this.USchamberOldColor = this.USchamberColor;
        this.dumpOldColor = this.dumpColor;

        this.USLcolor = this.parseColor(this.pointers[2].dataBus.totalRate);
        this.coronaColor = this.parseColor(this.pointers[0].dataBus.totalRate);
        if(this.pointers[3])
            this.auxCoronaColor = this.parseColor(this.pointers[3].dataBus.totalRate);
        this.DSLcolor = this.parseColor(this.pointers[1].dataBus.totalRate);
        if(this.pointers[4])
            this.DSchamberColor = this.parseColor(this.pointers[4].dataBus.totalRate);
        if(this.pointers[5])
            this.USchamberColor = this.parseColor(this.pointers[5].dataBus.totalRate);
        //this.dumpColor = this.parseColor(this.pointers[6].dataBus.totalRate);
    };

    //alarm animation test:
    //fadeRed('TIGRESSTab')
    function fadeBlack(tabID){
        $('#'+tabID).off();
        $('#'+tabID).on('transitionend', function(){fadeRed(tabID)});
        document.getElementById(tabID).style.border = '2px solid black';
        document.getElementById(tabID).style['border-right'] = 'none';
    };
    function fadeRed(tabID){
        $('#'+tabID).off();
        $('#'+tabID).on('transitionend', function(){fadeBlack(tabID)});
        document.getElementById(tabID).style.border = '2px solid red';
        document.getElementById(tabID).style['border-right'] = 'none';
    };

    this.drawScale = function(){

        var i, j, string, unit, title;

        this.context.clearRect(0, this.canvasHeight - this.scaleHeight, this.canvasWidth, this.canvasHeight);

        //titles
        this.context.fillStyle = '#999999';
        this.context.font="24px 'Orbitron'";
        this.context.textBaseline = 'middle';
        if(window.parameters.detectorLogMode.DashboardButton){
            title = 'log(Rate)';
        } else {
            title = 'Rate';
        }
        this.context.fillText(title, this.canvasWidth/2 - this.context.measureText(title).width/2, this.canvasHeight-this.scaleHeight/2 + 20 + 20);
        this.context.textBaseline = 'alphabetic';

        //tickmark;
        this.context.strokeStyle = '#999999';
        this.context.lineWidth = 1;
        this.context.font="12px 'Raleway'";

        //determine unit:
        unit = ODB.Dashboard.dashboardMax;
        if(unit > 1000000) unit = ' MHz';
        else if(unit > 1000) unit = ' kHz';
        else unit = ' Hz';
        if(window.parameters.detectorLogMode.DashboardButton) unit = ' log(Hz)';

        this.context.beginPath();
        this.context.moveTo(this.canvasWidth*0.05+1, this.canvasHeight - this.scaleHeight/2 + 20);
        this.context.lineTo(this.canvasWidth*0.05+1, this.canvasHeight - this.scaleHeight/2 + 20 + 10);
        this.context.stroke();
        if(window.parameters.detectorLogMode.DashboardButton) string = Math.log( ODB.Dashboard.dashboardMin ) + ' log(Hz)';
        else string = (ODB.Dashboard.dashboardMin) + ' Hz';
        this.context.fillText( string, this.canvasWidth*0.05 - this.context.measureText(string).width/2, this.canvasHeight-this.scaleHeight/2 + 45);

        this.context.beginPath();
        this.context.moveTo(this.canvasWidth*0.95-1, this.canvasHeight - this.scaleHeight/2 + 20);
        this.context.lineTo(this.canvasWidth*0.95-1, this.canvasHeight - this.scaleHeight/2 + 20 + 10); 
        this.context.stroke();

        string = ODB.Dashboard.dashboardMax;
        if(window.parameters.detectorLogMode. DashboardButton){
            string = Math.log(string).toFixed(1) + unit;
        } else {
            if(string > 1000000) string = string/1000000 + unit;
            else if(string > 1000) string = string/1000 + unit;
            else string = string + unit;
        }
        this.context.fillText(string, this.canvasWidth*0.95 - this.context.measureText(string).width/2, this.canvasHeight-this.scaleHeight/2 + 45);

        for(i=0; i<3000; i++){
            this.context.fillStyle = scalepickr(0.001*(i%1000), 'Sunset');
            this.context.fillRect(this.canvasWidth*0.05 + this.canvasWidth*0.9/1000*(i%1000), this.canvasHeight-this.scaleHeight/2, this.canvasWidth*0.9/1000, 20);
        }

    };

    this.parseColor = function(scalar){
        var scale;

        //how far along the scale are we?
        if(window.parameters.detectorLogMode.DashboardButton){  //log mode
            scale = (Math.log(scalar) - Math.log(ODB.Dashboard.dashboardMin) )/ (Math.log(ODB.Dashboard.dashboardMax) - Math.log(ODB.Dashboard.dashboardMin ));
        } else {  //linear mode
            scale = (scalar - ODB.Dashboard.dashboardMin ) / (ODB.Dashboard.dashboardMax - ODB.Dashboard.dashboardMin);
        }

        return scalepickr(scale, 'Sunset');

    };   
}//Each detector will have its own data structure for ferrying information 
//from the ODB (or elsewhere) to the instance of the monitoring service
//for that detector.  Also, each detector will have a key map which matches
//monitoring service array indices to detector element name, and to ODB
//index.

HVDS = function(rows, cols){
	var i,j;
	//data arrays:
	this.channelName = [];
    this.demandVoltage = [];
    this.reportVoltage = [];
    this.reportCurrent = [];
    this.demandVrampUp = [];
    this.demandVrampDown = [];
    this.reportTemperature = [];
    this.channelMask = [];
    this.alarmStatus = [];
    this.rampStatus = [];
    this.voltLimit = [];
    this.currentLimit = [];
    for(i=0; i<rows; i++){
    	this.channelName[i] = [];
        this.demandVoltage[i] = [];
        this.reportVoltage[i] = [];
        this.reportCurrent[i] = [];
        this.demandVrampUp[i] = [];
        this.demandVrampDown[i] = [];
        this.reportTemperature[i] = [];
        this.channelMask[i] = [];
        this.alarmStatus[i] = [];
        this.rampStatus[i] = [];
        this.voltLimit[i] = [];
        this.currentLimit[i] = [];
        for(j=0;j<cols;j++){
        	this.alarmStatus[i][j] = [0,0,0];
        }
    }
}

HVBarDS = function(){
    this.barChartData = [];
    this.barChartAlarms = [];
}

function cloverDS(nClovers, mode){
	var i, j, k;

	this.colorQuads = ['G', 'B', 'W', 'R'];
	var pfx = (mode == 'TIGRESS') ? 'TI' : 'GR';
	this.HPGe = {};
	this.totalRate = 0;
	for(i=1; i<1+nClovers; i++){
		//loop over quadrants
		for(j=0; j<4; j++){
			this.HPGe[pfx+'G'+( (i<10) ? '0'+i : i)+this.colorQuads[j]+'N00A'] = {
				'HV'		: 0,		//note both A and B carry the same HV for GRIFFIN style HPGe
				'threshold' : 0,
				'rate'		: 0,
				'index'     : ((mode== 'TIGRESS')? 10:2)*j+((mode== 'TIGRESS')? 60:30)*(i-1),

				'oldHVcolor' : '#000000',
				'HVcolor'	 : '#000000',
				'oldThresholdColor' : '#000000',
				'thresholdColor' : '#000000',
				'oldRateColor' : '#000000',
				'rateColor' : '#000000'				
			}
			this.HPGe[pfx+'G'+( (i<10) ? '0'+i : i)+this.colorQuads[j]+'N00B'] = {
				'HV'		: 0,		//note both A and B carry the same HV for GRIFFIN style HPGe
				'threshold' : 0,
				'rate'		: 0,
				'index'		: ((mode== 'TIGRESS')? 10:2)*j+1+((mode== 'TIGRESS')? 60:30)*(i-1),

				'oldHVcolor' : '#000000',
				'HVcolor'	 : '#000000',
				'oldThresholdColor' : '#000000',
				'thresholdColor' : '#000000',
				'oldRateColor' : '#000000',
				'rateColor' : '#000000'				
			}

			if(mode == 'TIGRESS'){
				for(k=1; k<9; k++){
					this.HPGe['TIG'+( (i<10) ? '0'+i : i)+this.colorQuads[j]+'P0'+k+'X'] = {
						'HV'		: 0,
						'threshold' : 0,
						'rate'		: 0,
						'index'     : 10*j+1+k + 60*(i-1),

						'oldHVcolor' : '#000000',
						'HVcolor'	 : '#000000',
						'oldThresholdColor' : '#000000',
						'thresholdColor' : '#000000',
						'oldRateColor' : '#000000',
						'rateColor' : '#000000'							
					}
				}
			}
		}

		//BGO channels
		var ID;
		//loop over quadrants
		for(j=0; j<4; j++){
			//five BGO segments in each quadrant: front, front, side, side, back
			for(k=1; k<6; k++){
				if(k==1) ID = ((mode== 'TIGRESS')? 53:21)+2*j;	//front suppressors
				if(k==2) ID = ((mode== 'TIGRESS')? 52:20)+2*j;
				if(k==3) ID = ((mode== 'TIGRESS')? 45:13)+2*j;	//side suppressors
				if(k==4) ID = ((mode== 'TIGRESS')? 44:12)+2*j;
				if(k==5) ID = ((mode== 'TIGRESS')? 40:8)+j; 		//back suppressors
				this.HPGe[pfx+'S'+( (i<10) ? '0'+i : i)+this.colorQuads[j]+'N0'+k+'X'] = {
				'HVA'		: 0xDEADBEEF,		//each rate channel has two HV hookups.
				'HVB'		: 0xDEADBEEF,
				'threshold' : 0,
				'rate'		: 0,
				'index'		: ID+((mode== 'TIGRESS')? 60:30)*(i-1),

				'oldHVAcolor' : '#000000',
				'HVAcolor'	 : '#000000',
				'oldHVBcolor' : '#000000',
				'HVBcolor'	 : '#000000',				
				'oldThresholdColor' : '#000000',
				'thresholdColor' : '#000000',
				'oldRateColor' : '#000000',
				'rateColor' : '#000000'					
				}
			}
		}

	}

	//invert the index map for the TT:
	this.HPGeTTmap = [];
	for(key in this.HPGe){
		this.HPGeTTmap[this.HPGe[key].index] = key;
	}

	this.summary = {};
	for(i=1; i<1+nClovers; i++){
		//HPGe summaries
		for(j=0; j<4; j++){
			this.summary[pfx+'G'+( (i<10) ? '0'+i : i)+this.colorQuads[j]] = {
				'clover' : i,
				'quadrant' : j,

				'HV'		: 0,
				'threshold' : 0,
				'rate'		: 0,

				'oldHVcolor' : '#000000',
				'HVcolor'	 : '#000000',
				'oldThresholdColor' : '#000000',
				'thresholdColor' : '#000000',
				'oldRateColor' : '#000000',
				'rateColor' : '#000000'					
			}
		}

		//BGO summaries
		for(j=0; j<4; j++){
			this.summary[pfx+'S'+( (i<10) ? '0'+i : i)+this.colorQuads[j]] = {
				'clover' : i,
				'quadrant' : j,

				'HV'		: 0,
				'threshold' : 0,
				'rate'		: 0,

				'oldHVcolor' : '#000000',
				'HVcolor'	 : '#000000',
				'oldThresholdColor' : '#000000',
				'thresholdColor' : '#000000',
				'oldRateColor' : '#000000',
				'rateColor' : '#000000'					
			}			
		}
	}
}

SHARCDS = function(padsEnabled){
	var i, j, name,
	that = this;
	this.SHARC = {};
	this.TTmap = [];
	this.summary = {};
	this.totalRate = 0;
	//SHARC detail level index logic: hundreds correspond to Array Position, ones and tens count through Segments front to back to pads. 
	//boxes:
	for(i=5; i<13; i++){
		//fronts:
		for(j=0; j<24; j++){
			name = 'SHB' + ( (i<10) ? '0'+i : i ) + 'DP' + ( (j<10) ? '0'+j : j ) + 'X';
			deployKeys('SHARC', name, 100*i + j);
		}
		//backs:
		for(j=0; j<48; j++){
			name = 'SHB' + ( (i<10) ? '0'+i : i ) + 'DN' + ( (j<10) ? '0'+j : j ) + 'X';
			deployKeys('SHARC', name, 100*i + 24 + j);
		}		
		//pads
		for(j=1; j<2; j++){ //only fronts actually instrumented?
			name = 'SHB' + ( (i<10) ? '0'+i : i ) + 'E' + ( (j==0) ? 'N' : 'P' ) + '00X';
			deployKeys('SHARC', name, 100*i+72 + j);
			deployKeys('summary', name, 10*i+8 + j); //summary level, see below
		}
	}

	//quadrants:
	for(i=1; i<5; i++){
		//fronts:
		for(j=0; j<16; j++){
			name = 'SHQ' + '0'+i + 'DP' + ( (j<10) ? '0'+j : j ) + 'X';  //upstream
			deployKeys('SHARC', name, 100*i + j);
			name = 'SHQ' + (i+12) + 'DP' + ( (j<10) ? '0'+j : j ) + 'X';  //downstream
			deployKeys('SHARC', name, 100*(i+12) + j);
		}
		//backs:
		for(j=0; j<24; j++){
			name = 'SHQ' + '0'+i + 'DN' + ( (j<10) ? '0'+j : j ) + 'X'; //upstream
			deployKeys('SHARC', name, 100*i + 16 + j);
			name = 'SHQ' + (i+12) + 'DN' + ( (j<10) ? '0'+j : j ) + 'X'; //downstream
			deployKeys('SHARC', name, 100*(i+12) + 16 + j);
		}
		//pads
		for(j=1; j<2; j++){  //only fronts actually instrumented?
			name = 'SHQ0' + i + 'E' + ( (j==0) ? 'N' : 'P' ) + '00X';
			deployKeys('SHARC', name, 100*i+40 + j);
			deployKeys('summary', name, 10*i+8 + j);
			name = 'SHQ' + (i+12) + 'E' + ( (j==0) ? 'N' : 'P' ) + '00X';
			deployKeys('SHARC', name, 100*(i+12)+40 + j);
			deployKeys('summary', name, 10*(i+12)+8 + j);
		}


	}

	//invert the index map for the TT:
	for(key in this.SHARC){
		this.TTmap[this.SHARC[key].index] = key;
	}

	//sumaries - split each detector into 4 groups of segments:
	//SHARC summary level index logic: index = 10*(Array Position) + { (Front Q1->Q4, Back Q1->Q4, front pad, back pad) -> [0,9] }
	//boxes:
	for(i=5; i<13; i++){
		//fronts:
		for(j=0; j<4; j++){
			name = 'SHB' + ( (i<10) ? '0'+i : i ) + 'DP' + j;
			deployKeys('summary', name, 10*i + j);
		}
		//backs:
		for(j=0; j<4; j++){
			name = 'SHB' + ( (i<10) ? '0'+i : i ) + 'DN' + j;
			deployKeys('summary', name, 10*i + 4 + j);
		}		
	}

	//quadrants:
	for(i=1; i<5; i++){
		//fronts:
		for(j=0; j<4; j++){
			name = 'SHQ' + '0'+i + 'DP' + j;  //upstream
			deployKeys('summary', name, 10*i + j);
			name = 'SHQ' + (i+12) + 'DP' + j;  //downstream
			deployKeys('summary', name, 10*(i+12) + j);
		}
		//backs:
		for(j=0; j<4; j++){
			name = 'SHQ' + '0'+i + 'DN' + j; //upstream
			deployKeys('summary', name, 10*i + 4 + j);
			name = 'SHQ' + (i+12) + 'DN' + j; //downstream
			deployKeys('summary', name, 10*(i+12) + 4 + j);
		}
	}
 
	function deployKeys(object, name, index){
		that[object][name] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,
			'index'		: index,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000'	
		}
		that.TTmap[index] = name;		
	};
}

DESCANTDS = function(){
	var i, name;

	this.DESCANT = {};
	this.TTmap = [];
	this.totalRate = 0;
	for(i=1; i<71; i++){
		name = (i<10) ? 'DSC0'+i+'XN00X' : 'DSC'+i+'XN00X';
		this.DESCANT[name] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,
			'index'		: i,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000'	
		}
		this.TTmap[i] = name;
	}
}

PACESDS = function(){
	var i, name;

	this.PACES = {};
	this.TTmap = [];
	this.totalRate = 0;
	for(i=1; i<6; i++){
		name = 'PAC0'+i+'XN00A';
		this.PACES[name] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,
			'index'		: 2*i-1,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000'	
		}
		this.TTmap[2*i-1] = name;

		name = 'PAC0'+i+'XN00B';
		this.PACES[name] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,
			'index'		: 2*i,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000'	
		}
		this.TTmap[2*i] = name;
	}
}

DANTEDS = function(){
	var i, name;

	this.DANTE = {};
	this.TTmap = [];
	this.totalRate = 0;
	for(i=1; i<11; i++){
		//LaBr PMT channels
		name = (i<10) ? 'DAL0'+i+'XN00X' : 'DAL'+i+'XN00X';
		this.DANTE[name] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,
			'index'		: i,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000',
		}

		//LaBr TAC channels
		name = (i<10) ? 'DAL0'+i+'XT00X' : 'DAL'+i+'XT00X';
		this.DANTE[name] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,
			'index'		: i+10,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000',
		}

		//Suppressors:
		name = (i<10) ? 'DAS0'+i+'XN00X' : 'DAS'+i+'XN00X';
		this.DANTE[name] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,
			'index'		: i+20,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000',
		}
	}

	for(name in this.DANTE){
		if(this.DANTE.hasOwnProperty(name)){
			this.TTmap[this.DANTE[name].index] = name;
		}
	}
}

DSSDDS = function(){

	var i, j, name, layer, charge, 
	index = 0,
	prefix = 'MAD',
	layers = ['D', 'E'],
	charges = ['N', 'P'];

	this.DSSD = {};
	this.TTmap = [];
	
	//quick hack only supports what's getting used in Madrid experiment May/June 2013 - last time this will ever be used?
	for(i=1; i<5; i++){
		for(layer=0; layer<2; layer++){
			for(charge=0; charge<2; charge++){
				for(j=0; j<16; j++){
					if( !(layer==1 && (i==1 || i==2 || i==3)) ){
						name = prefix + ((i<10) ? '0'+i : i) + layers[layer] + charges[charge] + ((j<10) ? '0'+j : j) + 'X';
						this.DSSD[name] = {
							'HV'		: 0,
							'threshold' : 0,
							'rate' 		: 0,
							'index'		: index,

							'oldHVcolor' : '#000000',
							'HVcolor'	 : '#000000',
							'oldThresholdColor' : '#000000',
							'thresholdColor' : '#000000',
							'oldRateColor' : '#000000',
							'rateColor' : '#000000'	
						}
						this.TTmap[index] = name;
						index++;
					}
				}
			}
		}
	}

	//pads:
	var padID = ['MAD01ENXXX', 'MAD02ENXXX', 'MAD03ENXXX'];
	for(i=0; i<3; i++){
						this.DSSD[padID[i]] = {
							'HV'		: 0,
							'threshold' : 0,
							'rate' 		: 0,
							'index'		: index,

							'oldHVcolor' : '#000000',
							'HVcolor'	 : '#000000',
							'oldThresholdColor' : '#000000',
							'thresholdColor' : '#000000',
							'oldRateColor' : '#000000',
							'rateColor' : '#000000'	
						}
						this.TTmap[index] = padID[i];
						index++;
	}
	
}

BAMBINODS = function(mode, layers, spiceMode){
	var i, j, k, index=0, name, prefix, arrayPosition;
	if(spiceMode)
		prefix = ((mode=='S2') ? 'SPZ0' : 'SPE0');
	else
		prefix = ((mode=='S2') ? 'BAZ0' : 'BAE0');
	this.waypoints = ['D', 'E'];  //note tooltip indices only support two layers in S3 mode

	this.BAMBINO = {};
	this.TTmap = [];
	this.totalRate = 0;
	for(i=1; i<3; i++){  //1 for upstream, 2 for downstream, 0 for SPICE.
		arrayPosition = (spiceMode) ? 0 : i;
		for(j=0; j<layers; j++){ //telescope layers
			for(k=0; k<24+( (mode=='S2') ? 16 : 32 ); k++ ){  //segments, 16 azimuthal in S2 mode, 32 in S3
				name = prefix + arrayPosition + this.waypoints[j] + ( (k<24) ? 'P'+( (k<10) ? '0'+k : k ) : 'N' + ( (k-24<10) ? '0'+(k-24) : k-24 ) ) + 'X';
				this.BAMBINO[name] = {
					'HV'		: 0,
					'threshold' : 0,
					'rate' 		: 0,
					'index'		: index,

					'oldHVcolor' : '#000000',
					'HVcolor'	 : '#000000',
					'oldThresholdColor' : '#000000',
					'thresholdColor' : '#000000',
					'oldRateColor' : '#000000',
					'rateColor' : '#000000'	
				}
				this.TTmap[index] = name;
				index++;
			}
		}
	}
}

SCEPTARDS = function(config){
	var i, name;

	this.SCEPTAR = {};
	this.TTmap = [];
	this.totalRate = 0;
	//upstream SCEPTAR
	if(config[0]){
		for(i=1; i<11; i++){
			name = (i<10) ? 'SEP0'+i+'XN00X' : 'SEP'+i+'XN00X';
			this.SCEPTAR[name] = {
				'HV'		: 0,
				'threshold' : 0,
				'rate' 		: 0,
				'index'		: i,

				'oldHVcolor' : '#000000',
				'HVcolor'	 : '#000000',
				'oldThresholdColor' : '#000000',
				'thresholdColor' : '#000000',
				'oldRateColor' : '#000000',
				'rateColor' : '#000000'	
			}
			this.TTmap[i] = name;
		}
	}

	//downstream SCEPTAR
	if(config[1]){
		for(i=11; i<21; i++){
			name = 'SEP'+i+'XN00X';
			this.SCEPTAR[name] = {
				'HV'		: 0,
				'threshold' : 0,
				'rate' 		: 0,
				'index'		: i,

				'oldHVcolor' : '#000000',
				'HVcolor'	 : '#000000',
				'oldThresholdColor' : '#000000',
				'thresholdColor' : '#000000',
				'oldRateColor' : '#000000',
				'rateColor' : '#000000'	
			}
			this.TTmap[i] = name;
		}
	}
/* not sure what I was thinking here
	//ZDS:
	if(config[2]){
		this.SCEPTAR['ZDS01XN00X'] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,
			'index'		: 21,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000'		
		}
		this.TTmap[21] = 'ZDS01XN00X';
	}
*/
}

ZDSDS = function(){
	this.ZDS = {};
	this.TTmap = [];
	this.ZDS['ZDS01XN00X'] = {
		'HV'		: 0,
		'threshold' : 0,
		'rate' 		: 0,
		'index'		: 0,

		'oldHVcolor' : '#000000',
		'HVcolor'	 : '#000000',
		'oldThresholdColor' : '#000000',
		'thresholdColor' : '#000000',
		'oldRateColor' : '#000000',
		'rateColor' : '#000000'		
	}
	this.TTmap[0] = 'ZDS01XN00X';
}

SPICEDS = function(){
	var i, name;

	this.SPICE = {};
	this.TTmap = [];
	this.totalRate = 0;
	for(i=0; i<120; i++){
		name = 'SPI00XN';
		if(i<10) name += '00'+i;
		else if(i<100) name += '0'+i;
		else name += i;
		this.SPICE[name] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,
			'index'		: i,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000'	
		}
		this.TTmap[i] = name;
	}
}

TIPwallDS = function(){
	var i, j, k, name, key, subKey;

	this.TIPwall = {};
	this.totalRate = 0;
	for(i=1; i<25; i++){
		var name = (i<10) ? 'TPW00'+i+'P00X' : 'TPW0'+i+'P00X';
		this.TIPwall[name] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000'	
		}
	}
	this.TIPwall['TPW011P00X']['index'] = 0;
	this.TIPwall['TPW012P00X']['index'] = 1;
	this.TIPwall['TPW013P00X']['index'] = 2;
	this.TIPwall['TPW014P00X']['index'] = 3;
	this.TIPwall['TPW015P00X']['index'] = 4;
	this.TIPwall['TPW010P00X']['index'] = 5;
	this.TIPwall['TPW002P00X']['index'] = 6;
	this.TIPwall['TPW003P00X']['index'] = 7;
	this.TIPwall['TPW004P00X']['index'] = 8;
	this.TIPwall['TPW016P00X']['index'] = 9;
	this.TIPwall['TPW009P00X']['index'] = 10;
	this.TIPwall['TPW001P00X']['index'] = 11;
	this.TIPwall['TPW005P00X']['index'] = 12;
	this.TIPwall['TPW017P00X']['index'] = 13;
	this.TIPwall['TPW024P00X']['index'] = 14;
	this.TIPwall['TPW008P00X']['index'] = 15;
	this.TIPwall['TPW007P00X']['index'] = 16;
	this.TIPwall['TPW006P00X']['index'] = 17;
	this.TIPwall['TPW018P00X']['index'] = 18;
	this.TIPwall['TPW023P00X']['index'] = 19;
	this.TIPwall['TPW022P00X']['index'] = 20;
	this.TIPwall['TPW021P00X']['index'] = 21;
	this.TIPwall['TPW020P00X']['index'] = 22;
	this.TIPwall['TPW019P00X']['index'] = 23;

	//invert the above index map for TT lookup
	this.TTmap = []
	for(key in this.TIPwall){
		this.TTmap[this.TIPwall[key].index] = key;
	}

}

TIPballDS = function(){
	var i, j, k, name, key, subKey;

	this.TIPball = {};
	this.totalRate = 0;
	for(i=1; i<129; i++){
		var name = (i<10) ? 'TPC00'+i+'P00X' : ( (i<100) ? 'TCW0'+i+'P00X' : 'TCW'+i+'P00X');
		this.TIPball[name] = {
			'HV'		: 0,
			'threshold' : 0,
			'rate' 		: 0,
			'index'		: i,

			'oldHVcolor' : '#000000',
			'HVcolor'	 : '#000000',
			'oldThresholdColor' : '#000000',
			'thresholdColor' : '#000000',
			'oldRateColor' : '#000000',
			'rateColor' : '#000000'	
		}
	}

	//invert the above index map for TT lookup
	this.TTmap = []
	for(key in this.TIPball){
		this.TTmap[this.TIPball[key].index] = key;
	}

}



















//TODO: both the Filter and Cycle pages make use of a draggable badge system of defining groups and relationships.  The code for this
//is currently pretty spaghetti, should factor out a reusable class.

function Filter(){
    var that = this,
    i;
    window.filterPointer = that;

	this.wrapperID = window.parameters.wrapper;	//ID of wrapping div
	this.canvasID = 'FilterCanvas';	        //ID of canvas to paint filter on
    this.linkWrapperID = 'FilterLinks';        //ID of div to contain clock view header
    this.sidebarID = 'FilterSidebar';          //ID of sidebar div
    this.TTcanvasID = 'TTfilterCanvas';
    this.filterSystems = ['GRI', 'PAC', 'DTE'] //subsytems available to participate in the filter, dummy for now
    this.filterSystemsNames = ['GRIFFIN', 'PACES', 'DANTE'];  //human readable version

	this.wrapper = document.getElementById(this.wrapperID);

    //add top level nav button:
    injectDOM('button', 'FilterButton', 'statusLink', {
        'class' : 'navLink',
        'innerHTML' : 'Filter',
        'type' : 'button',
        'onclick' : function(){swapView('FilterLinks', 'FilterCanvas', 'FilterSidebar', 'FilterButton')}
    });

    //nav wrapper div
    injectDOM('div', this.linkWrapperID, this.wrapperID, {'class':'navPanel'});
    //nav header
    injectDOM('h1', 'FilterLinksBanner', this.linkWrapperID, {'class':'navPanelHeader', 'innerHTML':ODB.topLevel.expName+' Filter Status'});
    injectDOM('br', 'break', this.linkWrapperID, {});

    injectDOM('button', 'gotoFilterEdit', 'FilterLinks', {
        'class' : 'navLink',
        'onclick' : function(){swapView('editFilterLinks', 'editFilterCanvas', 'editFilterSidebar', 'FilterButton')},
        'innerHTML' : 'Edit Filter',
        'style' : 'margin-bottom: 1em', 
        'type' : 'button'
    });

	//deploy a canvas for the filter view:
    this.canvasWidth = 0.48*$(this.wrapper).width();
    this.canvasHeight = 1*$(this.wrapper).height();

    injectDOM('canvas', this.canvasID, this.wrapperID, {'class':'monitor', 'style':'top:' + ($('#FilterLinks').offset().top + $('#FilterLinks').height() + 5) +'px;'});
    this.canvas = document.getElementById('FilterCanvas');
    this.context = this.canvas.getContext('2d');
    this.canvas.setAttribute('width', this.canvasWidth);
    this.canvas.setAttribute('height', this.canvasHeight);

    //and the tt layer:
    injectDOM('canvas', this.TTcanvasID, this.wrapperID, {'class':'monitor', 'style':'top:' + ($('#FilterLinks').offset().top + $('#FilterLinks').height() + 5) +'px;'});
    this.TTcanvas = document.getElementById('TTfilterCanvas');
    this.TTcontext = this.TTcanvas.getContext('2d');
    this.TTcanvas.setAttribute('width', this.canvasWidth);
    this.TTcanvas.setAttribute('height', this.canvasHeight);

    //set up tooltip:
    this.TTcontext.fillStyle = '#123456';
    this.TTcontext.fillRect(0,0,this.canvasWidth, this.canvasHeight);
    this.tooltip = new Tooltip(this.canvasID, 'filterTT', this.wrapperID, [], []);
    this.tooltip.obj = that;

    this.canvas.onclick =   function(event){
                                var x,y, cell;
                                x = event.pageX - that.canvas.offsetLeft - that.wrapper.offsetLeft;
                                y = event.pageY - that.canvas.offsetTop - that.wrapper.offsetTop;
                                cell = that.findCell(x,y);
                                //draw and swap out if user clicked on a valid clover
                                if(cell > -1 && cell < 6){
                                    that.populateSidebar(cell);
                                }
                            };

    //right sidebar dummy
    injectDOM('div', this.sidebarID, this.wrapperID, {'class':'collapsableSidebar', 'style':'float:right; height:80%;'});
    //deploy right bar menu:
    //deployMenu(this.sidebarID, ['detail'] , ['Filter Detail'] );
    //start with menu open:
    //document.getElementById('detailarrow').onclick();

    //drawing parameters:
    this.lineWeight = 4;
    this.context.lineWidth = this.lineWeight;
    this.context.fillStyle = '#444444';

    this.scaleHeight = 0.2*this.canvasHeight;

    this.arrowGutter = 0.07*this.canvasHeight;
    this.arrowOver = 0.04*this.canvasHeight;

    this.inputLinkHeight = 0.08*this.canvasHeight-this.lineWeight;
    this.inputLinkWidth = 0.8*this.canvasWidth-this.lineWeight;
    this.inputLinkX0 = 0.1*this.canvasWidth + this.lineWeight/2;
    this.inputLinkY0 = 0.72*this.canvasHeight + this.lineWeight/2;

    this.shortBufferHeight = 0.1*this.canvasHeight - this.lineWeight;
    this.shortBufferWidth = 0.15*this.canvasWidth - this.lineWeight;
    this.shortBufferX0 = 0.25*this.canvasWidth + this.lineWeight/2;
    this.shortBufferY0 = 0.55*this.canvasHeight + this.lineWeight/2;

    this.rawDataHeight = 0.18*this.canvasHeight - this.lineWeight;
    this.rawDataWidth = 0.3*this.canvasWidth - this.lineWeight;
    this.rawDataX0 = 0.1*this.canvasWidth + this.lineWeight/2;
    this.rawDataY0 = 0.3*this.canvasHeight + this.lineWeight/2;

    this.masterCoreHeight = 0.35*this.canvasHeight - this.lineWeight;
    this.masterCoreWidth = 0.3*this.canvasWidth - this.lineWeight;
    this.masterCoreX0 = 0.6*this.canvasWidth + this.lineWeight/2;
    this.masterCoreY0 = this.rawDataY0;

    this.longBufferHeight = 0.08*this.canvasHeight - this.lineWeight;
    this.longBufferWidth = 0.8*this.canvasWidth - this.lineWeight;
    this.longBufferX0 = 0.1*this.canvasWidth + this.lineWeight/2;
    this.longBufferY0 = 0.15*this.canvasHeight + this.lineWeight/2 

    this.compLinkHeight = 0.08*this.canvasHeight - this.lineWeight;
    this.compLinkWidth = 0.8*this.canvasWidth - this.lineWeight;
    this.compLinkX0 = 0.1*this.canvasWidth + this.lineWeight/2;
    this.compLinkY0 = this.lineWeight/2;

    this.textMargin = 20;

    //establish animation parameters////////////////////////////////////////////////////////////////////
    this.FPS = 30;
    this.duration = 0.5;
    this.nFrames = this.FPS*this.duration;

    //data buffers///////////////////////////

    //member functions/////////////////////////////////////////////

    this.draw = function(frame){
        var fontSize;

        this.context.fillStyle = '#444444';
        //Input Link
        this.context.strokeStyle = '#000000';
        roundBox(this.context, this.inputLinkX0, this.inputLinkY0, this.inputLinkWidth, this.inputLinkHeight, 25);
        this.context.fill();
        this.context.stroke();

        //Short term Buffer
        this.context.strokeStyle = '#000000';
        roundBox(this.context, this.shortBufferX0, this.shortBufferY0, this.shortBufferWidth, this.shortBufferHeight, 25);
        this.context.fill();
        this.context.stroke();

        //Raw Data
        this.context.strokeStyle = '#000000';
        roundBox(this.context, this.rawDataX0, this.rawDataY0, this.rawDataWidth, this.rawDataHeight, 25);
        this.context.fill();
        this.context.stroke();

        //Filter Core 
        this.context.strokeStyle = '#000000';
        roundBox(this.context, this.masterCoreX0, this.masterCoreY0, this.masterCoreWidth, this.masterCoreHeight, 25);
        this.context.fill();
        this.context.stroke();

        //Long term Buffer
        this.context.strokeStyle = '#000000';
        roundBox(this.context, this.longBufferX0, this.longBufferY0, this.longBufferWidth, this.longBufferHeight, 25);
        this.context.fill();
        this.context.stroke();

        //Computer Link
        this.context.strokeStyle = '#000000';
        roundBox(this.context, this.compLinkX0, this.compLinkY0, this.compLinkWidth, this.compLinkHeight, 25);
        this.context.fill();
        this.context.stroke();

        //arrows:
        //input -> short buffer
        this.context.strokeStyle = '#999999';
        arrow(this.context, 0.325*this.canvasWidth, 0.72*this.canvasHeight, 0.325*this.canvasWidth, 0.65*this.canvasHeight + this.lineWeight - this.arrowOver, 0.01*this.canvasHeight);
        this.context.stroke();

        //input -> raw data
        arrow(this.context, 0.175*this.canvasWidth, 0.72*this.canvasHeight, 0.175*this.canvasWidth, 0.48*this.canvasHeight + this.lineWeight - this.arrowOver, 0.01*this.canvasHeight);
        this.context.stroke(); 

        //short buffer -> raw data
        arrow(this.context, 0.325*this.canvasWidth, 0.55*this.canvasHeight, 0.325*this.canvasWidth, 0.48*this.canvasHeight + this.lineWeight - this.arrowOver, 0.01*this.canvasHeight);
        this.context.stroke();

        //short buffer -> master
        arrow(this.context, 0.4*this.canvasWidth, 0.6*this.canvasHeight, 0.6*this.canvasWidth - this.lineWeight + this.arrowOver, 0.6*this.canvasHeight, 0.01*this.canvasHeight);
        this.context.stroke();        

        //master -> raw data
        arrow(this.context, 0.6*this.canvasWidth, 0.4*this.canvasHeight, 0.4*this.canvasWidth+this.lineWeight - this.arrowOver, 0.4*this.canvasHeight, 0.01*this.canvasHeight);
        this.context.stroke(); 

        //raw data -> long (raw)
        arrow(this.context, 0.175*this.canvasWidth, 0.3*this.canvasHeight, 0.175*this.canvasWidth, 0.23*this.canvasHeight+this.lineWeight - this.arrowOver, 0.01*this.canvasHeight);
        this.context.stroke(); 

        //raw data -> long (data)
        arrow(this.context, 0.325*this.canvasWidth, 0.3*this.canvasHeight, 0.325*this.canvasWidth, 0.23*this.canvasHeight+this.lineWeight - this.arrowOver, 0.01*this.canvasHeight);
        this.context.stroke(); 

        //long buffer -> computer link
        arrow(this.context, 0.5*this.canvasWidth, 0.15*this.canvasHeight, 0.5*this.canvasWidth, 0.08*this.canvasHeight+this.lineWeight - this.arrowOver, 0.01*this.canvasHeight);
        this.context.stroke(); 

        //labels
        if(frame == 0){
            this.context.fillStyle = '#EEEEEE';
            fontSize = fitFont(this.context, 'Short-Term', this.shortBufferWidth-this.textMargin*2);
            this.context.font = fontSize+'px Raleway';
            this.context.textBaseline = 'middle';

            //Short-term buffer:
            this.context.fillText('Short-Term', this.shortBufferX0+this.textMargin, this.shortBufferY0+this.textMargin);
            this.context.fillText('Buffer', this.shortBufferX0+this.textMargin, this.shortBufferY0+this.textMargin+fontSize);
            if(fontSize < 16)
                this.context.font = '16px Raleway';
            //Input link:
            this.context.fillText('Input Link', this.inputLinkX0+this.textMargin, this.inputLinkY0 + this.inputLinkHeight/2);
            //Raw Data
            this.context.fillText('Raw Data', this.rawDataX0+this.textMargin, this.rawDataY0+1.2*this.textMargin);
            //Filter Core
            this.context.fillText('Filter Core', this.masterCoreX0 + this.masterCoreWidth - this.context.measureText('Filter Core').width -this.textMargin, this.masterCoreY0+1.2*this.textMargin);
            //Long Term Buffer
            this.context.fillText('Long-Term Buffer', this.longBufferX0+this.longBufferWidth - this.context.measureText('Long-Term Buffer').width - this.textMargin, this.longBufferY0+this.longBufferHeight/2);
            //Computer Link
            this.context.fillText('Computer Link', this.compLinkX0+this.compLinkWidth - this.context.measureText('Computer Link').width - this.textMargin, this.compLinkY0+this.compLinkHeight/2);            
        }

    };

    this.drawTTlayer = function(){
        //Input Link
        this.TTcontext.fillStyle = '#000000';
        roundBox(this.TTcontext, this.inputLinkX0, this.inputLinkY0, this.inputLinkWidth, this.inputLinkHeight, 25);
        this.TTcontext.fill();

        //Short term Buffer
        this.TTcontext.fillStyle = '#010101';
        roundBox(this.TTcontext, this.shortBufferX0, this.shortBufferY0, this.shortBufferWidth, this.shortBufferHeight, 25);
        this.TTcontext.fill();

        //Raw Data
        this.TTcontext.fillStyle = '#020202';
        roundBox(this.TTcontext, this.rawDataX0, this.rawDataY0, this.rawDataWidth, this.rawDataHeight, 25);
        this.TTcontext.fill();

        //Filter Core 
        this.TTcontext.fillStyle = '#030303';
        roundBox(this.TTcontext, this.masterCoreX0, this.masterCoreY0, this.masterCoreWidth, this.masterCoreHeight, 25);
        this.TTcontext.fill();

        //Long term Buffer
        this.TTcontext.fillStyle = '#040404';
        roundBox(this.TTcontext, this.longBufferX0, this.longBufferY0, this.longBufferWidth, this.longBufferHeight, 25);
        this.TTcontext.fill();

        //Computer Link
        this.TTcontext.fillStyle = '#050505';
        roundBox(this.TTcontext, this.compLinkX0, this.compLinkY0, this.compLinkWidth, this.compLinkHeight, 25);
        this.TTcontext.fill();
    };
    //paint the tt layer exactly once :)
    this.drawTTlayer();

    this.update = function(){
        this.draw(0);
    };

    this.animate = function(){
        if(window.onDisplay == this.canvasID /*|| window.freshLoad*/) animate(this, 0);
        else this.draw(this.nFrames);
    };

    this.findCell = function(x, y){
        var imageData = this.TTcontext.getImageData(x,y,1,1), 
            index;
        
        index = -1;
        if(imageData.data[0] == imageData.data[1] && imageData.data[0] == imageData.data[2]) index = imageData.data[0];

        return index;
    };

    this.defineText = function(cell){
         document.getElementById(this.tooltip.ttDivID).innerHTML = cell;
    };

    this.populateSidebar = function(cell){
        //Input Link
        if(cell==0){
            injectDOM('p', 'detailContentMessage', 'detailContent', {'innerHTML':'Input Link'});
        //Short Term Buffer
        } else if(cell==1){
            injectDOM('p', 'detailContentMessage', 'detailContent', {'innerHTML':'Short-Term Buffer'});
        //Raw Data
        } else if(cell==2){
            injectDOM('p', 'detailContentMessage', 'detailContent', {'innerHTML':'Raw Data'});
        //Filter Core
        } else if(cell==3){
            injectDOM('p', 'detailContentMessage', 'detailContent', {'innerHTML':'Filter Core'});
        //Long Term Buffer
        } else if(cell==4){
            injectDOM('p', 'detailContentMessage', 'detailContent', {'innerHTML':'Long-Term Buffer'});
        //Computer Link
        } else if(cell==5){
            injectDOM('p', 'detailContentMessage', 'detailContent', {'innerHTML':'Computer Link'});
        }
    };

    //start with filter core sidebar displayed:
    //this.populateSidebar(3);
    
    //deploy the editFilter page
    window.editFilter = new editFilter(this.filterSystems, this.filterSystemsNames)
}








function editFilter(filterSystems, filterSystemsNames){
    var that = this,
    i;
    window.filterEditPointer = that;
    this.filterConIndex = 0;
    this.filterConPresent = [];  //keeps track of which filter condition indices are in which position
    this.newFilterMessage = 'Drag detectors from the right here to AND them together in a filter condition; add more leaves to OR together the different groups.'

    this.wrapperID = window.parameters.wrapper; //ID of wrapping div
    this.canvasID = 'editFilterCanvas';         //ID of canvas to paint filter on
    this.linkWrapperID = 'editFilterLinks';        //ID of div to contain clock view header
    this.sidebarID = 'editFilterSidebar';          //ID of sidebar div
    this.filterSystems = filterSystems; //subsytems available to participate in the filter
    this.filterSystemsNames = filterSystemsNames //human readable filterSystems

    this.wrapper = document.getElementById(this.wrapperID);

    //keep an internal list of all available filter:
    this.filterNames = [];
    //generate initial cycle list:
    for(key in ODB.Filters){
        if(ODB.Filters.hasOwnProperty(key) && typeof ODB.Filters[key] == 'object' && !Array.isArray(ODB.Filters[key])){
            this.filterNames[this.filterNames.length] = key;
        }
    }

    //nav wrapper div
    injectDOM('div', this.linkWrapperID, this.wrapperID, {'class':'navPanel'});
    //nav header
    injectDOM('h1', 'editFilterLinksBanner', this.linkWrapperID, {'class':'navPanelHeader', 'innerHTML':'Edit Filter'});
    injectDOM('br', 'break', this.linkWrapperID, {});
    //nav buttons
    injectDOM('button', 'returnToSummaryFilter', this.linkWrapperID, {
        'class' : 'navLink',
        'innerHTML' : 'Return to Filter Summary',
        'type' : 'button',
        'onclick' : function(){swapView('FilterLinks', 'FilterCanvas', 'FilterSidebar', 'FilterButton')}
    });
    injectDOM('button', 'commitFilter', this.linkWrapperID, {
        'class' : 'navLink',
        'innerHTML' : 'Deploy Filter and Return',
        'type' : 'button',
        'onclick' : deployFilter
    });
    injectDOM('button', 'abortFilter', this.linkWrapperID, {
        'class' : 'navLink',
        'innerHTML' : 'Reload Active Filter',
        'type' : 'button',
        'onclick' : reloadFilter
    });
    injectDOM('br', 'break', this.linkWrapperID, {});
    injectDOM('label', 'filterNameLabel', this.linkWrapperID, {'style' : 'margin-left:10px;', 'innerHTML' : 'Name this Filter: ', 'for':'filterName'});
    injectDOM('input', 'filterName', this.linkWrapperID, {'type':'text', 'value':'newFilter'});
    injectDOM('button', 'saveFilter', this.linkWrapperID, {
        'class' : 'navLink',
        'innerHTML' : 'Save Filter Definition',
        'type' : 'button',
        'onclick' : saveFilter
    });
    injectDOM('br', 'break', this.linkWrapperID, {});
    injectDOM('label', 'loadFilterLabel', this.linkWrapperID, {'style':'margin-left:10px;', 'innerHTML':'Load Filter: '});
    injectDOM('select', 'filterOptions', this.linkWrapperID, {});
    document.getElementById('loadFilterLabel').setAttribute('for', 'filterOptions');
    loadOptions(ODB.Filters, 'filterOptions');
    injectDOM('button', 'loadFilter', this.linkWrapperID, {
        'class':'navLink', 
        'innerHTML':'Load', 
        'type':'button',
        'onclick': loadFilter.bind(null)
    });
    injectDOM('button', 'deleteFilter', this.linkWrapperID, {
        'class' : 'navLink',
        'innerHTML' : 'Delete',
        'type' : 'button',
        'onclick' : function(){
            var name = getDrop('filterOptions');
            confirm('Delete Filter Definition', 'Do you really want to delete '+name+'?', deleteOption.bind(null, '/DashboardConfig/Filters/', 'filterOptions'));
            document.getElementById('tempDiv').style.top = window.innerHeight*0.2;
        }
    });
    injectDOM('br', 'break', this.linkWrapperID, {});

    //div structure for drag and drop area: right panel for detector palete, gutter for tree lines and main area for trigger groups:
    injectDOM('div', 'editFilterWrapper', this.linkWrapperID, {'style':'width:'+0.68*$(this.wrapper).width()+'px; display:inline-block; margin-top:1em'});
    injectDOM('div', 'filterWrap', 'editFilterWrapper', {'style':'float:left; width:79%'}); //79 kind of kludgy, to accommodate margins.
    injectDOM('div', 'treeGutter', 'filterWrap', {'style':'float:left; width:7%; text-align:center;'});
    injectDOM('div', 'treeBlockX', 'treeGutter', {'style':'height:20px;'});  //top block in tree gutter provides the first branch
    injectDOM('div', 'filterCons', 'filterWrap', {'style':'float:left; width:89%'});
    deployEmptyFilterCondition();
    injectDOM('div', 'filterPalete', 'editFilterWrapper', {
        'class' : 'filterDiv',
        'style' : 'width:15%; float:right; text-align:center; padding-top:1em; max-height:'+($('#leftSidebar').offset().top + $('#leftSidebar').offset().height - $('#filterWrap').offset().top)+'px; overflow:scroll; background-color:#222222; position:relative;',
    });
    injectDOM('button', 'newFilterCon', 'treeGutter', {
        'class' : 'addButton',
        'innerHTML' : '+',
        'type' : 'button',
        'onclick' : function(){deployEmptyFilterCondition()}
    });

    //deploy a dummy canvas for the filter view:
    this.canvasWidth = 0// 0.48*$(this.wrapper).width();
    this.canvasHeight = 0 //1*$(this.wrapper).height();
    injectDOM('canvas', this.canvasID, this.wrapperID, {'class':'monitor', 'style':'top:' + ($('#editFilterLinks').height() + 5) +'px;'});
    this.canvas = document.getElementById('editFilterCanvas');
    this.context = this.canvas.getContext('2d');
    this.canvas.setAttribute('width', this.canvasWidth);
    this.canvas.setAttribute('height', this.canvasHeight);

/*
    //right sidebar
    injectDOM('div', this.sidebarID, this.wrapperID, {'class':'collapsableSidebar', 'style':'float:right; height:80%;'});
    //deploy right bar menu:
    deployMenu(this.sidebarID, this.filterSystems, this.filterSystemsNames);    

    //inject inputs into filterable subsystem tabs:
    for(i=0; i<this.filterSystemsNames.length; i++){
        //prescale input + label
        injectDOM('input', this.filterSystems[i]+'ContentPS', this.filterSystems[i]+'Content', {'type':'number'});
        injectDOM('label', this.filterSystems[i]+'ContentPSlabel', this.filterSystems[i]+'Content', {'innerHTML':'Prescale Factor', 'for':this.filterSystems[i]+'ContentPS'});
        injectDOM('br', 'break', this.filterSystems[i]+'Content', {});

        //coinc multiplicity input + label
        injectDOM('input', this.filterSystems[i]+'ContentMulti', this.filterSystems[i]+'Content', {'type':'number'});
        injectDOM('label', this.filterSystems[i]+'ContentMultilabel', this.filterSystems[i]+'Content', {'innerHTML':'Coinc. Multiplicity', 'for':this.filterSystems[i]+'ContentMulti'});
        injectDOM('br', 'break', this.filterSystems[i]+'Content', {});

        //prescale input + label
        injectDOM('input', this.filterSystems[i]+'ContentCoincWindow', this.filterSystems[i]+'Content', {'type':'number'});
        injectDOM('label', this.filterSystems[i]+'ContentCoincWindowLabel', this.filterSystems[i]+'Content', {'innerHTML':'Coinc. Window [ns]', 'for':this.filterSystems[i]+'ContentCoincWindow'});
    }
*/
    injectDOM('div', this.sidebarID, this.wrapperID, {}); //dummy sidebar for transitions

    //inject detector options into palete
    this.badgeWidth = document.getElementById('filterPalete').offsetWidth*0.9;
    this.badgeHeight = 100;
    //DANTE
    if(ODB.DANTE)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'DANTEPaleteBadge', 'filterPalete', dante, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.25, '#999999'], 'DANTE', true);
    //PACES
    if(ODB.PACES)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'PACESPaleteBadge', 'filterPalete', paces, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.25, this.badgeHeight*0.25/3], 'PACES', true);
    //SCEPTAR
    if(ODB.SCEPTAR)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'SCEPTARPaleteBadge', 'filterPalete', sceptar, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.25], 'SCEPTAR', true);
    //HPGE
    deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'HPGEPaleteBadge', 'filterPalete', tigress, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.25], 'HPGE', true); 
    //ZDS
    if(ODB.ZDS)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'ZDSPaleteBadge', 'filterPalete', zds, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.25], 'ZDS', true);
    //SPICE
    if(ODB.SPICE)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'SPICEPaleteBadge', 'filterPalete', spice, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.25], 'SPICE', true);
    //DESCANT
    if(ODB.DESCANT)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'DESCANTPaleteBadge', 'filterPalete', descant, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.12], 'DESCANT', true);
    //BAMBINO
    if(ODB.BAMBINO)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'BAMBINOPaleteBadge', 'filterPalete', bambino, [this.badgeWidth*0.45, this.badgeWidth*0.55, this.badgeHeight/3, this.badgeHeight*0.6, this.badgeHeight*0.12], 'BAMBINO', true);
    //SHARC
    if(ODB.SHARC)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'SHARCPaleteBadge', 'filterPalete', sharc, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeWidth*0.3, this.badgeHeight*0.7], 'SHARC', true);
    //TIPwall
    if(ODB.TIPwall)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'TIPwallPaleteBadge', 'filterPalete', tipWall, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.7], 'TIP Wall', true);
    //TIPball
    if(ODB.TIPball)
        deployBadgeCanvas(this.badgeWidth, this.badgeHeight, 'TIPballPaleteBadge', 'filterPalete', tipBall, [this.badgeWidth/2, this.badgeHeight*0.35, this.badgeHeight*0.35], 'TIP Ball', true);

    reloadFilter();
}

//drag and drop handler functions:
function dragStart(event){
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', this.id.slice(0, this.id.indexOf('PaleteBadge')));
}

function handleDrop(event){
    var index = this.id.slice(18, this.id.length);

    event.stopPropagation();

    if(this.innerHTML == window.filterEditPointer.newFilterMessage)
        this.innerHTML = '';

    if(event.dataTransfer.getData('text/plain') == 'DANTE' && !this.querySelector('#DANTEfilterBadge'+this.id) ){
        deployFilterBadge('DANTEfilterBadge', this.id, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'DANTEfilterBadgeCanvas', 'DANTEfilterBadge'+this.id, dante, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25, '#999999'], 'DANTE', false));
    } else if(event.dataTransfer.getData('text/plain') == 'PACES' && !this.querySelector('#PACESfilterBadge'+this.id) ){
        deployFilterBadge('PACESfilterBadge', this.id, deployBadgeCanvas.bind(null,window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'PACESfilterBadgeCanvas', 'PACESfilterBadge'+this.id, paces, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25, window.filterEditPointer.badgeHeight*0.25/3], 'PACES', false));
    } else if(event.dataTransfer.getData('text/plain') == 'SCEPTAR' && !this.querySelector('#SCEPTARfilterBadge'+this.id) ){
        deployFilterBadge('SCEPTARfilterBadge', this.id, deployBadgeCanvas.bind(null,window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'SCEPTARfilterBadgeCanvas', 'SCEPTARfilterBadge'+this.id, sceptar, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25], 'SCEPTAR', false));
    } else if(event.dataTransfer.getData('text/plain') == 'HPGE' && !this.querySelector('#HPGEfilterBadge'+this.id) ){
        deployFilterBadge('HPGEfilterBadge', this.id, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'HPGEfilterBadgeCanvas', 'HPGEfilterBadge'+this.id, tigress, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25], 'HPGE', false));
    } else if(event.dataTransfer.getData('text/plain') == 'ZDS' && !this.querySelector('#ZDSfilterBadge'+this.id) ){
        deployFilterBadge('ZDSfilterBadge', this.id, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'ZDSfilterBadgeCanvas', 'ZDSfilterBadge'+this.id, zds, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25], 'ZDS', false));
    } else if(event.dataTransfer.getData('text/plain') == 'SPICE' && !this.querySelector('#SPICEfilterBadge'+this.id) ){
        deployFilterBadge('SPICEfilterBadge', this.id, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'SPICEfilterBadgeCanvas', 'SPICEfilterBadge'+this.id, spice, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25], 'SPICE', false));
    } else if(event.dataTransfer.getData('text/plain') == 'DESCANT' && !this.querySelector('#DESCANTfilterBadge'+this.id) ){
        deployFilterBadge('DESCANTfilterBadge', this.id, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'DESCANTfilterBadgeCanvas', 'DESCANTfilterBadge'+this.id, descant, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.12], 'DESCANT', false));
    } else if(event.dataTransfer.getData('text/plain') == 'BAMBINO' && !this.querySelector('#BAMBINOfilterBadge'+this.id) ){
        deployFilterBadge('BAMBINOfilterBadge', this.id, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'BAMBINOfilterBadgeCanvas', 'BAMBINOfilterBadge'+this.id, bambino, [window.filterEditPointer.badgeWidth*0.45, window.filterEditPointer.badgeWidth*0.55, window.filterEditPointer.badgeHeight/3, window.filterEditPointer.badgeHeight*0.6, window.filterEditPointer.badgeHeight*0.12], 'BAMBINO', false));
    } else if(event.dataTransfer.getData('text/plain') == 'SHARC' && !this.querySelector('#SHARCfilterBadge'+this.id) ){
        deployFilterBadge('SHARCfilterBadge', this.id, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'SHARCfilterBadgeCanvas', 'SHARCfilterBadge'+this.id, sharc, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeWidth*0.3, window.filterEditPointer.badgeHeight*0.7], 'SHARC', false));
    } else if(event.dataTransfer.getData('text/plain') == 'TIPwall' && !this.querySelector('#TIPwallfilterBadge'+this.id) ){
        deployFilterBadge('TIPwallfilterBadge', this.id, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'TIPwallfilterBadgeCanvas', 'TIPwallfilterBadge'+this.id, tipWall, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.7], 'TIP Wall', false));
    } else if(event.dataTransfer.getData('text/plain') == 'TIPball' && !this.querySelector('#TIPballfilterBadge'+this.id) ){
        deployFilterBadge('TIPballfilterBadge', this.id, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'TIPballfilterBadgeCanvas', 'TIPballfilterBadge'+this.id, tipBall, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.35], 'TIP Ball', false));
    } else {
        console.log(event.dataTransfer.getData('text/plain'));
    }

    //resize the appropriate tree gutter
    document.getElementById('treeBlock' + index).style.height = document.getElementById('filterGroup' + index).offsetHeight + parseInt(document.body.style.fontSize);

    return false;
}

function dragOver(event){
    event.stopPropagation();
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    return false;
}

//create a badge canvas
function deployBadgeCanvas(width, height, id, wrapperID, paintThumb, thumbArgs, label, draggable){
    var canvas, context;

    //bail out if canvas already exists:
    if(document.getElementById(id+wrapperID)) return;

    injectDOM('canvas', id+wrapperID, wrapperID, {
        'style':'width:'+this.badgeWidth+'px; height:'+this.badgeHeight+'px;',
        'class' : (draggable) ? 'paleteOption' : ''
    });
    canvas = document.getElementById(id+wrapperID);
    context = canvas.getContext('2d');
    canvas.setAttribute('width', width);
    canvas.setAttribute('height', height);
    context.font = Math.min(14, fitFont(context, label, width))+'px Raleway';
    context.fillStyle = '#999999';
    context.strokeStyle = '#999999';
    paintThumb.apply(null, [context].concat(thumbArgs));
    context.fillStyle = '#FFFFFF';
    context.fillText(label, width/2 - context.measureText(label).width/2, height-10);    
    //palete
    if(draggable){
        canvas.setAttribute('draggable', true);
        canvas.addEventListener('dragstart', dragStart, false);
    //filters
    } else{
        //bail out if this is a non-editable cycle summary:
        if(wrapperID.indexOf('cycleSummary') != -1) return;
        closeX(context, width - 10, 10, 7 );
        canvas.onclick = function(event){

                                var element, x,y, pointer,
                                    coords = this.relMouseCoords(event),
                                    width = (window.onDisplay == 'editFilterCanvas') ? window.filterEditPointer.badgeWidth : window.cyclePointer.badgeWidth;
                                x = coords.x;
                                y = coords.y;
                                if( Math.pow(width-10 - x, 2) + Math.pow(y-10,2) < 49 ){
                                    if(window.onDisplay == 'editFilterCanvas'){
                                        var index = this.id.slice(this.id.indexOf('filterGroupContent')+18, this.id.length);
                                        this.parentNode.parentNode.removeChild(this.parentNode);
                                        //resize the corresponding tree gutter:
                                        resizeBranches();
                                        //document.getElementById('treeBlock' + index).style.height = document.getElementById('filterGroup' + index).offsetHeight + parseInt(document.body.style.fontSize);
                                        //replace the intro message if there's nothing else to show:
                                        if(document.getElementById('filterGroupContent' + index).innerHTML == '')
                                            document.getElementById('filterGroupContent' + index).innerHTML = window.filterEditPointer.newFilterMessage;
                                        askForFilterDeploy();
                                    }
                                    else if(window.onDisplay == 'cycleCanvas'){
                                        pointer = this.parentNode;
                                        this.parentNode.removeChild(this);
                                        if(pointer.innerHTML == ''){
                                            pointer.innerHTML = window.cyclePointer.helpMessage;
                                            pointer.setAttribute('class', 'delayCycleContent');
                                        }
                                        askForCycleDeploy();
                                    }
                                }
                            };
    }

}

//create the full badge for the filter divs
function deployFilterBadge(id, wrapperID, createCanvas){
    injectDOM('div', id+wrapperID, wrapperID, {'class':'filterBadge'});
    document.getElementById(id+wrapperID).filterTag = filterTag(id.slice(0, id.indexOf('filterBadge')));
    createCanvas();
    createOptionScroll(id+wrapperID, id+wrapperID+'scroll', ['Singles', 'Coincidence', 'Prescaled'], document.getElementById(id+wrapperID).offsetWidth, filterScrollCB.bind(null, id+wrapperID)  );
    injectDOM('label', id+wrapperID+'label', id+wrapperID, {
        'innerHTML' : '',
        'for' : id+wrapperID+'factor'
    });
    injectDOM('input', id+wrapperID+'factor', id+wrapperID, {
        'type' : 'number',
        'class' : 'filterFactor',
        'style' : 'opacity:0',
        'min' : 0,
        'value' : 1
    });

    //update help messages:
    if(wrapperID == 'singleStreamFilters')
        document.getElementById('singleStreamHelp').innerHTML = 'Any of these:';
    else if(wrapperID.slice(0,11) == 'interstream')
        document.getElementById('interstreamHelp'+wrapperID.slice(11, wrapperID.length)).innerHTML = 'or ALL of these:'
    askForFilterDeploy();
    resizeBranches();
}

function filterScrollCB(target){
    scroll = document.getElementById(target+'scroll');
    if(scroll.chosen==0){
        document.getElementById(target+'label').innerHTML = '';
        document.getElementById(target+'factor').style.width = 0;        
        document.getElementById(target+'label').style.opacity = 0;
        document.getElementById(target+'factor').style.opacity = 0;
    } else if(scroll.chosen==1){
        document.getElementById(target+'label').innerHTML = 'Multiplicity: ';
        document.getElementById(target+'factor').style.width = '3em';
        document.getElementById(target+'label').style.opacity = 1;
        document.getElementById(target+'factor').style.opacity = 1;        
    } else if(scroll.chosen==2){
        document.getElementById(target+'label').innerHTML = 'Prescale Factor: ';
        document.getElementById(target+'factor').style.width = '6em';
        document.getElementById(target+'label').style.opacity = 1;
        document.getElementById(target+'factor').style.opacity = 1;        
    }
}

//parse the detector names into their tokens for the filter definition
function filterTag(detName){
    if(detName == 'DANTE')
        return 'DAB';
    else if(detName == 'PACES')
        return 'PAC';
    else if(detName == 'SCEPTAR')
        return 'SEP';
    else if(detName == 'HPGE')
        return 'GRG';
    else if(detName == 'ZDS')
        return 'ZDS';
    else if(detName == 'SPICE')
        return 'SPI';
    else if(detName == 'DESCANT')
        return 'DSC';
    else if(detName == 'BAMBINO')
        return 'BAE';
    else if(detName == 'SHARC')
        return 'SHB';
    else if(detName == 'TIPwall')
        return 'TPW';
    else if(detName == 'TIPball')
        return 'TPC';
    else
        return detName;
}

//parse whatever is currently declared into a filter string definition
function buildFilter(){
    var i, j, k, modeTag, filters = [],
        filterConditions = document.getElementById('filterCons');

    for(i=0; i<filterConditions.childNodes.length; i++){
        filters[i] = [];
        for(j=0; j<filterConditions.childNodes[i].childNodes.length; j++){
            for(k=0; k<filterConditions.childNodes[i].childNodes[j].childNodes.length; k++){
                if(filterConditions.childNodes[i].childNodes[j].childNodes[k].filterTag){
                    filterString = '';
                    //add subsystem tag
                    filterString += filterConditions.childNodes[i].childNodes[j].childNodes[k].filterTag;
                    //add Singles / Coinc / Prescale tag:
                    modeTag = filterConditions.childNodes[i].childNodes[j].childNodes[k].childNodes[1].childNodes[1].innerHTML;  //trololololo
                    modeTag = ( (modeTag == 'Singles') ? '-S' : ( (modeTag=='Prescaled') ? '-P' : '-C' ) );
                    filterString += modeTag;
                    //Include varibale prescale / coincidence multiplicity here; fixed to 1 until I get a real spec:
                    filterString += '-'+filterConditions.childNodes[i].childNodes[j].childNodes[k].childNodes[3].value;

                    filters[i][k] = filterString;
                }
            }
        }
    }

    return filters;
}

function deployEmptyFilterCondition(){
        var bottomFilterConID = window.filterEditPointer.filterConPresent[window.filterEditPointer.filterConPresent.length-1];

        //inject a new filter group:
        injectDOM('div', 'filterGroup'+window.filterEditPointer.filterConIndex, 'filterCons', {'class':'filterCon'});
        //inject a new tree gutter:
        injectDOM('div', 'treeBlock'+window.filterEditPointer.filterConIndex, 'treeGutter', {'class':'treeGutter', 'style':'display:none;'});
        //make sure the tree gutter comes above the new button:
        document.getElementById('treeGutter').insertBefore(document.getElementById('treeBlock'+window.filterEditPointer.filterConIndex), document.getElementById('newFilterCon'))
        //resize the previous tree gutter and reveal it to connect it to the tree:
        if(bottomFilterConID != undefined){
            document.getElementById('treeBlock' + bottomFilterConID).style.height = document.getElementById('filterGroup' + bottomFilterConID).offsetHeight + parseInt(window.getComputedStyle(document.body).fontSize);
            document.getElementById('treeBlock' + bottomFilterConID).style.display = 'block';
        }

        //off button
        injectDOM('button', 'deleteFilterCon'+window.filterEditPointer.filterConIndex, 'filterGroup'+window.filterEditPointer.filterConIndex, {
            'class' : 'deleteButton',
            'innerHTML' : String.fromCharCode(0x2573),
            'type' : 'button',
            'onclick' : function(){
                //refuse if this is the last condition:
                if(window.filterEditPointer.filterConPresent.length<2)
                    return;
                //delete elements
                var index = parseInt(this.id.slice(15, this.id.length), 10),
                    treeGutter = document.getElementById('treeBlock'+index); 
                    element = document.getElementById(this.id);
                treeGutter.parentNode.removeChild(treeGutter);
                element.parentNode.parentNode.removeChild(element.parentNode);
                //need to remove this group's index from filterConPresent
                window.filterEditPointer.filterConPresent.splice(window.filterEditPointer.filterConPresent.indexOf(index), 1);
                //hide previous tree gutter
                document.getElementById('treeBlock'+window.filterEditPointer.filterConPresent[window.filterEditPointer.filterConPresent.length-1]).style.display = 'none';
                askForFilterDeploy();
            }
        });
        //content block
        injectDOM('div', 'filterGroupContent'+window.filterEditPointer.filterConIndex, 'filterGroup'+window.filterEditPointer.filterConIndex, {'innerHTML':window.filterEditPointer.newFilterMessage});
        //prepare filter groups to accept new elements:
        document.getElementById('filterGroupContent'+window.filterEditPointer.filterConIndex).addEventListener('dragover', dragOver, false);
        document.getElementById('filterGroupContent'+window.filterEditPointer.filterConIndex).addEventListener('drop', handleDrop, false);

        window.filterEditPointer.filterConPresent[window.filterEditPointer.filterConPresent.length] = window.filterEditPointer.filterConIndex;
        window.filterEditPointer.filterConIndex++;
}

//step through the tree and make sure all the branches are the right size
function resizeBranches(){
    var i;

    for(i=0; i<window.filterEditPointer.filterConIndex; i++){
        if(document.getElementById('deleteFilterCon'+i) ){
            document.getElementById('treeBlock' + i).style.height = document.getElementById('filterGroup' + i).offsetHeight + parseInt(window.getComputedStyle(document.body).fontSize);
        }
    }
}

function saveFilter(){
    var i, deleteCode,
        filter = buildFilter(),
        name = document.getElementById('filterName').value,
        groups = [], types = [], arrayLengths = [], stringLength = [];

    //recreate the filter
    deleteCode = JSON.parse(ODBMDelete(['/DashboardConfig/Filters/'+name]));
    ODBMCreate(['/DashboardConfig/Filters/'+name], [TID_KEY]);

    //create arrays for each OR'ed group:
    for(i=0; i<filter.length; i++){
        groups[i] = '/DashboardConfig/Filters/'+name+'/group'+i;
        types[i] = TID_STRING;
        arrayLengths[i] = filter[i].length;
        stringLength[i] = 32;
    }
    ODBMCreate(groups, types, arrayLengths, stringLength);

    //populate arrays
    for(i=0; i<filter.length; i++){
        ODBSet('/DashboardConfig/Filters/'+name+'/group'+i+'[*]', filter[i]);   
    }

    //include in dropdown if new
    if(deleteCode[0] == 312){
        option = document.createElement('option');
        option.text = name;
        option.value = window.filterEditPointer.filterNames.length;
        window.filterEditPointer.filterNames[window.filterEditPointer.filterNames.length] = name;
        document.getElementById('filterOptions').add(option, null);
    }
}

function deployFilter(){

    var name = document.getElementById('filterName').value,
        filter = buildFilter(),
        i, deleteCode, oldGroups = [], groups = [], types = [], arrayLengths = [], stringLength = [];

    //write name:
    ODBSet('/DashboardConfig/Filters/Active Name', name);

    //delete old groups, max 100 OR'd conditions:
    for(i=0; i<100; i++){
        if(ODB.Filters['group'+i])
            oldGroups[oldGroups.length] = '/DashboardConfig/Filters/group'+i;
    }
    ODBMDelete(oldGroups);

    //write new filter groups
    //create arrays for each OR'ed group:
    for(i=0; i<filter.length; i++){
        groups[i] = '/DashboardConfig/Filters/group'+i;
        types[i] = TID_STRING;
        arrayLengths[i] = filter[i].length;
        stringLength[i] = 32;
    }
    ODBMCreate(groups, types, arrayLengths, stringLength);

    //populate arrays
    for(i=0; i<filter.length; i++){
        ODBSet('/DashboardConfig/Filters/group'+i+'[*]', filter[i]);   
    }

    //regrab ODB
    fetchODB();
    suspendFilterRequest();
    document.getElementById('FilterButton').onclick();
}

function reloadFilter(){
    var i,
        dropdown = document.getElementById('filterOptions');

    for(i=0; i<dropdown.childNodes.length; i++){
        if(dropdown.childNodes[i].innerHTML == ODB.Filters['Active Name']){
            dropdown.selectedIndex = i;
        }
    }

    loadFilter();
    suspendFilterRequest();
    fetchODB();
}

function loadFilter(){
    var name = getDrop('filterOptions'),
        filter = JSON.parse(ODBCopy('/DashboardConfig/Filters/'+name)),
        key, length, i, init=1, rule, detector, mode, factor, groupID, contentID, 
        counter, originalCount, badgeID, scroll, scrollButton;

    //load the name into the input box
    document.getElementById('filterName').value = name;

    //find the last rule index declared, and build from there; will delete earlier ones at the end
    for(i=0; i<window.filterEditPointer.filterConIndex; i++){
        if(document.getElementById('deleteFilterCon'+i))
            counter = i;
    }
    originalCount = counter;
    window.filterEditPointer.filterConIndex = counter+1

    for(key in filter){
        //skip the metadata
        if(key.indexOf('key') != -1) continue;

        //if there's just one thing, ODBCopy just returns it, not in an array :/
        length = ( typeof filter[key] == 'string' ) ? 1 : filter[key].length;

        //make a new block for each group:
        if(!init){
            document.getElementById('newFilterCon').onclick();
        } else
            init = 0;

        //construct the ID for this block:
        groupID = 'filterGroup' + counter;
        contentID = 'filterGroupContent' + counter;

        //dump the default text
        document.getElementById(contentID).innerHTML = '';

        //deploy all the individual elements in the block
        for(i=0; i<length; i++){
            //extract an individual rule
            if(length==1)
                rule = filter[key];
            else
                rule = filter[key][i];

            //slice the rule up into which detector in what mode with what prescale / multi factor:
            detector = rule.slice(0,3);
            mode = rule.slice(4,5);
            factor = parseInt( rule.slice(6, rule.length), 10 );

            //set us up the badge:
            if(detector == 'DAB'){
                deployFilterBadge('DANTEfilterBadge', contentID, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'DANTEfilterBadgeCanvas', 'DANTEfilterBadge'+contentID, dante, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25, '#999999'], 'DANTE', false));
                badgeID = 'DANTEfilterBadgefilterGroupContent'+counter;
            } else if(detector == 'PAC' ){
                deployFilterBadge('PACESfilterBadge', contentID, deployBadgeCanvas.bind(null,window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'PACESfilterBadgeCanvas', 'PACESfilterBadge'+contentID, paces, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25, window.filterEditPointer.badgeHeight*0.25/3], 'PACES', false));
                badgeID = 'PACESfilterBadgefilterGroupContent'+counter;
            } else if(detector == 'SEP' ){
                deployFilterBadge('SCEPTARfilterBadge', contentID, deployBadgeCanvas.bind(null,window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'SCEPTARfilterBadgeCanvas', 'SCEPTARfilterBadge'+contentID, sceptar, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25], 'SCEPTAR', false));
                badgeID = 'SCEPTARfilterBadgefilterGroupContent'+counter;
            } else if(detector == 'GRG' ){
                deployFilterBadge('HPGEfilterBadge', contentID, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'HPGEfilterBadgeCanvas', 'HPGEfilterBadge'+contentID, tigress, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25], 'HPGE', false));
                badgeID = 'HPGEfilterBadgefilterGroupContent'+counter;
            } else if(detector == 'ZDS' ){
                deployFilterBadge('ZDSfilterBadge', contentID, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'ZDSfilterBadgeCanvas', 'ZDSfilterBadge'+contentID, zds, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25], 'ZDS', false));
                badgeID = 'ZDSfilterBadgefilterGroupContent'+counter;
            } else if(detector == 'SPI' ){
                deployFilterBadge('SPICEfilterBadge', contentID, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'SPICEfilterBadgeCanvas', 'SPICEfilterBadge'+contentID, spice, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.25], 'SPICE', false));
                badgeID = 'SPICEfilterBadgefilterGroupContent'+counter;
            } else if(detector == 'DSC' ){
                deployFilterBadge('DESCANTfilterBadge', contentID, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'DESCANTfilterBadgeCanvas', 'DESCANTfilterBadge'+contentID, descant, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.12], 'DESCANT', false));
                badgeID = 'DESCANTfilterBadgefilterGroupContent'+counter;
            } else if(detector == 'BAE' ){
                deployFilterBadge('BAMBINOfilterBadge', contentID, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'BAMBINOfilterBadgeCanvas', 'BAMBINOfilterBadge'+contentID, bambino, [window.filterEditPointer.badgeWidth*0.45, window.filterEditPointer.badgeWidth*0.55, window.filterEditPointer.badgeHeight/3, window.filterEditPointer.badgeHeight*0.6, window.filterEditPointer.badgeHeight*0.12], 'BAMBINO', false));
                badgeID = 'BAMBINOfilterBadgefilterGroupontent'+counter;
            } else if(detector == 'SHB' ){
                deployFilterBadge('SHARCfilterBadge', contentID, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'SHARCfilterBadgeCanvas', 'SHARCfilterBadge'+contentID, sharc, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeWidth*0.3, window.filterEditPointer.badgeHeight*0.7], 'SHARC', false));
                badgeID = 'SHARCfilterBadgefilterGroupContent'+counter;
            } else if(detector == 'TPW' ){
                deployFilterBadge('TIPwallfilterBadge', contentID, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'TIPwallfilterBadgeCanvas', 'TIPwallfilterBadge'+contentID, tipWall, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.7], 'TIP Wall', false));
                badgeID = 'TIPwallfilterBadgefilterGroupContent'+counter;
            } else if(detector == 'TPC' ){
                deployFilterBadge('TIPballfilterBadge', contentID, deployBadgeCanvas.bind(null, window.filterEditPointer.badgeWidth, window.filterEditPointer.badgeHeight, 'TIPballfilterBadgeCanvas', 'TIPballfilterBadge'+contentID, tipBall, [window.filterEditPointer.badgeWidth/2, window.filterEditPointer.badgeHeight*0.35, window.filterEditPointer.badgeHeight*0.35], 'TIP Ball', false));
                badgeID = 'TIPballfilterBadgefilterGroupContent'+counter;
            }

            //get the scroll in the right position:
            scroll = document.getElementById(badgeID+'scroll');
            scrollButton = document.getElementById(badgeID+'scrollLeftArrow');
            if(mode == 'C'){
                while(scroll.chosen != 1)
                    scrollButton.onclick();
            } else if(mode == 'P'){
                while(scroll.chosen != 2)
                    scrollButton.onclick();
            }

            //assign multiplicity / prescale factor:
            document.getElementById(badgeID + 'factor').value = factor;

        }
        counter++;

    }

    //delete any rules that may have come before:
    for(i=0; i<originalCount; i++){
        if(document.getElementById('deleteFilterCon'+i))
            document.getElementById('deleteFilterCon'+i).onclick();
    }

    askForFilterDeploy();
}

//start the deploy filter button flashing:
function askForFilterDeploy(){
    document.getElementById('commitFilter').style.webkitAnimationName = 'alertBorder';
    document.getElementById('commitFilter').style.mozAnimationName = 'alertBorder';
}

//suspend request for cycle deployment
function suspendFilterRequest(){
    document.getElementById('commitFilter').style.webkitAnimationName = 'x';
    document.getElementById('commitFilter').style.mozAnimationName = 'x';    
}





HPGe.prototype = Object.create(Subsystem.prototype);

function HPGe(){
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'HPGe';
    var that = this;
    Subsystem.call(this);
    window.HPGepointer = that;

    //member variables////////////////////////////////////////////////////////
    this.cloverShowing = 1;                         //index of clover currently showing in detail view
    this.detailShowing = 0;                         //is the detail canvas showing?
    this.scalePrefix = 'Clover ';                   //prefix for scale title
    this.cloversAbsent = [];                        //are any clovers removed to accomodate other subsystems?
    if(ODB.HPGe.upstreamLampAbsent)
        this.cloversAbsent = this.cloversAbsent.concat([13,14,15,16]);
    if(ODB.HPGe.downstreamLampAbsent)
        this.cloversAbsent = this.cloversAbsent.concat([1,2,3,4]);    

    this.mode = ODB.topLevel.HPGeArray;         //mode to run in, either 'TIGRESS' or 'GRIFFIN'
    this.dataBus = new cloverDS(16, this.mode);     //called after mode is fetched in order to know what kind of HPGe to deploy
    this.nHPGesegments = 0;
    if(this.mode == 'TIGRESS')
        this.nHPGesegments = 40;
    else if(this.mode == 'GRIFFIN')
        this.nHPGesegments = 8;

    this.BGOenable = window.parameters.BGOenable;   //are the suppresors present?

    DetailView.call(this);                          //inject the infrastructure for a detail-level view
    HPGeAssets.call(this);                          //inject the HPGe drawing assets

    //HPGe subsystem button needs special behavior, to call back the top view from the detail level
    document.getElementById('HPGelink').onclick = function(){
        if(that.detailShowing){
            that.detailShowing = 0;
            that.detailTooltip.canvas.onmouseout(); //edge case, clicking back to main view w/o moving mouse causes detail TT to try and update, suppress.
            //swapFade(null, that, 1000);
            swapFade(this.id, that, window.subsystemScalars);
        } else{
            swapFade(this.id, this.parentPointer, window.subsystemScalars); 
            rePaint();
        }
    }

    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['HPGe', 'BGO'];

    //onclick switch between top and detail view:
    this.detailCanvas.onclick = function(event){
                                    var y = event.pageY - that.canvas.offsetTop - that.monitor.offsetTop;    
                                    if(y < that.canvasHeight - that.scaleHeight){
                                        if(that.pointingNow)
                                            getSubsystemSpectrum(that.pointingNow);
                                            //document.getElementById(that.pointingNow+'spectrum').onclick();
                                    } else{
                                        parameterDialogue(that.name, [['HPGe', ODB[that.name][that.constructMinMaxKey('HPGe')][0], ODB[that.name][that.constructMinMaxKey('HPGe')][1], window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/HPGe/'+scaleType()+'[0]', '/DashboardConfig/HPGe/'+scaleType()+'[1]'], ['BGO', ODB[that.name][that.constructMinMaxKey('BGO')][0], ODB[that.name][that.constructMinMaxKey('BGO')][1],  window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/HPGe/BGO'+scaleType()+'[0]', '/DashboardConfig/HPGe/BGO'+scaleType()+'[1]'] ], window.parameters.subdetectorColors[window.state.subdetectorView]);
                                    }
                                };
    this.canvas.onclick =   function(event){
                                //use TT layer to decide which clover user clicked on
                                var cloverClicked = -1;
                                var x,y;
                                x = event.pageX - that.canvas.offsetLeft - that.monitor.offsetLeft;
                                y = event.pageY - that.canvas.offsetTop - that.monitor.offsetTop;
                                cloverClicked = that.findCell(x,y);
                                //draw and swap out if user clicked on a valid clover
                                if(cloverClicked != -1){
                                    cloverClicked = Math.floor( (cloverClicked - 108) / 8)+1;
                                    that.TTdetailLayerDone = 0;  //need to redraw detail TT layer for different detail views
                                    if(that.cloversAbsent.indexOf(cloverClicked)==-1){
                                        that.cloverShowing = cloverClicked
                                        that.drawDetail(that.detailContext, that.nFrames);
                                        that.drawDetail(that.TTdetailContext, that.nFrames);
                                        that.detailShowing = 1;
                                        that.tooltip.canvas.onmouseout();
                                        swapFade(null, that, 1000)
                                    }
                                } else if(y > that.canvasHeight - that.scaleHeight){
                                    parameterDialogue(that.name, [['HPGe', ODB[that.name][that.constructMinMaxKey('HPGe')][0], ODB[that.name][that.constructMinMaxKey('HPGe')][1], window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/HPGe/'+scaleType()+'[0]', '/DashboardConfig/HPGe/'+scaleType()+'[1]'], ['BGO', ODB[that.name][that.constructMinMaxKey('BGO')][0], ODB[that.name][that.constructMinMaxKey('BGO')][1],  window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/HPGe/BGO'+scaleType()+'[0]', '/DashboardConfig/HPGe/BGO'+scaleType()+'[1]'] ], window.parameters.subdetectorColors[window.state.subdetectorView]);
                                }
                            };


    //drawing parameters/////////////////////////////////////////////////////////////////////////////////////////////
    this.centerX = this.canvasWidth/2;
    this.centerY = this.canvasHeight*0.4;
    this.lineWeight = 1;
    this.context.lineWidth = this.lineWeight;
    this.context.strokeStyle = '#999999';

    this.BGOouter = 0.09*this.canvasWidth;
    this.BGOinner = 0.67*this.BGOouter;
    this.HPGeside = 0.4*this.BGOouter;

    this.firstRow = this.centerY - this.BGOouter/2 - .112*this.canvasWidth;
    this.secondRow = this.centerY - this.BGOouter/2;
    this.thirdRow = this.centerY - this.BGOouter/2 + .112*this.canvasWidth;

    this.firstCol = this.canvasWidth*0.022;
    this.secondCol = this.canvasWidth*0.134;
    this.thirdCol = this.canvasWidth*0.246;
    this.fourthCol = this.canvasWidth*0.358;
    this.fifthCol = this.canvasWidth*0.540;
    this.sixthCol = this.canvasWidth*0.652;
    this.seventhCol = this.canvasWidth*0.764;
    this.eighthCol = this.canvasWidth*0.876;

    this.summaryCoord = [];
    this.summaryCoord[5] = [this.thirdCol, this.secondRow, 'north'];
    this.summaryCoord[6] = [this.fourthCol, this.secondRow, 'north'];
    this.summaryCoord[7] = [this.fifthCol, this.secondRow, 'south'];
    this.summaryCoord[8] = [this.sixthCol, this.secondRow, 'south'];
    this.summaryCoord[9] = [this.seventhCol, this.secondRow, 'south']; 
    this.summaryCoord[10] = [this.eighthCol, this.secondRow, 'south'];
    this.summaryCoord[11] = [this.firstCol, this.secondRow, 'north'];
    this.summaryCoord[12] = [this.secondCol, this.secondRow, 'north'];
    if(this.mode == 'TIGRESS'){
        this.summaryCoord[1] = [this.thirdCol, this.firstRow, 'north'];
        this.summaryCoord[2] = [this.fifthCol, this.firstRow, 'south'];
        this.summaryCoord[3] = [this.seventhCol, this.firstRow, 'south'];
        this.summaryCoord[4] = [this.firstCol, this.firstRow, 'north'];
        this.summaryCoord[13] = [this.thirdCol, this.thirdRow, 'north'];
        this.summaryCoord[14] = [this.fifthCol, this.thirdRow, 'south'];
        this.summaryCoord[15] = [this.seventhCol, this.thirdRow, 'south'];
        this.summaryCoord[16] = [this.firstCol, this.thirdRow, 'north'];
    } else if(this.mode == 'GRIFFIN'){
        this.summaryCoord[1] = [this.fourthCol, this.firstRow, 'north'];
        this.summaryCoord[2] = [this.sixthCol, this.firstRow, 'south'];
        this.summaryCoord[3] = [this.eighthCol, this.firstRow, 'south'];
        this.summaryCoord[4] = [this.secondCol, this.firstRow, 'north'];
        this.summaryCoord[13] = [this.fourthCol, this.thirdRow, 'north'];
        this.summaryCoord[14] = [this.sixthCol, this.thirdRow, 'south'];
        this.summaryCoord[15] = [this.eighthCol, this.thirdRow, 'south'];
        this.summaryCoord[16] = [this.secondCol, this.thirdRow, 'north'];
    }

    //detail view
    this.crystalSide = this.canvasWidth*0.1*0.8;
    this.suppressorWidth = this.canvasWidth*0.03*0.8;
    this.suppressorSpacing = this.canvasWidth*0.04*0.8;
    this.backBGOinnerWidth = 2*this.crystalSide + 2*this.suppressorSpacing;
    this.backBGOouterWidth = this.backBGOinnerWidth + 2*this.suppressorWidth;
    this.sideBGOinnerWidth = this.backBGOouterWidth + 2*this.suppressorSpacing;
    this.sideBGOouterWidth = this.sideBGOinnerWidth + 2*this.suppressorWidth;
    this.frontBGOinnerWidth = this.sideBGOouterWidth + 2*this.suppressorSpacing;
    this.frontBGOouterWidth = this.frontBGOinnerWidth + 2*this.suppressorWidth;
    this.sideSpacer = 20;

    //Member functions/////////////////////////////////////////////////////////////////////////////////

    //function to wrap drawing for animate
    this.draw = function(frame){
        var i, summaryKey,
            pfx = (this.mode == 'TIGRESS') ? 'TI' : 'GR';

        //beam arrow
        this.context.clearRect(this.centerX-0.04*this.canvasWidth, 0, 0.07*this.canvasWidth, 0.7*this.canvasHeight);
        this.context.fillStyle = '#999999';
        this.context.font="24px 'Orbitron'";
        this.context.moveTo(this.centerX, 0.7*this.canvasHeight);
        this.context.lineTo(this.centerX, 0.1*this.canvasHeight);
        this.context.lineTo(this.centerX + 10, 0.1*this.canvasHeight + 10);
        this.context.stroke();
        this.context.save();
        this.context.translate(this.centerX-5, 0.1*this.canvasHeight);
        this.context.rotate(-Math.PI/2);
        this.context.fillText('Beam', -this.context.measureText('Beam').width-10, 0);
        this.context.restore();

        for(i=1; i<17; i++){
            summaryKey = pfx+'G' + ( (i<10) ? '0'+i : i );
            this.drawHPGesummary(this.context, this.summaryCoord[i][0], this.summaryCoord[i][1], summaryKey, frame);
            if(!this.TTlayerDone)
                this.drawHPGesummary(this.TTcontext, this.summaryCoord[i][0], this.summaryCoord[i][1], summaryKey, frame);

            summaryKey = pfx+'S' + ( (i<10) ? '0'+i : i );
            this.drawHPGesummary(this.context, this.summaryCoord[i][0], this.summaryCoord[i][1], summaryKey, frame);
            if(!this.TTlayerDone)
                this.drawHPGesummary(this.TTcontext, this.summaryCoord[i][0], this.summaryCoord[i][1], summaryKey, frame);            
        }

        //titles
        this.context.clearRect(0,0.75*this.canvasHeight,this.canvasWidth,0.25*this.canvasHeight - this.scaleHeight);
        this.context.fillStyle = '#999999';
        this.context.font="24px 'Orbitron'";
        if(this.mode == 'TIGRESS'){
            this.context.fillText('North Hemisphere', 0.201*this.canvasWidth + this.BGOouter/2 - this.context.measureText('North Hemisphere').width/2, 0.78*this.canvasHeight);
            this.context.fillText('South Hemisphere', 0.701*this.canvasWidth + this.BGOouter/2 - this.context.measureText('North Hemisphere').width/2, 0.78*this.canvasHeight);
        } else if(this.mode == 'GRIFFIN'){
            this.context.fillText('West Hemisphere', 0.201*this.canvasWidth + this.BGOouter/2 - this.context.measureText('West Hemisphere').width/2, 0.78*this.canvasHeight);
            this.context.fillText('East Hemisphere', 0.701*this.canvasWidth + this.BGOouter/2 - this.context.measureText('East Hemisphere').width/2, 0.78*this.canvasHeight);
        }

        if(frame==this.nFrames || frame==0) this.drawScale(this.context);

        this.TTlayerDone = 1;
    };

    this.defineText = function(cell){
        var toolTipContent = '';
        var nextLine;

        toolTipContent += this.defineHPGeText(cell) + '<br>';

        if(this.detailShowing){
            document.getElementById(this.detailTooltip.ttDivID).innerHTML = toolTipContent;
        } else{
            if( cell==255 || !( ((cell-100)%8 < 4) && this.mode=='TIGRESS') ){  //HPGe summaries on TIGRESS have so much stuff in them, they need to build their own table :(
                document.getElementById(this.tooltip.ttDivID).innerHTML = toolTipContent;
            }
        }

        return 0;

    };

    this.update = function(){
        //get new data
        this.fetchNewData();

        //update the databus
        this.updateHPGe();

        //update tooltips
        this.tooltip.update();
        this.detailTooltip.update();
        //this.displaySwitch();

        //animate if on top:
        this.animate();
    };

    this.fetchNewData = function(){
        this.fetchHPGeData();
    };

    //do an initial populate
    //console.log('first Update')
    //this.update();
}PACES.prototype = Object.create(Subsystem.prototype);

function PACES(){
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'PACES';
    var that = this;
    Subsystem.call(this);
    this.dataBus = new PACESDS();
    //make a pointer at window level back to this object, so we can pass by reference to the nav button onclick
    window.PACESpointer = that;

    //member variables///////////////////////////////////
    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['PACES'];

    //drawing parameters
    this.centerX = this.canvasWidth/2;
    this.centerY = this.canvasHeight*0.45;
    this.arrayRadius = this.canvasHeight*0.3;
    this.SiLiRadius = this.canvasHeight*0.1;

    //member functions///////////////////////////////////////////////////////////////////

    this.draw = function(frame){

    	var i, name, fill;
    	this.context.strokeStyle = '#999999'

        //Thresholds & Rate view///////////////////////////////////////
        //once for the display canvas....
        if(window.state.subdetectorView == 1 || window.state.subdetectorView == 2){
        	for(i=0; i<5; i++){

                name = 'PAC0'+(i+1)+'XN00A';

        		this.context.save();
        		this.context.translate(this.centerX, this.centerY);
        		this.context.rotate(i*Math.PI*72/180);

                fill = colors(name, this.dataBus.PACES, frame, this.nFrames);
                this.context.fillStyle =  (fill == 0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
        		this.context.beginPath();
        		this.context.arc(0, -this.arrayRadius, this.SiLiRadius, 0, Math.PI);
        		this.context.closePath();
                this.context.fill();
        		this.context.stroke();

                name = 'PAC0'+(i+1)+'XN00B';

                fill = colors(name, this.dataBus.PACES, frame, this.nFrames);
                this.context.fillStyle =  (fill == 0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
                this.context.beginPath();
                this.context.arc(0, -this.arrayRadius, this.SiLiRadius, Math.PI, 0);
                this.context.closePath();
                this.context.fill();
                this.context.stroke();

        		this.context.restore();
        	}
        }
        //...and again for the tooltip encoding
        if(!this.TTlayerDone){
            for(i=0; i<5; i++){
                this.TTcontext.save();
                this.TTcontext.translate(this.centerX, this.centerY);
                this.TTcontext.rotate(i*Math.PI*72/180);

                this.TTcontext.fillStyle = 'rgba('+(2*i+1)+','+(2*i+1)+','+(2*i+1)+',1)';
                this.TTcontext.beginPath();
                this.TTcontext.arc(0, -this.arrayRadius, this.SiLiRadius, 0, Math.PI);
                this.TTcontext.closePath();
                this.TTcontext.fill();

                this.TTcontext.fillStyle = 'rgba('+(2*i+2)+','+(2*i+2)+','+(2*i+2)+',1)';
                this.TTcontext.beginPath();
                this.TTcontext.arc(0, -this.arrayRadius, this.SiLiRadius, Math.PI, 0);
                this.TTcontext.closePath();
                this.TTcontext.fill();

                this.TTcontext.restore();

            }
            this.TTlayerDone = 1;
        }

        //HV view///////////////////////////////////////////
        if(window.state.subdetectorView == 0){
            for(i=0; i<5; i++){

                name = 'PAC0'+(i+1)+'XN00A';  //real voltage is plugged into seg. A; seg B voltage contains garbage data, don't use.

                fill = colors(name, this.dataBus.PACES, frame, this.nFrames);
                this.context.fillStyle =  (fill == 0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
                this.context.save();
                this.context.translate(this.centerX, this.centerY);
                this.context.rotate(i*Math.PI*72/180);
                this.context.beginPath();
                this.context.arc(0, -this.arrayRadius, this.SiLiRadius, 0, 2*Math.PI);
                this.context.closePath();
                this.context.fill();
                this.context.stroke();
                this.context.restore();
            }
        }

        if(frame==this.nFrames || frame==0) {
            //scale
            this.drawScale(this.context);
        }
    };

    //do an initial populate:
    //this.update();
}SCEPTAR.prototype = Object.create(Subsystem.prototype);

function SCEPTAR(){
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'SCEPTAR';
    var that = this;
    Subsystem.call(this);
    //establish which of USSCEPTAR, DSSCEPTAR, and ZDS are present:
    this.SCEPTARconfig = [ODB.SCEPTAR.USdeploy, ODB.SCEPTAR.DSdeploy%2, Math.floor(ODB.SCEPTAR.DSdeploy/2)];
    this.dataBus = new SCEPTARDS(this.SCEPTARconfig);
    //make a pointer at window level back to this object, so we can pass by reference to the nav button onclick
    window.SCEPTARpointer = that;

    //member variables///////////////////////////////////
    this.config = this.SCEPTARconfig;  //subsystems on: [upstream sceptar, downstream sceptar, downstream ZDS]
    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['SCEPTAR'];
    if(ODB.SCEPTAR.DSdeploy == 2) this.subdetectors[1] = 'ZDS';

    //set up scale adjust dialog:
    this.canvas.onclick = function(event){
        var y = event.pageY - that.canvas.offsetTop - that.monitor.offsetTop;
        if(y > that.canvasHeight - that.scaleHeight){
            if(that.config[2]) parameterDialogue(that.name, [['SCEPTAR', ODB[that.name][that.constructMinMaxKey('SCEPTAR')][0], ODB[that.name][that.constructMinMaxKey('SCEPTAR')][1], window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/SCEPTAR/'+scaleType()+'[0]', '/DashboardConfig/SCEPTAR/'+scaleType()+'[1]'],   ['ZDS', ODB[that.name][that.constructMinMaxKey('ZDS')][0], ODB[that.name][that.constructMinMaxKey('ZDS')][1], window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/ZDS/'+scaleType()+'[0]', '/DashboardConfig/ZDS/'+scaleType()+'[1]'] ], window.parameters.subdetectorColors[window.state.subdetectorView]);
            else parameterDialogue(that.name, [['SCEPTAR', ODB[that.name][that.constructMinMaxKey('SCEPTAR')][0], ODB[that.name][that.constructMinMaxKey('SCEPTAR')][1], window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/SCEPTAR/'+scaleType()+'[0]', '/DashboardConfig/SCEPTAR/'+scaleType()+'[1]']], window.parameters.subdetectorColors[window.state.subdetectorView]);

        }
    }

    //make the button say ZDS if only ZDS is deployed:
    if(this.config[2]==1 && this.config[0]==0 && this.config[1]==0)
        document.getElementById('SCEPTARlink').innerHTML = 'ZDS';

    //drawing parameters///////////////////////////////////////
    this.ZDSradius = this.canvasHeight*0.5 / 4; 
    this.ZDScenterX = this.canvasWidth*0.5 + (this.config[0] +this.config[1] + this.config[2] - 1)*this.canvasWidth*0.25;
    this.ZDScenterY = 0.4*this.canvasHeight;
    this.SCEPTARx0 = this.canvasWidth*0.1;
    this.SCEPTARy0 = this.canvasHeight*0.1;

    this.SCEPTARspoke = this.canvasHeight/5;
    this.USSCx0 = (this.config[0] + this.config[1] + this.config[2] == 2) ? 0.25*this.canvasWidth : 0.5*this.canvasWidth;
    this.USSCy0 = 0.4*this.canvasHeight;
    this.DSSCx0 = (this.config[0] + this.config[1] + this.config[2] == 2) ? 0.75*this.canvasWidth : 0.5*this.canvasWidth;
    this.DSSCy0 = 0.4*this.canvasHeight;

    //member functions///////////////////////////////////////////////////////////////////


    this.draw = function(frame){
    	var i, row, col, fill;

        //once for display view...
    	this.context.strokeStyle = '#999999';
        //upstream SCEPTAR
        if(this.config[0] == 1){
            this.drawSceptar('upstream', frame, this.context);
        }
        //downstream SCEPTAR
        if(this.config[1] == 1){
            this.drawSceptar('downstream', frame, this.context);
        }
    	//ZDS
        if(this.config[2] == 1){
            fill = colors('ZDS01XN00X', this.dataBus.SCEPTAR, frame, this.nFrames);
            this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
        	this.context.beginPath();
    	    this.context.arc(this.ZDScenterX, this.ZDScenterY, this.ZDSradius, 0, 2*Math.PI);
        	this.context.closePath();
        	this.context.fill();
    	    this.context.stroke();
        }

        //...and again for tt encoding:
        if(!this.TTlayerDone){
            //upstream SCEPTAR
            if(this.config[0] == 1){
                this.drawSceptar('upstream', frame, this.TTcontext);
            }
            //downstream SCEPTAR
            if(this.config[1] == 1){
                this.drawSceptar('downstream', frame, this.TTcontext);
            }
            //ZDS
            if(this.config[2] == 1){
                //antialiasing hackaround:
                this.TTcontext.beginPath();
                this.TTcontext.arc(this.ZDScenterX, this.ZDScenterY, 1.05*this.ZDSradius, 0, 2*Math.PI);
                this.TTcontext.closePath();
                this.TTcontext.fillStyle = '#123456';
                this.TTcontext.fill();
                //end hack around
                this.TTcontext.beginPath();
                this.TTcontext.arc(this.ZDScenterX, this.ZDScenterY, this.ZDSradius, 0, 2*Math.PI);
                this.TTcontext.closePath();
                this.TTcontext.fillStyle = 'rgba('+21+','+21+','+21+',1)';
                this.TTcontext.fill();
            }
            this.TTlayerDone = 1;
        }
   

    	//titles
        this.context.clearRect(0,this.SCEPTARy0 + 2.5*this.SCEPTARspoke + 10,this.canvasWidth,this.canvasHeight - (this.scaleHeight+this.SCEPTARy0 + 2.5*this.SCEPTARspoke + 10));
        this.context.fillStyle = '#999999';
        this.context.font="24px 'Orbitron'";
        if(this.config[0] == 1){
            this.context.fillText('Upstream SCEPTAR', this.USSCx0 - this.context.measureText('Upstream SCEPTAR').width/2, this.USSCy0 + 1.4*this.SCEPTARspoke);
        }
        if(this.config[1] == 1){
            this.context.fillText('Downstream SCEPTAR', this.DSSCx0 - this.context.measureText('Downstream SCEPTAR').width/2, this.DSSCy0 + 1.4*this.SCEPTARspoke);
        }
        if(this.config[2] == 1){
            this.context.fillText('ZDS', this.ZDScenterX - this.context.measureText('ZDS').width/2, this.ZDScenterY + 1.4*this.SCEPTARspoke);    
        }

        //scale
        if(frame==this.nFrames || frame==0) this.drawScale(this.context);
	
    };

    this.drawSceptar = function(side, frame, context){
        var x0, y0, i, indexStart, name;
        if(side == 'upstream'){
            x0 = this.USSCx0;
            y0 = this.USSCy0;
            indexStart = 0;
        } else if(side == 'downstream'){
            x0 = this.DSSCx0;
            y0 = this.DSSCy0;
            indexStart = 10;
        }

        for(i=0; i<10; i++){
            name = (indexStart+i+1<10) ? 'SEP0'+(indexStart+i+1)+'XN00X' : 'SEP'+(indexStart+i+1)+'XN00X'

            if(context == this.context){
                fill = colors(name, this.dataBus.SCEPTAR, frame, this.nFrames);
                this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
            }
            else if(context == this.TTcontext) context.fillStyle = '#123456'; //anti-antialiasing
            context.save();
            context.translate(x0, y0);
            context.rotate((i%5)*Math.PI/180*72);
            context.beginPath();
            context.moveTo(0,0);
            context.lineTo(0, -this.SCEPTARspoke/2*( 2 - Math.floor(i/5) ) );
            context.rotate(Math.PI/180*72);
            context.lineTo(0, -this.SCEPTARspoke/2*( 2 - Math.floor(i/5) ) );
            context.closePath();
            context.fill();
            if(context == this.context) context.stroke();
            context.restore();

            if(context == this.TTcontext){
                context.fillStyle = 'rgba('+(indexStart+1+i)+','+(indexStart+1+i)+','+(indexStart+1+i)+',1)';
                context.save();
                context.translate(x0, y0);
                context.rotate((i%5)*Math.PI/180*72);
                context.beginPath();
                context.moveTo(0,0);
                context.lineTo(0, -this.SCEPTARspoke/2*( 2 - Math.floor(i/5) ) );
                context.rotate(Math.PI/180*72);
                context.lineTo(0, -this.SCEPTARspoke/2*( 2 - Math.floor(i/5) ) );
                context.closePath();
                context.fill();
                context.restore();
            }
        }   
    }

    //do an initial populate:
    //this.update();
}SHARC.prototype = Object.create(Subsystem.prototype);
function SHARC(){
    //basic plumbing:
    this.name = 'SHARC';                //name prefix
    var that = this;                    //pointer to self
    Subsystem.call(this);               //inject Subsystem attributes
    window.SHARCpointer = that;         //send a pointer to SHARC up to global scope
    this.dataBus = new SHARCDS();       //build the data structure to manage SHARC's info
    DetailView.call(this);              //inject the infrastructure for a detail level view

    //member variables////////////////////
    this.padsEnabled = window.parameters.SHARCpads;     //are the pads present?
    this.detailShowing = 0;                             //is the detail view on display?
    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['SHARC'];

    //drawing parameters:
    //summary view is laid out on a 15x12 grid:
    this.cellWidth = this.canvasWidth/15;
    this.cellHeight = (this.canvasHeight - this.scaleHeight)/12
    this.quadInnerRad = 0.05*this.cellWidth;
    this.quadOuterRad = 0.98*this.cellWidth;
    this.quadSquish = 0.98*this.cellHeight/this.quadOuterRad/2;
    this.context.strokeStyle = '#999999';

    //detail view
    this.innerQuadRadDetail = this.canvasHeight*0.1;
    this.outerQuadRadDetail = this.canvasHeight*0.6;
    this.quadArcDetail = 0.45*Math.PI/2;
    this.detailTitles = ['Upstream Quadrant 1', 'Upstream Quadrant 2', 'Upstream Quadrant 3', 'Upstream Quadrant 4', 'Upstream Box 1', 'Upstream Box 2', 'Upstream Box 3', 'Upstream Box 4', 'Downstream Box 1', 'Downstream Box 2', 'Downstream Box 3', 'Downstream Box 4', 'Downstream Quadrant 1', 'Downstream Quadrant 2', 'Downstream Quadrant 3', 'Downstream Quadrant 4']
    this.quadDetailFrontCenter = (0.3 - 0.1*this.padsEnabled)*this.canvasWidth;
    this.quadDetailBackCenter = (0.7 - 0.1*this.padsEnabled)*this.canvasWidth;
    this.boxDetailFrontLeftEdge = 0.1*this.canvasWidth*(1-this.padsEnabled);
    this.boxDetailBackLeftEdge = (0.52-0.1*this.padsEnabled)*this.canvasWidth;
    this.scaleDown = 0.9;

    //member functions////////////////////

    this.draw = function(frame){
        var dummyColors4 = ['#000000', '#444444', '#AAAAAA', '#FFFFFF'], i, dummyColors16 = [], x, TTcolors = [];
        for(i=0; i<16; i++){
            x = i.toString(16);
            dummyColors16[i] = '#'+x+x+x+x+x+x;
        }

        //UPSTREAM//////////////////////////////////////
        if(this.padsEnabled){
            //upstream quad pad back
            //quadBack(this.context, 1*this.cellWidth, 11.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, colors(['SHQ13FN00X', 'SHQ14FN00X', 'SHQ15FN00X', 'SHQ16FN00X'], this.dataBus.SHARC, frame, this.nFrames), 0);
            //upstream quad pad front
            quadBack(this.context, 1.5*this.cellWidth, 10.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, colors(['SHQ13EP00X', 'SHQ14EP00X', 'SHQ15EP00X', 'SHQ16EP00X'], this.dataBus.SHARC, frame, this.nFrames), 0);       

            //tooltip:
            if(!this.TTlayerDone){
                TTcolors = ['rgba(113,113,113,1)', 'rgba(114,114,114,1)', 'rgba(115,115,115,1)', 'rgba(116,116,116,1)'];
                //upstream quad pad back
                //quadBack(this.TTcontext, 1*this.cellWidth, 11.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, TTcolors, 1);
                //upstream quad pad front
                quadBack(this.TTcontext, 1.5*this.cellWidth, 10.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, TTcolors, 1); 
            }
        }

        //upstream quad back
        quadBack(this.context, 2*this.cellWidth, 9.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, this.meanColor('SHQ13DN', frame, 0).concat(this.meanColor('SHQ14DN', frame, 0), this.meanColor('SHQ15DN', frame, 0), this.meanColor('SHQ16DN', frame, 0)), 0);
        //upstream quad front
        quadFront(this.context, 2.5*this.cellWidth, 8.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, this.meanColor('SHQ13DP', frame, 0).concat(this.meanColor('SHQ14DP', frame, 0), this.meanColor('SHQ15DP', frame, 0), this.meanColor('SHQ16DP', frame, 0)), 0);
        //upstream quad tooltip:
        if(!this.TTlayerDone){
            //upstream quad back
            TTcolors = ['rgba(26,26,26,1)', 'rgba(28,28,28,1)', 'rgba(30,30,30,1)', 'rgba(32,32,32,1)'];
            quadBack(this.TTcontext, 2*this.cellWidth, 9.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, TTcolors, 1);
            //upstream quad front
            TTcolors = ['rgba(25,25,25,1)', 'rgba(27,27,27,1)', 'rgba(29,29,29,1)', 'rgba(31,31,31,1)'];
            quadBack(this.TTcontext, 2.5*this.cellWidth, 8.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, TTcolors, 1);
        }

        //3 o'clock upstream DSSD:
        //pads
        if(this.padsEnabled){
            //horizStack(this.context, 7.5*this.cellWidth, 3.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB11FP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //horizStack(this.context, 7.5*this.cellWidth, 4.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB11FN00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            vertStack(this.context, 7.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, colors(['SHB11EP00X'], this.dataBus.SHARC, frame, this.nFrames), 'v', 0);

            //tooltip:
            if(!this.TTlayerDone){
                TTcolors = ['rgba(111,111,111,1)'];
                //horizStack(this.TTcontext, 7.5*this.cellWidth, 3.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                //horizStack(this.TTcontext, 7.5*this.cellWidth, 4.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                vertStack(this.TTcontext, 7.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
            }
        }
        //back
        vertStack(this.context, 6.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, this.meanColor('SHB11DN', frame, 1), 'v', 0);
        //front
        horizStack(this.context, 5.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, this.meanColor('SHB11DP', frame, 1), 'v', 0);
        //tooltip:
        if(!this.TTlayerDone){
            //back
            TTcolors = ['rgba(21,21,21,1)'];
            vertStack(this.TTcontext, 6.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
            //front
            TTcolors = ['rgba(22,22,22,1)'];
            horizStack(this.TTcontext, 5.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
        }

        //12 o'clock upstream DSSD:
        //pads
        if(this.padsEnabled){
            //horizStack(this.context, 3.5*this.cellWidth, 0.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB10FP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //horizStack(this.context, 4.5*this.cellWidth, 0.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB10FN00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            horizStack(this.context, 4*this.cellWidth, 0.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB10EP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //tooltip:
            if(!this.TTlayerDone){
                TTcolors = ['rgba(110,110,110,1)'];
                //horizStack(this.TTcontext, 3.5*this.cellWidth, 0.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                //horizStack(this.TTcontext, 4.5*this.cellWidth, 0.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);                
                horizStack(this.TTcontext, 4*this.cellWidth, 0.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
            }            
        }
        //back
        horizStack(this.context, 4*this.cellWidth, 1.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, this.meanColor('SHB10DN', frame, 1), 'h', 0);
        //front
        vertStack(this.context, 4*this.cellWidth, 2.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, this.meanColor('SHB10DP', frame, 0), 'h', 0);
        //tooltip:
        if(!this.TTlayerDone){
            //back
            TTcolors = ['rgba(19,19,19,1)'];
            horizStack(this.TTcontext, 4*this.cellWidth, 1.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
            //front
            TTcolors = ['rgba(20,20,20,1)'];
            vertStack(this.TTcontext, 4*this.cellWidth, 2.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
        }

        //9 o'clock upstream DSSD:
        //pads
        if(this.padsEnabled){
            //horizStack(this.context, 0.5*this.cellWidth, 3.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB09FP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //horizStack(this.context, 0.5*this.cellWidth, 4.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB09FN00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            vertStack(this.context, 0.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, colors(['SHB09EP00X'], this.dataBus.SHARC, frame, this.nFrames), 'v', 0);
            //tooltip:
            if(!this.TTlayerDone){
                TTcolors = ['rgba(109,109,109,1)'];
                //horizStack(this.TTcontext, 0.5*this.cellWidth, 3.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                //horizStack(this.TTcontext, 0.5*this.cellWidth, 4.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);                
                vertStack(this.TTcontext, 0.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 0);
            } 
        }
        //back
        vertStack(this.context, 1.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, this.meanColor('SHB09DN', frame, 1), 'v', 0);
        //front
        horizStack(this.context, 2.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, this.meanColor('SHB09DP', frame, 0), 'v', 0);
        //tooltip:
        if(!this.TTlayerDone){
            //back
            TTcolors = ['rgba(17,17,17,1)'];
            vertStack(this.TTcontext, 1.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
            //front
            TTcolors = ['rgba(18,18,18,1)'];
            horizStack(this.TTcontext, 2.5*this.cellWidth, 4*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
        }

        //6 o'clock upstream DSSD:
        //pads
        if(this.padsEnabled){
            //horizStack(this.context, 3.5*this.cellWidth, 7.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB12FP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //horizStack(this.context, 4.5*this.cellWidth, 7.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB12FN00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            horizStack(this.context, 4*this.cellWidth, 7.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB12EP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //tooltip:
            if(!this.TTlayerDone){
                TTcolors = ['rgba(112,112,112,1)'];
                //horizStack(this.TTcontext, 3.5*this.cellWidth, 7.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                //horizStack(this.TTcontext, 4.5*this.cellWidth, 7.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);              
                horizStack(this.TTcontext, 4*this.cellWidth, 7.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
            } 
        }
        //back
        horizStack(this.context, 4*this.cellWidth, 6.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, this.meanColor('SHB12DN', frame, 1), 'h', 0);
        //front
        vertStack(this.context, 4*this.cellWidth, 5.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, this.meanColor('SHB12DP', frame, 1), 'h', 0);
        //tooltip:
        if(!this.TTlayerDone){
            //back
            TTcolors = ['rgba(23,23,23,1)'];
            horizStack(this.TTcontext, 4*this.cellWidth, 6.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
            //front
            TTcolors = ['rgba(24,24,24,1)'];
            vertStack(this.TTcontext, 4*this.cellWidth, 5.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
        }

        //DOWNSTREAM//////////////////////////////////
        if(this.padsEnabled){
            //downstream quad pad back
            //quadBack(this.context, 14*this.cellWidth, 0.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, colors(['SHQ01FN00X', 'SHQ02FN00X', 'SHQ03FN00X', 'SHQ04FN00X'], this.dataBus.SHARC, frame, this.nFrames), 0);
            //upstream quad pad front
            quadBack(this.context, 13.5*this.cellWidth, 1.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, colors(['SHQ01EP00X', 'SHQ02EP00X', 'SHQ03EP00X', 'SHQ04EP00X'], this.dataBus.SHARC, frame, this.nFrames), 0);

            //tooltip:
            if(!this.TTlayerDone){
                TTcolors = ['rgba(101,101,101,1)', 'rgba(102,102,102,1)', 'rgba(103,103,103,1)', 'rgba(104,104,104,1)'];
                //downstream quad pad back
                //quadBack(this.TTcontext, 14*this.cellWidth, 0.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, TTcolors, 1);
                //upstream quad pad front
                quadBack(this.TTcontext, 13.5*this.cellWidth, 1.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, TTcolors, 1);
            }

        }

        //downstream quad back
        quadBack(this.context, 13*this.cellWidth, 2.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, this.meanColor('SHQ01DN', frame, 0).concat(this.meanColor('SHQ02DN', frame, 0), this.meanColor('SHQ03DN', frame, 0), this.meanColor('SHQ04DN', frame, 0)), 0);
        //downstream quad front
        quadFront(this.context, 12.5*this.cellWidth, 3.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, this.meanColor('SHQ01DP', frame, 0).concat(this.meanColor('SHQ02DP', frame, 0), this.meanColor('SHQ03DP', frame, 0), this.meanColor('SHQ04DP', frame, 0)), 0);
        //downstream quad tooltip:
        if(!this.TTlayerDone){
            //downstream quad back
            TTcolors = ['rgba(2,2,2,1)', 'rgba(4,4,4,1)', 'rgba(6,6,6,1)', 'rgba(8,8,8,1)'];
            quadBack(this.TTcontext, 13*this.cellWidth, 2.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, TTcolors, 1);
            //downstream quad front
            TTcolors = ['rgba(1,1,1,1)', 'rgba(3,3,3,1)', 'rgba(5,5,5,1)', 'rgba(7,7,7,1)']; 
            quadBack(this.TTcontext, 12.5*this.cellWidth, 3.5*this.cellHeight, this.quadInnerRad, this.quadOuterRad, this.quadSquish, TTcolors, 1);
        }

        //3 o'clock downstream DSSD:
        //pads
        if(this.padsEnabled){
            //horizStack(this.context, 14.5*this.cellWidth, 7.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB07FP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //horizStack(this.context, 14.5*this.cellWidth, 8.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB07FN00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            vertStack(this.context, 14.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, colors(['SHB07EP00X'], this.dataBus.SHARC, frame, this.nFrames), 'v', 0);
            //tooltip:
            if(!this.TTlayerDone){
                TTcolors = ['rgba(107,107,107,1)'];
                //horizStack(this.TTcontext, 14.5*this.cellWidth, 7.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                //horizStack(this.TTcontext, 14.5*this.cellWidth, 8.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);             
                vertStack(this.TTcontext, 14.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
            } 
        }
        //back
        vertStack(this.context, 13.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, this.meanColor('SHB07DN', frame, 1), 'v', 0);
        //front
        horizStack(this.context, 12.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, this.meanColor('SHB07DP', frame, 1), 'v', 0);
        //tooltip:
        if(!this.TTlayerDone){
            //back
            TTcolors = ['rgba(13,13,13,1)'];
            vertStack(this.TTcontext, 13.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
            //front
            TTcolors = ['rgba(14,14,14,1)'];
            horizStack(this.TTcontext, 12.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
        }

        //12 o'clock downstream DSSD:
        //pads
        if(this.padsEnabled){
            //horizStack(this.context, 10.5*this.cellWidth, 4.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB06FP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //horizStack(this.context, 11.5*this.cellWidth, 4.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB06FN00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            horizStack(this.context, 11*this.cellWidth, 4.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB06EP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //tooltip:
            if(!this.TTlayerDone){
                TTcolors = ['rgba(106,106,106,1)'];
                //horizStack(this.TTcontext, 10.5*this.cellWidth, 4.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                //horizStack(this.TTcontext, 11.5*this.cellWidth, 4.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                horizStack(this.TTcontext, 11*this.cellWidth, 4.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);        
            }
        }
        //back
        horizStack(this.context, 11*this.cellWidth, 5.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, this.meanColor('SHB06DN', frame, 1), 'h', 0);
        //front
        vertStack(this.context, 11*this.cellWidth, 6.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, this.meanColor('SHB06DP', frame, 0), 'h', 0);
        //tooltip:
        if(!this.TTlayerDone){
            //back
            TTcolors = ['rgba(11,11,11,1)'];
            horizStack(this.TTcontext, 11*this.cellWidth, 5.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
            //front
            TTcolors = ['rgba(12,12,12,1)'];
            vertStack(this.TTcontext, 11*this.cellWidth, 6.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
        }

        //9 o'clock downstream DSSD:
        //pads
        if(this.padsEnabled){
            //horizStack(this.context, 7.5*this.cellWidth, 7.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB05FP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //horizStack(this.context, 7.5*this.cellWidth, 8.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB05FN00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            vertStack(this.context, 7.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, colors(['SHB05EP00X'], this.dataBus.SHARC, frame, this.nFrames), 'v', 0);
            //tooltip:
            if(!this.TTlayerDone){
                TTcolors = ['rgba(105,105,105,1)'];
                //horizStack(this.TTcontext, 7.5*this.cellWidth, 7.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                //horizStack(this.TTcontext, 7.5*this.cellWidth, 8.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                vertStack(this.TTcontext, 7.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
            }
        }
        //back
        vertStack(this.context, 8.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, this.meanColor('SHB05DN', frame, 1), 'v', 0);
        //front
        horizStack(this.context, 9.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, this.meanColor('SHB05DP', frame, 0), 'v', 0);
        //tooltip:
        if(!this.TTlayerDone){
            //back
            TTcolors = ['rgba(9,9,9,1)'];
            vertStack(this.TTcontext, 8.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
            //front
            TTcolors = ['rgba(10,10,10,1)'];
            horizStack(this.TTcontext, 9.5*this.cellWidth, 8*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*2*this.cellHeight*1.7, TTcolors, 'v', 1);
        }

        //6 o'clock downstream DSSD:
        //pads
        if(this.padsEnabled){
            //horizStack(this.context, 10.5*this.cellWidth, 11.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB08FP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //horizStack(this.context, 11.5*this.cellWidth, 11.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB08FN00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            horizStack(this.context, 11*this.cellWidth, 11.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, colors(['SHB08EP00X'], this.dataBus.SHARC, frame, this.nFrames), 'h', 0);
            //tooltip:
            if(!this.TTlayerDone){
                TTcolors = ['rgba(108,108,108,1)'];
                //horizStack(this.TTcontext, 10.5*this.cellWidth, 11.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
                //horizStack(this.TTcontext, 11.5*this.cellWidth, 11.5*this.cellHeight, this.scaleDown*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);         
                horizStack(this.TTcontext, 11*this.cellWidth, 11.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
            }
        }
        //back
        horizStack(this.context, 11*this.cellWidth, 10.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, this.meanColor('SHB08DN', frame, 1), 'h', 0);
        //front
        vertStack(this.context, 11*this.cellWidth, 9.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, this.meanColor('SHB08DP', frame, 1), 'h', 0);
        //tooltip:
        if(!this.TTlayerDone){
            //back
            TTcolors = ['rgba(15,15,15,1)'];
            horizStack(this.TTcontext, 11*this.cellWidth, 10.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
            //front
            TTcolors = ['rgba(16,16,16,1)'];
            vertStack(this.TTcontext, 11*this.cellWidth, 9.5*this.cellHeight, this.scaleDown*2*this.cellWidth, this.scaleDown*this.cellHeight, TTcolors, 'h', 1);
        }

        if(frame==this.nFrames || frame==0){ 
            //scale:
            this.drawScale(this.context);

            //orienting arrows:
            this.context.lineWidth = 2;
            //upstream
            this.context.beginPath();
            this.context.moveTo(2.5*this.cellWidth, 11.5*this.cellHeight);
            this.context.lineTo(4*this.cellWidth, 8.5*this.cellHeight);
            this.context.lineTo(4.2*this.cellWidth, 8.7*this.cellHeight);
            this.context.stroke();
            //downstream
            this.context.beginPath();
            this.context.moveTo(11*this.cellWidth, 3.5*this.cellHeight);
            this.context.lineTo(12.5*this.cellWidth, 0.5*this.cellHeight);
            this.context.lineTo(12.1*this.cellWidth, 0.7*this.cellHeight);
            this.context.stroke();

            this.context.lineWidth = 1;

            //titles:
            this.context.fillStyle = '#999999';
            this.context.font = '20px Orbitron';
            this.context.textBaseline = 'top';
            this.context.fillText('Upstream', this.cellWidth*4 - this.context.measureText('Upstream').width/2, this.canvasHeight - this.scaleHeight*0.95);
            this.context.fillText('Downstream', this.cellWidth*11 - this.context.measureText('Downstream').width/2, this.canvasHeight - this.scaleHeight*0.95);
            this.context.textBaseline = 'alphabetic';
        }

        this.TTlayerDone = 1;
    };

    this.drawDetail = function(x, frame){  //animatedetail expects the first argument to be the detail context - refactor to eliminate.
        var colors = [], TTcolors = [],
            i, name,
            arrayElt = Math.ceil(this.detailShowing/2);

        this.detailContext.clearRect(0,0, this.canvasWidth, this.canvasHeight-this.scaleHeight);
        if(!this.TTdetailLayerDone){
            this.TTdetailContext.fillStyle = '#FEDCBA'
            this.TTdetailContext.fillRect(0,0, this.canvasWidth, this.canvasHeight);
        }
        //title
        this.detailContext.fillStyle = '#999999';
        this.detailContext.font = '20px Orbitron';
        this.detailContext.fillText(this.detailTitles[arrayElt-1], this.canvasWidth/2 - this.detailContext.measureText(this.detailTitles[arrayElt-1]).width/2, this.canvasHeight*0.75 );

        //quadrant details
        if(arrayElt < 5 || arrayElt > 12){

            //subtitles:
            this.detailContext.fillText('Front', this.quadDetailFrontCenter - this.detailContext.measureText('Front').width/2, this.canvasHeight*0.67);
            this.detailContext.fillText('Back', this.quadDetailBackCenter - this.detailContext.measureText('Back').width/2, this.canvasHeight*0.67);
            if(this.padsEnabled) this.detailContext.fillText('Pads', this.canvasWidth*0.9 - this.detailContext.measureText('Pads').width/2, this.canvasHeight*0.67);

            //front side:
            colors = [];
            TTcolors = [];
            for(i=0; i<16; i++){
                name = 'SHQ' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'DP' + ( (i<10) ? '0'+i : i ) + 'X';
                colors[colors.length] = frameColor(this.dataBus.SHARC[name], frame, this.nFrames);
                TTcolors[TTcolors.length] = 'rgba('+i+','+i+','+i+',1)';
            }
            radialQuadrant(this.detailContext, this.quadDetailFrontCenter, this.canvasHeight*0.7, this.innerQuadRadDetail, this.outerQuadRadDetail, this.quadArcDetail, -Math.PI/2, colors);
            if(!this.TTdetailLayerDone)
                radialQuadrant(this.TTdetailContext, this.quadDetailFrontCenter, this.canvasHeight*0.7, this.innerQuadRadDetail, this.outerQuadRadDetail, this.quadArcDetail, -Math.PI/2, TTcolors, 1);

            //back side:
            colors = [];
            TTcolors = [];
            for(i=0; i<24; i++){
                name = 'SHQ' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'DN' + ( (i<10) ? '0'+i : i ) + 'X';
                colors[colors.length] = frameColor(this.dataBus.SHARC[name], frame, this.nFrames);
                TTcolors[TTcolors.length] = 'rgba('+(i+16)+','+(i+16)+','+(i+16)+',1)';
            }
            azimuthalQuadrant(this.detailContext, this.quadDetailBackCenter, this.canvasHeight*0.7, this.innerQuadRadDetail, this.outerQuadRadDetail, this.quadArcDetail, -Math.PI/2, colors);
            if(!this.TTdetailLayerDone)
                azimuthalQuadrant(this.TTdetailContext, this.quadDetailBackCenter, this.canvasHeight*0.7, this.innerQuadRadDetail, this.outerQuadRadDetail, this.quadArcDetail, -Math.PI/2, TTcolors, 1);

            //pads
            colors = [];
            TTcolors = [];
            if(this.padsEnabled){
                name = 'SHQ' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'EN00X';
                colors[0] = frameColor(this.dataBus.SHARC[name], frame, this.nFrames);
                TTcolors[0] = 'rgba(40,40,40,1)';
                radialQuadrant(this.detailContext, this.canvasWidth*0.9, this.canvasHeight*0.4, this.innerQuadRadDetail/2, this.innerQuadRadDetail*2, this.quadArcDetail, -Math.PI/2, colors);
                if(!this.TTdetailLayerDone)
                    radialQuadrant(this.TTdetailContext, this.canvasWidth*0.9, this.canvasHeight*0.4, this.innerQuadRadDetail/2, this.innerQuadRadDetail*2, this.quadArcDetail, -Math.PI/2, TTcolors, 1);
                name = 'SHQ' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'EP00X';
                colors[0] = frameColor(this.dataBus.SHARC[name], frame, this.nFrames);
                TTcolors[0] = 'rgba(41,41,41,1)';
                radialQuadrant(this.detailContext, this.canvasWidth*0.9, this.canvasHeight*0.6, this.innerQuadRadDetail/2, this.innerQuadRadDetail*2, this.quadArcDetail, -Math.PI/2, colors);
                if(!this.TTdetailLayerDone)
                    radialQuadrant(this.TTdetailContext, this.canvasWidth*0.9, this.canvasHeight*0.6, this.innerQuadRadDetail/2, this.innerQuadRadDetail*2, this.quadArcDetail, -Math.PI/2, TTcolors, 1);
            }

        } else{  //box details

            //subtitles:
            this.detailContext.fillText('Front', this.canvasWidth*0.19+this.boxDetailFrontLeftEdge - this.detailContext.measureText('Front').width/2, this.canvasHeight*0.7);
            this.detailContext.fillText('Back', this.canvasWidth*0.19+this.boxDetailBackLeftEdge - this.detailContext.measureText('Back').width/2, this.canvasHeight*0.7);
            if(this.padsEnabled) this.detailContext.fillText('Pads', this.canvasWidth*0.9 - this.detailContext.measureText('Pads').width/2, this.canvasHeight*0.7);

            //front side:
            colors = [];
            TTcolors = [];
            for(i=0; i<24; i++){
                name = 'SHB' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'DP' + ( (i<10) ? '0'+i : i ) + 'X';
                colors[colors.length] = frameColor(this.dataBus.SHARC[name], frame, this.nFrames);
                TTcolors[TTcolors.length] = 'rgba('+i+','+i+','+i+',1)';
            }
            boxFront(this.detailContext, this.boxDetailFrontLeftEdge,0.05*this.canvasHeight, 0.60*this.canvasHeight, 0.38*this.canvasWidth, colors);
            if(!this.TTdetailLayerDone)
                boxFront(this.TTdetailContext, this.boxDetailFrontLeftEdge,0.05*this.canvasHeight, 0.60*this.canvasHeight, 0.38*this.canvasWidth, TTcolors, 1);

            //back side:
            colors = [];
            TTcolors = [];
            for(i=0; i<48; i++){
                name = 'SHB' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'DN' + ( (i<10) ? '0'+i : i ) + 'X';
                colors[colors.length] = frameColor(this.dataBus.SHARC[name], frame, this.nFrames);
                TTcolors[TTcolors.length] = 'rgba('+(i+24)+','+(i+24)+','+(i+24)+',1)';
            }
            boxBack(this.detailContext, this.boxDetailBackLeftEdge, 0.05*this.canvasHeight, 0.60*this.canvasHeight, 0.38*this.canvasWidth, colors);
            if(!this.TTdetailLayerDone)
                boxBack(this.TTdetailContext, this.boxDetailBackLeftEdge, 0.05*this.canvasHeight, 0.60*this.canvasHeight, 0.38*this.canvasWidth, TTcolors, 1);

            //pads
            colors = [];
            TTcolors = [];
            if(this.padsEnabled){
                name = 'SHB' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'EN00X';
                colors[0] = frameColor(this.dataBus.SHARC[name], frame, this.nFrames);
                TTcolors[0] = 'rgba(72,72,72,1)';
                boxFront(this.detailContext, this.canvasWidth*0.85, this.canvasHeight*0.175, 0.15*this.canvasHeight, 0.1*this.canvasWidth, colors);
                if(!this.TTdetailLayerDone)
                    boxFront(this.TTdetailContext, this.canvasWidth*0.85, this.canvasHeight*0.175, 0.15*this.canvasHeight, 0.1*this.canvasWidth, TTcolors, 1);
                name = 'SHB' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'EP00X';
                colors[0] = frameColor(this.dataBus.SHARC[name], frame, this.nFrames);
                TTcolors[0] = 'rgba(73,73,73,1)';
                boxFront(this.detailContext, this.canvasWidth*0.85, this.canvasHeight*0.375, 0.15*this.canvasHeight, 0.1*this.canvasWidth, colors);
                if(!this.TTdetailLayerDone)
                    boxFront(this.TTdetailContext, this.canvasWidth*0.85, this.canvasHeight*0.375, 0.15*this.canvasHeight, 0.1*this.canvasWidth, TTcolors, 1);
            }            
        }

        this.TTdetailLayerDone = 1;

        //decorations & TT:
        if(frame==this.nFrames || frame==0){ 
            //scale:
            this.drawScale(this.detailContext);
        }
    }

    this.defineText = function(cell){
        var i, name,
            objects = [], 
            keys = ['HV', 'threshold', 'rate'],
            arrayElt;

        if(this.detailShowing == 0){

            //strip elements:
            if(cell < 100){
                arrayElt = Math.ceil(cell/2);
                //quadrants
                if(arrayElt < 5 || arrayElt > 12){
                    //fronts
                    if(cell%2){
                        for(i=0; i<16; i++){
                            objects[objects.length] = 'SHQ' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'DP' + ( (i<10) ? '0'+i : i ) + 'X';
                        }
                    } else { //backs
                        for(i=0; i<24; i++){
                            objects[objects.length] = 'SHQ' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'DN' + ( (i<10) ? '0'+i : i ) + 'X';
                        }
                    }            
                } else{ //boxes
                    //fronts
                    if(cell%2 == 0){
                        for(i=0; i<24; i++){
                            objects[objects.length] = 'SHB' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'DP' + ( (i<10) ? '0'+i : i ) + 'X';
                        }
                    } else { //backs
                        //backs
                        for(i=0; i<48; i++){
                            objects[objects.length] = 'SHB' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'DN' + ( (i<10) ? '0'+i : i ) + 'X';
                        } 
                    }

                }
                document.getElementById(this.name+'TT').innerHTML = '';
                window.state.staticTT = 1;
                TTtable(this.name+'TT', this.dataBus.SHARC , objects, keys, objects[0].slice(0,5) + ( (objects[0].slice(5,7) == 'DP') ? ' (front)' : ' (back)' ), ['Device','HV [V]', 'Threhsold [ADC Units]', 'Rate [Hz]'], [Math.ceil(objects.length/2),Math.floor(objects.length/2)] );
            } else {  //pads:
                arrayElt = cell - 100;
                //quadrants
                if(arrayElt < 5 || arrayElt > 12){
                    objects[0] = 'SHQ' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'EP00X';
                    //objects[1] = 'SHQ' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'FN00X';
                } else { //boxes
                    objects[0] = 'SHB' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'EP00X';
                    //objects[1] = 'SHB' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'FN00X';
                }
                document.getElementById(this.name+'TT').innerHTML = '';
                TTtable(this.name+'TT', this.dataBus.SHARC ,objects, keys, objects[0].slice(0,5) + ' pads', ['Device','HV [V]', 'Threhsold [ADC Units]', 'Rate [Hz]'], [objects.length]);
            }
        } else {
            arrayElt = Math.ceil(this.detailShowing/2);
            if(arrayElt < 5 || arrayElt > 12){
                if(cell < 40)
                    name = 'SHQ' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + ( (cell < 16) ? ('DP' + ((cell<10)?'0'+cell:cell) ) : ('DN' + ((cell-16<10)?'0'+(cell-16):(cell-16))) ) + 'X';
                else 
                    name = 'SHQ' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'E' + ( (cell==40) ? 'N' : 'P' ) + '00X';
            } else {
                if(cell < 72)
                    name = 'SHB' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + ( (cell < 24) ? ('DP' + ((cell<10)?'0'+cell:cell) ) : ('DN' + ((cell-24<10)?'0'+(cell-24):(cell-24))) ) + 'X';
                else
                    name = 'SHB' + ( (arrayElt < 10) ? '0'+arrayElt : arrayElt ) + 'E' + ( (cell==72) ? 'N' : 'P' ) + '00X';
            }
            
            document.getElementById(this.detailTooltip.ttDivID).innerHTML = name + '<br><br>' + this.baseTTtext(this.dataBus.SHARC[name].HV, this.dataBus.SHARC[name].threshold, this.dataBus.SHARC[name].rate);

        }

    };

    //get new data
    this.fetchNewData = function(){
        
        var key, normalization, quarter;

        //zero out the summary:
        for(key in this.dataBus.summary){
            if(this.dataBus.summary.hasOwnProperty(key)){
                this.dataBus.summary[key].HV = 0;
                this.dataBus.summary[key].threshold = 0;
                this.dataBus.summary[key].rate = 0;
            }
        }

        //fetch data, plug into detail level and increment summary cells:
        for(key in this.dataBus.SHARC){
            if(window.JSONPstore['thresholds']){
                quarter = Math.floor(parseInt(key.slice(7,9)) / this.sizeOfQuarter(key));
                if(window.JSONPstore['thresholds'][key]){
                    this.dataBus.SHARC[key]['threshold'] = window.JSONPstore['thresholds'][key];
                    if(key.slice(5,6) != 'E'){ //treat pads differently since they don't need to be averaged:
                        if(this.dataBus.summary[key.slice(0,7) + quarter].threshold != 0xDEADBEEF) 
                            this.dataBus.summary[key.slice(0,7) + quarter].threshold += window.JSONPstore['thresholds'][key];
                    } else 
                        this.dataBus.summary[key].threshold = window.JSONPstore['thresholds'][key];
                } else{
                    this.dataBus.SHARC[key]['threshold'] = 0xDEADBEEF;
                    if(key.slice(5,6) != 'E')
                        this.dataBus.summary[key.slice(0,7) + quarter].threshold = 0xDEADBEEF;
                    else
                       this.dataBus.summary[key].threshold = 0xDEADBEEF; 
                }
            } 

            if(window.JSONPstore['scalar']){
                quarter = Math.floor(parseInt(key.slice(7,9)) / this.sizeOfQuarter(key));
                if(window.JSONPstore['scalar'][key]){
                    this.dataBus.SHARC[key]['rate'] = window.JSONPstore['scalar'][key]['TRIGREQ'];
                    if(key.slice(5,6) != 'E'){ //treat pads differently since they don't need to be averaged:
                        if(this.dataBus.summary[key.slice(0,7) + quarter].rate != 0xDEADBEEF) 
                            this.dataBus.summary[key.slice(0,7) + quarter].rate += window.JSONPstore['scalar'][key]['TRIGREQ'];
                    } else 
                        this.dataBus.summary[key].rate = window.JSONPstore['scalar'][key]['TRIGREQ'];
                } else{ 
                    this.dataBus.SHARC[key]['rate'] = 0xDEADBEEF;
                    if(key.slice(5,6) != 'E')
                        this.dataBus.summary[key.slice(0,7) + quarter].rate = 0xDEADBEEF;
                    else
                        this.dataBus.summary[key].rate = 0xDEADBEEF;
                }
            }
        }

        //average the summary level cells:
        for(key in this.dataBus.summary){
            if(this.dataBus.summary.hasOwnProperty(key) && key.slice(5,6)!='E' ){
                if(this.dataBus.summary[key].HV != 0xDEADBEEF) this.dataBus.summary[key].HV /= this.sizeOfQuarter(key);
                if(this.dataBus.summary[key].threshold != 0xDEADBEEF) this.dataBus.summary[key].threshold /= this.sizeOfQuarter(key);
                if(this.dataBus.summary[key].rate != 0xDEADBEEF) this.dataBus.summary[key].rate /= this.sizeOfQuarter(key);
            }
        }
        

    };

    //given a SHARC key, return 1/4 the number of segments in that type of detector
    this.sizeOfQuarter = function(key){

        if(key.slice(0,3) == 'SHB'){
            if(key.slice(5,7) == 'DP')
                return 6;
            else if(key.slice(5,7) == 'DN')
                return 12;
        } else if(key.slice(0,3) == 'SHQ'){
            if(key.slice(5,7) == 'DP')
                return 4;
            else if(key.slice(5,7) == 'DN')
                return 6;
        }        
    };

    //determine the color corresponding to the average value across a quarter of an element prefixed by prefix (7 characters ie SHB09DP) for the summary view.
    //colors packed in order [1st quarter, 2nd, 3rd, 4th], unless reversed flag is set, then returns [4th, 3rd, 2nd, 1st].
    this.meanColor = function(prefix, frame, reversed){
        var i,
            colors=[];

        for(i=0; i<4; i++){
            if(window.state.subdetectorView == 0) colors[i] = interpolateColor(parseHexColor(this.dataBus.summary[prefix+i].oldHVcolor), parseHexColor(this.dataBus.summary[prefix+i].HVcolor), frame/this.nFrames);
            else if(window.state.subdetectorView == 1) colors[i] = interpolateColor(parseHexColor(this.dataBus.summary[prefix+i].oldThresholdColor), parseHexColor(this.dataBus.summary[prefix+i].thresholdColor), frame/this.nFrames);
            else if(window.state.subdetectorView == 2) colors[i] = interpolateColor(parseHexColor(this.dataBus.summary[prefix+i].oldRateColor), parseHexColor(this.dataBus.summary[prefix+i].rateColor), frame/this.nFrames);
        }

        if(reversed)
            colors = colors.reverse();

        return colors;
    };

}


SPICE.prototype = Object.create(Subsystem.prototype);

function SPICE(){
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'SPICE';
    var that = this;
    Subsystem.call(this);
    this.dataBus = new SPICEDS();
    //SPICE can be deployed with an S2 or S3 downstream in the chamber;
    //these are identical to BAMBINO, so we deploy BAMBINO in 'SPICE mode':
    if(ODB.SPICE.SPICEauxiliary == 'S2' || ODB.SPICE.SPICEauxiliary == 'S3'){
        //window.parameters.deployment.BAMBINO = 1;
        ODB.BAMBINO.USdeploy = 0;
        ODB.BAMBINO.DSdeploy = 1;
        ODBSet('/DashboardConfig/BAMBINO/USdeploy', 0);
        ODBSet('/DashboardConfig/BAMBINO/DSdeploy', 1);
    }
    //make a pointer at window level back to this object, so we can pass by reference to the nav button onclick
    window.SPICEpointer = that;

    //member variables///////////////////////////////////
	this.nRadial = 10;
	this.nAzimuthal = 12;
    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['SPICE'];

    //drawing parameters///////////////////////////////////////
    this.centerX = this.canvasWidth/2;
    this.centerY = this.canvasHeight*0.42;
    this.innerRadius = this.canvasHeight*0.02;
    this.outerRadius = this.canvasHeight*0.36;
    this.azimuthalStep = 2*Math.PI / this.nAzimuthal;
    this.radialStep = (this.outerRadius - this.innerRadius) / this.nRadial;

    //member functions///////////////////////////////////////////////////////////////////


    this.draw = function(frame){
    	var i=0, key, ring, sector, fill;

    	this.context.strokeStyle = '#999999';
    	
        //once for display canvas...
    	for(key in this.dataBus.SPICE){
    		sector = i%12;
    		ring = 9 - Math.floor(i/12);

            fill = colors(key, this.dataBus.SPICE, frame, this.nFrames);
            this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;

		    this.context.beginPath();
		    this.context.arc(this.centerX, this.centerY, this.innerRadius + ring*this.radialStep, -sector*this.azimuthalStep, -(sector+1)*this.azimuthalStep, true);
    		this.context.lineTo(this.centerX + (this.innerRadius + (ring+1)*this.radialStep)*Math.cos(2*Math.PI - (sector+1)*this.azimuthalStep), this.centerY + (this.innerRadius + (ring+1)*this.radialStep)*Math.sin(2*Math.PI - (sector+1)*this.azimuthalStep));
	    	this.context.arc(this.centerX, this.centerY, this.innerRadius + (ring+1)*this.radialStep, - (sector+1)*this.azimuthalStep, - sector*this.azimuthalStep, false);
    		this.context.closePath();
    		this.context.fill();
    		this.context.stroke();

            i++;
    	}
        //...and again for tt encoding:
        if(!this.TTlayerDone){
        i=0;
            for(key in this.dataBus.SPICE){
                sector = i%12;
                ring = 9 - Math.floor(i/12);

                this.TTcontext.fillStyle = 'rgba('+this.dataBus.SPICE[key].index+','+this.dataBus.SPICE[key].index+','+this.dataBus.SPICE[key].index+',1)';
                this.TTcontext.beginPath();
                this.TTcontext.arc(this.centerX, this.centerY, this.innerRadius + ring*this.radialStep, -sector*this.azimuthalStep, -(sector+1)*this.azimuthalStep, true);
                this.TTcontext.lineTo(this.centerX + (this.innerRadius + (ring+1)*this.radialStep)*Math.cos(2*Math.PI - (sector+1)*this.azimuthalStep), this.centerY + (this.innerRadius + (ring+1)*this.radialStep)*Math.sin(2*Math.PI - (sector+1)*this.azimuthalStep));
                this.TTcontext.arc(this.centerX, this.centerY, this.innerRadius + (ring+1)*this.radialStep, - (sector+1)*this.azimuthalStep, - sector*this.azimuthalStep, false);
                this.TTcontext.closePath();
                this.TTcontext.fill();
                //suppress antialiasing problems between cells:
                this.TTcontext.strokeStyle = '#123456';
                this.TTcontext.stroke();

                i++;
            }
            this.TTlayerDone = 1;
        }

        //scale
        if(frame==this.nFrames || frame==0) this.drawScale(this.context);
    };

    
    //do an initial populate:
    //this.update();
}function StatusBar(wrapper){
	this.wrapperID = wrapper;
	this.titleID = 'experimentTitle';
	this.runInfoID = 'runInfo';

	var that = this;

    //header info
    injectDOM('div', 'statusHeader', this.wrapperID, {});

    //deploy tooltip:
    //this.tooltip = new Tooltip('LeftSidebarBKG', 'leftSidebarTT', this.wrapperID, [], []);
    //this.tooltip.obj = that;

    //tooltip actually attaches to a canvas - attach it to the background canvas, but then pull the event listners up to the top-level div:
    //document.getElementById('statusHeader').onmousemove = document.getElementById('LeftSidebarBKG').onmousemove
    //document.getElementById('statusHeader').onmouseout = document.getElementById('LeftSidebarBKG').onmouseout
    //document.getElementById('statusHeader').onmouseover = document.getElementById('LeftSidebarBKG').onmouseover
    //tooltip will also look for members canvasWidth and canvasHeight:
    //this.canvasWidth = document.getElementById('LeftSidebarBKG').width
    //this.canvasHeight = document.getElementById('LeftSidebarBKG').height

    //experiment title
    injectDOM('h2', this.titleID, 'statusHeader', {'style':'margin-top:25px; font-family: "Orbitron", sans-serif;'});

    //run info
    injectDOM('p', this.runInfoID, 'statusHeader', {'innerHTML' : 'Run Info Unavailable in pre-2011 MIDAS'});

    //run control buttons
    injectDOM('form', 'runControl', 'statusHeader', {});
    injectDOM('input', 'startButton', 'runControl', {'class':'navLink', 'name':'cmd', 'type':'submit', 'value':'Start'});
    injectDOM('input', 'stopButton', 'runControl', {'class':'navLink', 'name':'cmd', 'type':'submit', 'value':'Stop'});
    injectDOM('input', 'pauseButton', 'runControl', {'class':'navLink', 'name':'cmd', 'type':'submit', 'value':'Pause'});
    injectDOM('input', 'resumeButton', 'runControl', {'class':'navLink', 'name':'cmd', 'type':'submit', 'value':'Resume'});
    injectDOM('input', 'redirKludge', 'runControl', {'name':'redir', 'type':'hidden', 'value':'http://'+ODB.topLevel.statusURL+'/CS/Dashboard'});

    //Alarm Service
    window.AlarmServices = new AlarmService('leftSidebar', 'leftSidebarDetail');

    //JSONP monitor
    injectDOM('p', 'JSONPmonitor', this.wrapperID, {'style':'width:80%; margin-left:auto; margin-right:auto; padding-left:5%; padding-right:5%; margin-top:5%;'});

    //message service
    //insertDOM('table', 'messageTable', '', 'padding:10px; font-family:10px Raleway;', this.wrapperID, '', '');
    /*  //message input diabled until further notice///////////////////////////////////
    insertDOM('tr', 'inputRow', '', '', 'messageTable', '', '');
    insertDOM('td', 'inputCell', 'messageServiceCell', 'background:#333333;', 'inputRow', '');
    document.getElementById('inputCell').innerHTML = ''
    //insertDOM('input', 'inputMessage', '', '', 'inputCell', '', '', '', 'text', '');
    insertDOM('textarea', 'inputMessage', '', 'background:#333333; color:#FFFFFF', 'inputCell', '', '', '', '', '');
    document.getElementById('inputMessage').rows = 3;
    document.getElementById('inputMessage').cols = 30;
    //expand the text box to fill the sidebar on larger monitors:
    while(document.getElementById('messageTable').offsetWidth + 10 < document.getElementById(this.wrapperID).offsetWidth)
        document.getElementById('inputMessage').cols++;
    document.getElementById('inputMessage').value = 'Enter log message here; press return to commit.';
    document.getElementById('inputMessage').onclick = function(){
        this.value = '';
    }
    document.getElementById('inputMessage').onkeypress = function(event){
        if(event.keyCode == 13 && this.value!=''){
            ODBGenerateMsg(this.value);
            forceUpdate();
            this.value = 'Enter log message here; press return to commit.';
        }
    }
    */ //end message input///////////////////////////////////////////////////////////////
    injectDOM('div', 'message0', this.wrapperID, {'class':'messageServiceCell'});
    injectDOM('div', 'message1', this.wrapperID, {'class':'messageServiceCell'});
    injectDOM('div', 'message2', this.wrapperID, {'class':'messageServiceCell'});
    injectDOM('div', 'message3', this.wrapperID, {'class':'messageServiceCell'});
    injectDOM('div', 'message4', this.wrapperID, {'class':'messageServiceCell', 'style':'margin-bottom:20px;'});

    this.update = function(){
        var i;
    	//experiment title 
        this.expTitle = window.localODB.expTitle + ' Experiment';
    	document.getElementById(this.titleID).innerHTML = this.expTitle;

	    //run # 
        this.runInfo = 'Run # '+window.localODB.runInfo;

    	//run state
    	this.runInfo += ': ';
        this.runstate = window.localODB.runstate;
    	if(this.runstate == 1){ 
            this.runInfo += 'Stopped';
            $('#statusHeader').css('border-color', '#FF3333');
            document.getElementById('startButton').style.display = 'inline';
            document.getElementById('stopButton').style.display = 'none';
            document.getElementById('pauseButton').style.display = 'none';
            document.getElementById('resumeButton').style.display = 'none';
        }
    	else if(this.runstate == 2){
            this.runInfo += 'Paused';
            $('#statusHeader').css('border-color', '#FFFF33');
            document.getElementById('startButton').style.display = 'none';
            document.getElementById('stopButton').style.display = 'none';
            document.getElementById('pauseButton').style.display = 'none';
            document.getElementById('resumeButton').style.display = 'inline';   
        }
    	else if (this.runstate == 3){
            this.runInfo += 'Live';
            $('#statusHeader').css('border-color', '#66FF66');
            document.getElementById('startButton').style.display = 'none';
            document.getElementById('stopButton').style.display = 'inline';
            document.getElementById('pauseButton').style.display = 'inline';
            document.getElementById('resumeButton').style.display = 'none';
        }
    	else this.runInfo += 'State Unknown';
    
	    //run time
    	this.startInfo = 'Start: '+window.localODB.startInfo;
    	this.elapsed;
    	if(this.runstate == 1){
	   	    this.elapsed = 'Stop: '+window.localODB.elapsed;
	    } else {
            this.elapsed = 'Up: ';
            this.binaryStart = window.localODB.binaryStart;
            var date = new Date(); 
            var now = date.getTime() / 1000;
            var uptime = now - this.binaryStart;
            var hours = Math.floor(uptime / 3600);
            var minutes = Math.floor( (uptime%3600)/60 );
            var seconds = Math.floor(uptime%60);
            this.elapsed += hours + ' h, ' + minutes + ' m, ' + seconds +' s'
		}

        //run comment
        if(window.localODB.comment)
            this.comment = window.localODB.comment;
        else
            this.comment = '';

        document.getElementById(this.runInfoID).innerHTML = '<br>' + this.runInfo + '<br>' + this.startInfo + '<br>' + this.elapsed + '<br><br>' + this.comment + '<br><br>';
        

        //JSONP monitor:
        var JSONPtext = 'JSONP Services<br>';
        JSONPtext += 'Thresholds: ';
        JSONPtext += window.JSONPstatus[0]+'<br>';
        JSONPtext += 'Rates: ';
        JSONPtext += window.JSONPstatus[1]+'<br>';
        document.getElementById('JSONPmonitor').innerHTML = JSONPtext;
        
        //message service
        //var messages = ODBGetMsg(5);
        for(i=0; i<5; i++){
            document.getElementById('message'+i).innerHTML = window.localODB.messages[4-i]; //most recent on top
        }
        
        //pull in status table from traditional status page, and put it in the TT: - disabled until id's available in MIDAS
        /*
        $.get(ODB.topLevel.statusURL, function(response){
            var i, headStart, headEnd = '', rowNode;

            //remove the <head> before html is parsed: (todo: oneline this with regex and replace?)
            i=0;
            while(headEnd==''){
                if(response[i] == '<' && response[i+1] == 'h' && response[i+2] == 'e' && response[i+3] == 'a' && response[i+4] == 'd' && response[i+5] == '>' )
                    headStart = i;
                else if (response[i] == '<' && response[i+1] == '/' && response[i+2] == 'h' && response[i+3] == 'e' && response[i+4] == 'a' && response[i+5] == 'd' && response[i+6] == '>' )
                    headEnd = i+7;
                i++;
            }
            response = response.slice(0, headStart) + response.slice(headEnd, response.length);

            //change some colors - tags don't have IDs so easiest to do this as text:
            response = response.replace(/#E0E0FF/g, '#333333');

            //replace some font colors to make them legible against their backgrounds
            response = response.replace(/bgcolor="#00FF00"/g, 'bgcolor="#00FF00" style="color:#000000;"'); //green backgrounds
            response = response.replace(/bgcolor="00FF00"/g, 'bgcolor="#00FF00" style="color:#000000;"'); //green backgrounds, sometimes MIDAS leaves off the hash...
            response = response.replace(/bgcolor=#00FF00/g, 'bgcolor="#00FF00" style="color:#000000;"'); //green backgrounds, sometimes MIDAS leaves off the quotes...
            response = response.replace(/bgcolor="#FFFF00"/g, 'bgcolor="#FFFF00" style="color:#000000;"'); //yellow backgrounds
            response = response.replace(/bgcolor="FFFF00"/g, 'bgcolor="#FFFF00" style="color:#000000;"'); //yellow backgrounds, sometimes MIDAS leaves off the hash...
            response = response.replace(/bgcolor=#FFFF00/g, 'bgcolor="#FFFF00" style="color:#000000;"'); //yellow backgrounds, sometimes MIDAS leaves off the quotes...

            //stick the result in the TT - html parsing happens now:
            document.getElementById('leftSidebarTT').innerHTML = response;
            
            //now strip out unwanted table elements, easiest to do after html parsing:
            var rowTags = getTag('tr', 'leftSidebarTT');
            if(rowTags){
                for(i=0; i<4; i++){
                    rowTags[0].id = 'rowNodeID';
                    rowNode = document.getElementById('rowNodeID');
                    rowNode.parentNode.removeChild(rowNode);                    
                }
            }

            $('#leftSidebarTT').css('padding', 0);
            
        });
        */
        
    };

    this.findCell = function(event){
        return 1;
    };

    this.defineText = function(cell){        
        return 0;
    };

    this.update();

}//the subsystem object from which all subsystems will inherit.
function Subsystem(){
	var that = this;

	//names of things
	this.monitorID = window.parameters.wrapper;		//div ID of wrapper div
	this.linkWrapperID = 'SubsystemLinks';	        //ID of div wrapping subsystem navigation links
	this.sidebarID = 'SubsystemSidebar';			//ID of right sidebar for this object
	this.topNavID = 'SubsystemsButton';				//ID of top level nav button
	this.canvasID = this.name+'Canvas';		        //ID of canvas to draw main view on; this.name defined downstream in prototype chain
    this.subviewLink = this.name+'link';            //ID of inter-subsystem nav button
    this.TTcanvasID = this.name+'TTCanvas';         //ID of hidden tooltip map canvas for main view

    //other member data
    this.prefix = window.parameters[this.name].prefix;
    this.postfix = window.parameters[this.name].postfix;
    this.TTlayerDone = 0;                           //set to 1 when TT layer painted, don't paint again.

    //animation parameters
    this.FPS = 30;
    this.duration = 0.5;
    this.nFrames = this.FPS*this.duration;
    
    //DOM insertions
    //insert nav link
    injectDOM('button', this.name+'link', this.linkWrapperID, {
        'class' : 'navLink',
        'onclick' : function(){
            swapFade(this.id, this.parentPointer, window.subsystemScalars); 
            rePaint();
        },
        'innerHTML' : this.name,
        'type' : 'button'
    });
    document.getElementById(this.name+'link').parentPointer = this;
    //scale canvas
	this.monitor = document.getElementById(this.monitorID);
    this.canvasWidth = 0.48*$(this.monitor).width();
    this.canvasHeight = 0.8*$(this.monitor).height();
    //detector view
    injectDOM('canvas', this.canvasID, this.monitorID, {
        'class':'monitor', 
        'style':'top:' + ($('#'+this.linkWrapperID).offset().top + $('#'+this.linkWrapperID).height()*1.25 + 5) +'px;'
    });
    this.canvas = document.getElementById(this.canvasID);
    this.context = this.canvas.getContext('2d');
    this.canvas.setAttribute('width', this.canvasWidth);
    this.canvas.setAttribute('height', this.canvasHeight);
    //hidden Tooltip map layer
    injectDOM('canvas', this.TTcanvasID, this.monitorID, {
        'class' : 'monitor',
        'style' : 'top:' + ($('#'+this.linkWrapperID).offset().top + $('#'+this.linkWrapperID).height()*1.25 + 5) +'px;'
    });
    this.TTcanvas = document.getElementById(this.TTcanvasID);
    this.TTcontext = this.TTcanvas.getContext('2d');
    this.TTcanvas.setAttribute('width', this.canvasWidth);
    this.TTcanvas.setAttribute('height', this.canvasHeight);

    //Dirty trick to implement tooltip on arbitrary geometry: make another canvas of the same size hidden beneath, with the 
    //detector drawn on it, but with each element filled in with rgba(0,0,n,1), where n is the channel number; fetching the color from the 
    //hidden canvas at point x,y will then return the appropriate channel index.
    //paint whole hidden canvas with R!=G!=B to trigger TT suppression:
    this.TTcontext.fillStyle = '#123456';
    this.TTcontext.fillRect(0,0,this.canvasWidth, this.canvasHeight);

    //set up tooltip:
    this.tooltip = new Tooltip(this.canvasID, this.name+'TT', this.monitorID, this.prefix, this.postfix);
    this.tooltip.obj = that;

    //what fraction of the canvas does the scale take up?  need this for onclick behavior:
    this.scaleHeight = this.canvasHeight*0.2;
    //set up scale adjust dialog:
    this.canvas.onclick = function(event){
        var y = event.pageY - that.canvas.offsetTop - that.monitor.offsetTop;
        if(y > that.canvasHeight - that.scaleHeight)
            parameterDialogue(that.name, [[that.name, ODB[that.name][that.constructMinMaxKey(that.name)][0], ODB[that.name][that.constructMinMaxKey(that.name)][1], window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/'+that.name+'/'+scaleType()+'[0]', '/DashboardConfig/'+that.name+'/'+scaleType()+'[1]']], window.parameters.subdetectorColors[window.state.subdetectorView]);
        else{
            if(that.pointingNow)
                getSubsystemSpectrum(that.pointingNow);
                //document.getElementById(that.pointingNow+'spectrum').onclick();
        }
    }

    //member functions
    //construct the key pointing to the display min and max of detector
    this.constructMinMaxKey = function(detector){
        var limitIndex, limitKey;

        //construct key pointing to relevant minima and maxima, = subsystem name + view state + 'Scale'
        limitIndex = (window.state.subdetectorView < 3) ? window.state.subdetectorView : window.state.subdetectorView-2;
        limitKey = (that.name == detector) ? '' : detector;
        if(limitIndex == 0)
            limitKey += 'HVscale'
        else if(limitIndex == 1)
            limitKey += 'thresholdScale'
        else if(limitIndex == 2)
            limitKey += 'rateScale'

        return limitKey;
    };

    //determine which color <scalar> corresponds to
    this.parseColor = function(scalar, detector){
        var scale,
        limitKey = this.constructMinMaxKey(detector);

        if(scalar == 0xDEADBEEF) return 0xDEADBEEF

        //how far along the scale are we?  Technically this will produce the wrong color for canvases not currently on display.
        if(window.parameters.detectorLogMode.SubsystemsButton){
            scale = (Math.log(scalar) - Math.log(ODB[this.name][limitKey][0])) / (Math.log(ODB[this.name][limitKey][1]) - Math.log(ODB[this.name][limitKey][0]));
        } else {
            scale = (scalar - ODB[this.name][limitKey][0]) / (ODB[this.name][limitKey][1] - ODB[this.name][limitKey][0]);
        }

        //different scales for different meters to aid visual recognition:
        if(window.state.subdetectorView==0) return scalepickr(scale, window.parameters.subdetectorColors[0]);
        else if(window.state.subdetectorView==1 || window.state.subdetectorView==3) return scalepickr(scale, window.parameters.subdetectorColors[1]);
        else if(window.state.subdetectorView==2 || window.state.subdetectorView==4) return scalepickr(scale, window.parameters.subdetectorColors[2]);
    };

    //draw the color scale
    this.drawScale = function(context, frame){
        var i, j, key, nKeys=0, label, limitIndex, limitKey;
        var scaleFraction = 0.8  //fraction of canvas to span with the scale
        //clear the scale region
        context.clearRect(0, this.canvasHeight - this.scaleHeight, this.canvasWidth, this.canvasHeight);

        //compressed unit for scales, as a function of window.state.subdetectorView:
        var scaleUnit = [' k', String.fromCharCode(2406)+'10'+String.fromCharCode(179)+' ', ' k']

        //where in the array of minima / maxima will we find the appropriate limit:
        limitIndex = (window.state.subdetectorView < 3) ? window.state.subdetectorView : window.state.subdetectorView-2;

        //define the strings to use for each minima and maxima label:
        var minTicks = [];
        var maxTicks = [];
        title = window.parameters.monitorValues[limitIndex];
        if(window.parameters.detectorLogMode.SubsystemsButton) title = 'log(' + title + ')';
        for(i=0; i<this.subdetectors.length; i++){
            limitKey = this.constructMinMaxKey(this.subdetectors[i]);
            if(window.parameters.detectorLogMode.SubsystemsButton){
                //minimas
                minTicks[this.subdetectors[i]] = this.subdetectors[i]+': ' + Math.log(ODB[this.name][limitKey][0]).toFixed(1) + ' log(' + window.parameters.subdetectorUnit[limitIndex]+')';
                //maximas:
                maxTicks[this.subdetectors[i]] = this.subdetectors[i]+': ' + Math.log(ODB[this.name][limitKey][1]).toFixed(1) + ' log(' + window.parameters.subdetectorUnit[limitIndex]+')';
            } else {
                //minimas
                if(ODB[this.name][limitKey][0] < 1000) minTicks[this.subdetectors[i]] = this.subdetectors[i]+': ' + ODB[this.name][limitKey][0] + ' ' + window.parameters.subdetectorUnit[limitIndex];
                else minTicks[this.subdetectors[i]] = this.subdetectors[i] + ': ' + ODB[this.name][limitKey][0]/1000 + scaleUnit[limitIndex] + window.parameters.subdetectorUnit[limitIndex];
                //maximas:
                if(ODB[this.name][limitKey][1] < 1000) maxTicks[this.subdetectors[i]] = this.subdetectors[i]+': ' + ODB[this.name][limitKey][1] + ' ' + window.parameters.subdetectorUnit[limitIndex];
                else maxTicks[this.subdetectors[i]] = this.subdetectors[i] + ': ' + ODB[this.name][limitKey][1]/1000 + scaleUnit[limitIndex] + window.parameters.subdetectorUnit[limitIndex];
            }
            nKeys++;            
        }

        //titles
        context.fillStyle = '#999999';
        context.font="24px 'Orbitron'";
        context.fillText(title, this.canvasWidth/2 - context.measureText(title).width/2, this.canvasHeight*0.95);

        //tickmark;
        context.strokeStyle = '#999999';
        context.lineWidth = 1;
        context.font="12px 'Raleway'";

        //min tick
        context.beginPath();
        context.moveTo(this.canvasWidth*(1-scaleFraction)/2+1, this.canvasHeight - this.scaleHeight/2);
        context.lineTo(this.canvasWidth*(1-scaleFraction)/2+1, this.canvasHeight - this.scaleHeight/2 + 10);
        context.stroke();
        for(i=0; i<this.subdetectors.length; i++){
            label = ((nKeys == 1) ? minTicks[this.subdetectors[i]].slice(minTicks[this.subdetectors[i]].indexOf(':')+2, minTicks[this.subdetectors[i]].length+1) : minTicks[this.subdetectors[i]]);
            context.fillText( label, this.canvasWidth*(1-scaleFraction)/2 - context.measureText(label).width/2, this.canvasHeight-this.scaleHeight/2 + 25+12*i);
        }

        //max tick
        context.beginPath();
        context.moveTo(this.canvasWidth*(1-(1-scaleFraction)/2)-1, this.canvasHeight - this.scaleHeight/2);
        context.lineTo(this.canvasWidth*(1-(1-scaleFraction)/2)-1, this.canvasHeight - this.scaleHeight/2 + 10); 
        context.stroke();
        for(i=0; i<this.subdetectors.length; i++){
            label = ((nKeys == 1) ? maxTicks[this.subdetectors[i]].slice(maxTicks[this.subdetectors[i]].indexOf(':')+2, maxTicks[this.subdetectors[i]].length+1) : maxTicks[this.subdetectors[i]]);
            context.fillText(label, this.canvasWidth*(1-(1-scaleFraction)/2) - context.measureText(label).width/2, this.canvasHeight-this.scaleHeight/2 + 25+12*i);
        }

        var colorSteps = 150
        for(i=0; i<3*colorSteps; i++){
            if(window.state.subdetectorView == 0) context.fillStyle = scalepickr((i%colorSteps)/colorSteps, window.parameters.subdetectorColors[0]);
            if(window.state.subdetectorView == 1 || window.state.subdetectorView == 3) context.fillStyle = scalepickr((i%colorSteps)/colorSteps, window.parameters.subdetectorColors[1]);
            if(window.state.subdetectorView == 2 || window.state.subdetectorView == 4) context.fillStyle = scalepickr((i%colorSteps)/colorSteps, window.parameters.subdetectorColors[2]);
            context.fillRect(this.canvasWidth*(1-scaleFraction)/2 + this.canvasWidth*scaleFraction/colorSteps*(i%colorSteps), this.canvasHeight-this.scaleHeight/2-20, this.canvasWidth*scaleFraction/colorSteps, 20);
        }

        //make a tooltip hook for the scale; leave a 5px border to kick the cursor back to normal without an onmouseout 
        this.TTcontext.fillStyle = 'rgba(255,255,255,1)';
        this.TTcontext.fillRect(5, this.canvasHeight - this.scaleHeight+5, this.canvasWidth-10, this.canvasHeight-10);
        //same for the detail view
        if(this.TTdetailContext){
            this.TTdetailContext.fillStyle = 'rgba(255,255,255,1)';
            this.TTdetailContext.fillRect(5, this.canvasHeight - this.scaleHeight+5, this.canvasWidth-10, this.canvasHeight-10);
        }

    };

    //decide which view to transition to when this object is navigated to
    this.view = function(){
        return this.canvasID;
    };

    //determine the cell index at canvas position x, y
    this.findCell = function(x, y){
        var imageData = this.TTcontext.getImageData(x,y,1,1);
        var index = -1;
        if(imageData.data[0] == imageData.data[1] && imageData.data[0] == imageData.data[2]) index = imageData.data[0];
        return index;
    };

    //manage animation
    this.animate = function(){
        if(window.onDisplay == this.canvasID) animate(this, 0);
    };

    //make the base HV / thresholds / rate summary text for the tooltip
    this.baseTTtext = function(HV, thresh, rate, HVB){
        var nextLine, toolTipContent;
        toolTipContent = '';

        //HV
        if(arguments.length == 4){
            nextLine = window.parameters.monitorValues[0] + '-A: ';
            if(HV < 0xDEADBEEF)
                nextLine += HV.toFixed() + ' ' + window.parameters.subdetectorUnit[0];
            else
                nextLine += 'Not Reporting';
            toolTipContent += nextLine + '<br>';
            nextLine = window.parameters.monitorValues[0] + '-B: ';
            if(HVB < 0xDEADBEEF)
                nextLine += HVB.toFixed() + ' ' + window.parameters.subdetectorUnit[0];
            else
                nextLine += 'Not Reporting';
            toolTipContent += nextLine + '<br>';
        } else if(arguments.length == 3){
            nextLine = window.parameters.monitorValues[0] + ': ';
            if(HV < 0xDEADBEEF)
                nextLine += HV.toFixed() + ' ' + window.parameters.subdetectorUnit[0];
            else
                nextLine += 'Not Reporting';
            toolTipContent += nextLine + '<br>';            
        }

        //Thresholds
        nextLine = window.parameters.monitorValues[1] + ': ';
        if(thresh >= 0xDEADBEEF) nextLine += 'Not Reporting';
        else nextLine += thresh.toFixed() + ' ' + window.parameters.subdetectorUnit[1];
        toolTipContent += nextLine + '<br>';
        //Rate
        nextLine = window.parameters.monitorValues[2] + ': ';
        if(rate >= 0xDEADBEEF) nextLine += 'Not Reporting';
        else nextLine += rate.toFixed() + ' ' + window.parameters.subdetectorUnit[2];
        toolTipContent += nextLine;

        return toolTipContent;
    };

    //a more generic tt text.  lines is an array, where each entry is another array packed as [prefix, value, suffix]
    this.TTtext = function(lines){
        var i, nextLine, toolTipContent;
        toolTipContent = '';

        for(i=0; i<lines.length; i++){
            nextLine = lines[i][0] + ': ';
            nextLine += (lines[i][1] == 0xDEADBEEF) ? 'Not Reporting' : lines[i][1].toFixed() + ' ' + lines[i][2];
            toolTipContent += nextLine + '<br>'
        }

        return toolTipContent;
    };

    //simple data fetcher.  Some subsystems will have more sophisticated data routing.
    this.fetchNewData = function(){
        
        var key;
        this.dataBus.totalRate = 0;
        //it seems to be possible (but difficult) to trigger a fetchNewData when window.JSONPstore.thresholds is empty...?
        for(key in this.dataBus[this.name]){
            //thresholds
            this.dataBus[this.name][key]['threshold'] = 0xDEADBEEF; 
            if(window.JSONPstore['thresholds'] && typeof window.JSONPstore['thresholds'][key] == 'number'){
                this.dataBus[this.name][key]['threshold'] = window.JSONPstore['thresholds'][key];
            } //else if(this.name != 'DESCANT')
                //console.log([key, window.JSONPstore['thresholds']])
                   
            //rates
            this.dataBus[this.name][key]['rate'] = 0xDEADBEEF;
            if(window.JSONPstore['scalar'] && window.JSONPstore['scalar'][key] && typeof window.JSONPstore['scalar'][key]['TRIGREQ'] == 'number'){
                this.dataBus[this.name][key]['rate'] = window.JSONPstore['scalar'][key]['TRIGREQ'];
                this.dataBus.totalRate += window.JSONPstore['scalar'][key]['TRIGREQ'];
            }

            //HV
            this.dataBus[this.name][key]['HV'] = 0xDEADBEEF;
            if(window.JSONPstore['HV'] && typeof window.JSONPstore['HV'][key] == 'number'){
                this.dataBus[this.name][key]['HV'] = window.JSONPstore['HV'][key];
            }

        }
        
    };

    //generic update routine.  Again, some subsystems are more complcated versions of this:
    this.update = function(){
        var key;

        //get new data
        this.fetchNewData();

        //parse the new data into colors
        for(key in this.dataBus[this.name]){
            this.dataBus[this.name][key].oldHVcolor = this.dataBus[this.name][key].HVcolor;
            this.dataBus[this.name][key].HVcolor = this.parseColor(this.dataBus[this.name][key].HV, this.detectorType(key));
            this.dataBus[this.name][key].oldThresholdColor = this.dataBus[this.name][key].thresholdColor;
            this.dataBus[this.name][key].thresholdColor = this.parseColor(this.dataBus[this.name][key].threshold, this.detectorType(key));
            this.dataBus[this.name][key].oldRateColor = this.dataBus[this.name][key].rateColor;
            this.dataBus[this.name][key].rateColor = this.parseColor(this.dataBus[this.name][key].rate, this.detectorType(key));

            //if(this.dataBus[this.name][key].threshold == 0xDEADBEEF && key.slice(0,3) != 'DSC')
            //    console.log(key)
        }

        //do the same for the summary level, if it exists:
        if(this.dataBus.summary){
            for(key in this.dataBus.summary){
                this.dataBus.summary[key].oldHVcolor = this.dataBus.summary[key].HVcolor;
                this.dataBus.summary[key].HVcolor = this.parseColor(this.dataBus.summary[key].HV, this.detectorType(key));
                this.dataBus.summary[key].oldThresholdColor = this.dataBus.summary[key].thresholdColor;
                this.dataBus.summary[key].thresholdColor = this.parseColor(this.dataBus.summary[key].threshold, this.detectorType(key));
                this.dataBus.summary[key].oldRateColor = this.dataBus.summary[key].rateColor;
                this.dataBus.summary[key].rateColor = this.parseColor(this.dataBus.summary[key].rate, this.detectorType(key));
            }            
        }

        //update tooltip
        this.tooltip.update();
        //update detail level tooltip if it exists:
        if(this.detailTooltip)
            this.detailTooltip.update();

        //animate if on top:
        this.animate();

    };

    //return the detector code from the parameters store that corresponds to the input detector <name> - trivial case
    //here will work for subsystems with only one kind of element like DESCANT or SHARC, 
    //subsystems with multiple detector types like DANTE and TIP will have to define their own.
    this.detectorType = function(name){
        return this.name;
    };
    
    //write the simplest possible subsystem tooltip contents:
    this.defineText = function(cell){
        
        var key=null, nextLine, toolTipContent;

        if(cell == 255){
            toolTipContent = '<br>Click to adjust scale.<br><br>'
        } else {
            toolTipContent = '<br>'
            key = this.dataBus.TTmap[cell];
            nextLine = key;
            toolTipContent += nextLine + '<br><br>';
            toolTipContent += this.baseTTtext(this.dataBus[this.name][key].HV, this.dataBus[this.name][key].threshold, this.dataBus[this.name][key].rate);
            toolTipContent += '<br><br>';
            this.pointingNow = key;
        }

        document.getElementById(this.tooltip.ttDivID).innerHTML = toolTipContent;
    };
    
}









//another object to inject into subsystems that need a detail-level view:
function DetailView(){
    var that = this;
    this.detailCanvasID = this.name+'detailCanvas';       //ID of canvas to draw single HPGe view on
    this.TTdetailCanvasID = this.name+'TTdetailCanvas';   //ID of hidden tooltip map canvas for detail level
    this.TTdetailLayerDone = 0;

    //insert & scale canvas
    injectDOM('canvas', this.detailCanvasID, this.monitorID, {
        'class' : 'monitor',
        'style' : 'top:' + ($('#'+this.linkWrapperID).offset().top + $('#'+this.linkWrapperID).height()*1.25 + 5) +'px; transition:opacity 0.5s, z-index 0.5s; -moz-transition:opacity 0.5s, z-index 0.5s; -webkit-transition:opacity 0.5s, z-index 0.5s;'
    });
    this.detailCanvas = document.getElementById(this.detailCanvasID);
    this.detailContext = this.detailCanvas.getContext('2d');
    this.detailCanvas.setAttribute('width', this.canvasWidth);
    this.detailCanvas.setAttribute('height', this.canvasHeight);
    //hidden Tooltip map layer for detail
    injectDOM('canvas', this.TTdetailCanvasID, this.monitorID, {
        'class' : 'monitor',
        'style' : 'top:' + ($('#'+this.linkWrapperID).offset().top + $('#'+this.linkWrapperID).height()*1.25 + 5) +'px;'
    });
    this.TTdetailCanvas = document.getElementById(this.TTdetailCanvasID);
    this.TTdetailContext = this.TTdetailCanvas.getContext('2d');
    this.TTdetailCanvas.setAttribute('width', this.canvasWidth);
    this.TTdetailCanvas.setAttribute('height', this.canvasHeight);

    //detail level tt:
    //paint whole hidden canvas with R!=G!=B to trigger TT suppression:
    this.TTdetailContext.fillStyle = 'rgba(50,100,150,1)';
    this.TTdetailContext.fillRect(0,0,this.canvasWidth, this.canvasHeight);
    //set up detail tooltip:
    this.detailTooltip = new Tooltip(this.detailCanvasID, this.name+'TTdetail', this.monitorID, window.parameters.HPGeprefix, window.parameters.HPGepostfix);
    this.detailTooltip.obj = that;

    //onclick switch between top and detail view - only appropriate for detectors with a single scale (so ie not HPGe, which has HPGe+BGO)
    this.detailCanvas.onclick = function(event){
                                    var y = event.pageY - that.canvas.offsetTop - that.monitor.offsetTop;    
                                    if(y < that.canvasHeight - that.scaleHeight){
                                        that.detailShowing = 0;
                                        that.detailTooltip.canvas.onmouseout();
                                        swapFade(null, that, 1000);
                                    } else{
                                        parameterDialogue(that.name, [[that.name, ODB[that.name][that.constructMinMaxKey(that.name)][0], ODB[that.name][that.constructMinMaxKey(that.name)][1], window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/'+that.name+'/'+scaleType()+'[0]', '/DashboardConfig/'+that.name+'/'+scaleType()+'[1]']], window.parameters.subdetectorColors[window.state.subdetectorView]);
                                    }
                                };
    this.canvas.onclick =   function(event){
                                //use TT layer to decide which detail group user clicked on
                                var detailClicked = -1;
                                var x,y;
                                x = event.pageX - that.canvas.offsetLeft - that.monitor.offsetLeft;
                                y = event.pageY - that.canvas.offsetTop - that.monitor.offsetTop;
                                detailClicked = that.findCell(x,y);
                                //draw and swap out if user clicked on a valid detail group
                                if(detailClicked != -1){
                                    that.detailShowing = detailClicked;
                                    that.TTdetailLayerDone = 0 //get ready to draw a new TT layer for the detail view
                                    //draw detail chooses which detail group to draw as a function of that.detailShowing:
                                    that.drawDetail(0,that.nFrames);  //draw detail wants a context for first arg, eliminate
                                    that.tooltip.canvas.onmouseout();
                                    swapFade(null, that, 1000)
                                } else if(y > that.canvasHeight - that.scaleHeight){
                                    parameterDialogue(that.name, [[that.name, ODB[that.name][that.constructMinMaxKey(that.name)][0], ODB[that.name][that.constructMinMaxKey(that.name)][1], window.parameters.subdetectorUnit[window.state.subdetectorView], '/DashboardConfig/'+that.name+'/'+scaleType()+'[0]', '/DashboardConfig/'+that.name+'/'+scaleType()+'[1]']], window.parameters.subdetectorColors[window.state.subdetectorView]);
                                }
                            };

    //member functions
    //decide which view to transition to when this object is navigated to; overwrites equivalent in Subsystem.
    this.view = function(){
        if(this.detailShowing == 0)
            return this.canvasID;
        else if(this.detailShowing > 0)
            return this.detailCanvasID;
    };

    //determine the cell index at canvas position x, y; overwrites equivalent in Subsystem.
    this.findCell = function(x, y){
        var imageData 
        if(this.detailShowing){
            imageData = this.TTdetailContext.getImageData(x,y,1,1);
        } else{
            imageData = this.TTcontext.getImageData(x,y,1,1);
        }
        var index = -1;
        if(imageData.data[0] == imageData.data[1] && imageData.data[0] == imageData.data[2]) index = imageData.data[0];

        return index;
    };

    //manage animation
    this.animate = function(){
        if(window.onDisplay == this.canvasID) animate(this, 0);
        if(window.onDisplay == this.detailCanvasID) animateDetail(this, 0);
    };

    //decide which display version to show: (depricated?)
    this.displaySwitch = function(){
        this.TTdetailContext.fillStyle = 'rgba(50,100,150,1)';
        this.TTdetailContext.fillRect(0,0,this.canvasWidth,this.canvasHeight);
        this.drawDetail(this.detailContext, this.nFrames);
        this.drawDetail(this.TTdetailContext, this.nFrames);
    };

}








//function wrapping all the specialized drawing tools for HPGe displays:
function HPGeAssets(){
    //draw crystal core
    this.crystalCore = function(context, x0, y0, border, fill){
        context.strokeStyle = border;
        context.fillStyle = fill;
        context.fillRect(Math.round(x0), Math.round(y0), Math.round(this.crystalSide/3), Math.round(this.crystalSide/3));
        if(context == this.context || context == this.detailContext) context.stroke();
    };

    //draw HV box for one cloverleaf:
    this.crystal = function(context, x0, y0, border, fill){
        context.strokeStyle = border;
        context.fillStyle = fill;
        context.fillRect(Math.round(x0), Math.round(y0), Math.round(this.crystalSide), Math.round(this.crystalSide));
        if(context == this.context || context == this.detailContext){
            context.strokeRect(x0, y0, this.crystalSide, this.crystalSide);
        }

    }; 

    //draw split crystal for HV view
    this.splitCrystal = function(context, x0, y0, side, cloverLeaf, border, fill, fillB){
        //antialiasing hack: draw this first on the tooltip level
        if(context == this.TTdetailContext && fill != '#123456'){
            this.splitCrystal(context, x0, y0, side, border, '#123456', '#123456');
        }

        context.save();
        context.translate(x0+side/2, y0+side/2);
        context.rotate(Math.PI/2*cloverLeaf);
        context.strokeStyle = border;

        context.fillStyle = fill;
        context.beginPath();
        context.moveTo(side/2,-side/2);
        context.lineTo(-side/2,-side/2);
        context.lineTo(-side/2,side/2);
        context.closePath();
        context.fill();
        if(context == this.context || context == this.detailContext) context.stroke();

        context.fillStyle = fillB;
        context.beginPath();
        context.moveTo(side/2,-side/2);
        context.lineTo(side/2,side/2);
        context.lineTo(-side/2,side/2);
        context.closePath();
        context.fill();
        if(context == this.context || context == this.detailContext) context.stroke();
        
        context.restore();
    };

    //draw L shape
    this.drawL = function(context, phi, thickness, length, x0, y0, border, fill){
        //antialiasing hack: draw this first on the tooltip level
        if(context == this.TTdetailContext && fill != '#123456'){
            this.drawL(context, phi, thickness, length, x0, y0, border, '#123456');
        }

        context.strokeStyle = border;
        context.fillStyle = fill;
        context.save();
        context.translate(Math.round(x0), Math.round(y0));
        context.rotate(phi);

        context.beginPath();
        context.moveTo(0,0);
        context.lineTo(Math.round(length), 0);
        context.lineTo(Math.round(length), Math.round(thickness));
        context.lineTo(Math.round(thickness), Math.round(thickness));
        context.lineTo(Math.round(thickness), Math.round(length));
        context.lineTo(0,Math.round(length));
        context.closePath();
        context.fill();
        if(context == this.context || context == this.detailContext) context.stroke();

        context.restore();

    };

    //draw half-L
    this.drawHalfL = function(context, phi, thickness, length, x0, y0, chirality, split, border, fill, fillB){
        //antialiasing hack: draw this first on the tooltip level
        if(context == this.TTdetailContext && fill != '#123456'){
            this.drawHalfL(context, phi, thickness, length, x0, y0, chirality, split, border, '#123456', '#123456');
        }

        context.save();
        context.strokeStyle = border;
        context.fillStyle = fill;
        context.translate(x0, y0);
        context.rotate(phi);

        if(chirality == 'left'){
            context.translate(this.detailContext.width,0);
            context.scale(-1,1);   
        }

        if(split){
            context.beginPath();
            context.moveTo((length-thickness)/2,0);
            context.lineTo(length-thickness, 0);
            context.lineTo(length-thickness, -thickness);
            context.lineTo((length-thickness)/2,-thickness);
            context.closePath();
            context.fill();
            if(context == this.context || context == this.detailContext) context.stroke();

            context.fillStyle = fillB;
            context.beginPath();
            context.moveTo(0,0);
            context.lineTo((length-thickness)/2,0);
            context.lineTo((length-thickness)/2,-thickness);
            context.lineTo(-thickness, -thickness);
            context.closePath();
            context.fill();
            if(context == this.context || context == this.detailContext) context.stroke();
        } else{
            context.beginPath();
            context.moveTo(0,0);
            context.lineTo(length-thickness, 0);
            context.lineTo(length-thickness, -thickness);
            context.lineTo(-thickness, -thickness);
            context.closePath();
            context.fill();
            if(context == this.context || context == this.detailContext) context.stroke();
        }

        context.restore();
    };

    this.drawHPGesummary = function(context, x0,y0, cloverSummaryKey, frame){
        var key, i, q, iprime;
        var color1, color2, fillColor;

        for(q=0; q<4; q++){
            key = cloverSummaryKey + this.dataBus.colorQuads[q];
            i = this.dataBus.summary[key].quadrant;
            if(i==3) i = 2;
            else if(i==2) i = 3;
            
            if(key[2] == 'G'){
                //HPGE
                if(context == this.TTcontext){
                    iprime = 100+this.dataBus.summary[key].clover*8+i;
                    context.fillStyle = 'rgba('+iprime+','+iprime+','+iprime+',1)';
                } else{
                    if(window.state.subdetectorView == 0){
                        color1 = parseHexColor(this.dataBus.summary[key].oldHVcolor);
                        color2 = parseHexColor(this.dataBus.summary[key].HVcolor);
                    } else if(window.state.subdetectorView == 1){
                        color1 = parseHexColor(this.dataBus.summary[key].oldThresholdColor);
                        color2 = parseHexColor(this.dataBus.summary[key].thresholdColor);
                    } else if(window.state.subdetectorView == 2){
                        color1 = parseHexColor(this.dataBus.summary[key].oldRateColor);
                        color2 = parseHexColor(this.dataBus.summary[key].rateColor);
                    }
                    context.fillStyle = interpolateColor(color1, color2, frame/this.nFrames);
                    if(interpolateColor(color1, color2, frame/this.nFrames) == 0xDEADBEEF)
                        context.fillStyle = context.createPattern(window.parameters.warningFill, 'repeat');
                }
                if( this.cloversAbsent.indexOf(parseInt(cloverSummaryKey.slice(3,5),10)) != -1 && context!= this.TTcontext)
                    context.fillStyle = '#333333' //absent clovers transparent

                context.fillRect(Math.round(x0 + (this.BGOouter-this.HPGeside)/2 + (i%2)*(this.lineWeight + this.HPGeside/2)), Math.round(y0 + (this.BGOouter-this.HPGeside)/2 + (i>>1)/2*(2*this.lineWeight + this.HPGeside)), Math.round(this.HPGeside/2),Math.round(this.HPGeside/2));
                if(context != this.TTcontext){
                    context.strokeStyle = '#999999';
                    context.strokeRect(x0 + (this.BGOouter-this.HPGeside)/2 + (i%2)*(this.lineWeight + this.HPGeside/2), y0 + (this.BGOouter-this.HPGeside)/2 + (i>>1)/2*(2*this.lineWeight + this.HPGeside), this.HPGeside/2, this.HPGeside/2);
                }
            } else if(key[2] == 'S'){       
                //BGO
                var rotation 
                if(i<2) rotation = i*Math.PI/2;
                else if(i==2) rotation = 3*Math.PI/2;
                else if(i==3) rotation = Math.PI;
                var color = '#999999';
                if(context == this.TTcontext){
                    iprime = 100+this.dataBus.summary[key].clover*8+i+4;
                    fillColor = 'rgba('+iprime+','+iprime+','+iprime+',1)';
                } else{
                    if(window.state.subdetectorView == 0){
                        color1 = parseHexColor(this.dataBus.summary[key].oldHVcolor);
                        color2 = parseHexColor(this.dataBus.summary[key].HVcolor);
                    } else if(window.state.subdetectorView == 1){
                        color1 = parseHexColor(this.dataBus.summary[key].oldThresholdColor);
                        color2 = parseHexColor(this.dataBus.summary[key].thresholdColor);
                    } else if(window.state.subdetectorView == 2){
                        color1 = parseHexColor(this.dataBus.summary[key].oldRateColor);
                        color2 = parseHexColor(this.dataBus.summary[key].rateColor);
                    }
                    fillColor = interpolateColor(color1, color2, frame/this.nFrames);
                    if(fillColor == 0xDEADBEEF)
                        fillColor = context.createPattern(window.parameters.warningFill, 'repeat');
                    if( this.cloversAbsent.indexOf(parseInt(cloverSummaryKey.slice(3,5),10)) != -1 )
                        fillColor = '#333333' //absent clovers transparent
                }

                this.drawL(context, rotation, Math.round((this.BGOouter - this.BGOinner)/2), Math.round(this.BGOouter/2), Math.round(x0 + (this.BGOouter+this.lineWeight)*(i%2)), Math.round(y0 + (this.BGOouter+this.lineWeight)*(i>>1)), color, fillColor);
            }
            
        }

    };

    this.drawDetail = function(context, frame){
        if(context==this.TTdetailContext && this.TTdetailLayerDone) return 0; //only draw the TT layer once

        var i, j, quad;

        //state variables select the segmentation state of HPGe and services of BGO 
        var HPGestate, BGOstate;

        this.detailContext.lineWidth = this.lineWeight;

        //colorWheel enumerates the standard configuration of color sectors:
        var colorWheel =  ['#999999','#999999','#999999','#999999'];//['#00FF00', '#0000FF', '#FFFFFF', '#FF0000'];
        //orientation enumerates orientations of half-BGOs
        var orientation = ['left', 'right'];

        var fillColor, fillColor2;
        var pfx = (this.mode == 'TIGRESS') ? 'TI' : 'GR';

        //clover HPGe and BGO keys:
        var HPGeName = pfx+'G'+ ( (this.cloverShowing<10) ? '0'+this.cloverShowing : this.cloverShowing );
        var BGOname  = pfx+'S'+ ( (this.cloverShowing<10) ? '0'+this.cloverShowing : this.cloverShowing );
        var HPGeKey, BGOkey, BGOsuffix;

        if(window.state.subdetectorView == 0){
            HPGestate = 0; //no segmentation
            BGOstate = 1;  //two services per sector per side per suppressor
        }else if(window.state.subdetectorView == 1 || window.state.subdetectorView == 2){
            HPGestate = 1; //9-element segmentation
            BGOstate = 0;  //one service per sector per side per suppressor
        }
        
        //loop over quadrents:
        for(i=0; i<4; i++){
            
            //useful switches:
            var PBC = Math.ceil((i%3)/3);               //positive for i=1,2, 0 OW
            var NAD = Math.ceil((i%3)/3) - 1;           //negative for i=0,3, 0 OW
            var NAB = Math.floor(i/2) - 1;              //negative for i=0,1, 0 OW
            var PCD = Math.floor(i/2);                  //positive for i=2,3, 0 OW

            //append quadrant color to keys:
            HPGeKey = HPGeName + this.dataBus.colorQuads[i];
            BGOkey = BGOname + this.dataBus.colorQuads[i];

            //HPGe/////////////////////////////
            if(HPGestate == 0){
                
                if(context == this.detailContext){
                    fillColor  =  interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'N00A'].oldHVcolor), parseHexColor(this.dataBus.HPGe[HPGeKey+'N00A'].HVcolor), frame/this.nFrames);
                } else{
                    fillColor  = 'rgba('+i+', '+i+', '+i+', 1)';
                }
                if(fillColor==0xDEADBEEF) fillColor = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                this.crystal(context, this.centerX + PBC*this.lineWeight + NAD*this.crystalSide, this.centerY + NAB*this.crystalSide + PCD*this.lineWeight, colorWheel[i], fillColor);
                
            } else if(HPGestate == 1){
                
                if(this.mode == 'TIGRESS'){
                    
                    //cores - same as GRIFFIN for core, factor out
                    if(context == this.detailContext){
                        if(window.state.subdetectorView == 1){
                            fillColor  = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'N00A'].oldThresholdColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'N00A'].thresholdColor), frame/this.nFrames );
                            fillColor2 = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'N00B'].oldThresholdColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'N00B'].thresholdColor), frame/this.nFrames );
                        }
                        else if(window.state.subdetectorView == 2){ 
                            fillColor  = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'N00A'].oldRateColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'N00A'].rateColor), frame/this.nFrames );
                            fillColor2 = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'N00B'].oldRateColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'N00B'].rateColor), frame/this.nFrames );
                        }
                        if(fillColor==0xDEADBEEF) fillColor = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                        if(fillColor2==0xDEADBEEF) fillColor2 = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                    } else {
                        fillColor  = 'rgba('+10*i+', '+10*i+', '+10*i+', 1)';
                        fillColor2 = 'rgba('+(10*i+1)+', '+(10*i+1)+', '+(10*i+1)+', 1)';
                    }

                    this.splitCrystal(context, this.centerX + NAD*2/3*this.crystalSide + PBC*1/3*this.crystalSide + PBC*this.lineWeight, this.centerY + NAB*2/3*this.crystalSide + PCD*1/3*this.crystalSide + PCD*this.lineWeight, this.crystalSide/3, i, colorWheel[i], fillColor, fillColor2);
                    
                    for(j=0; j<4; j++){
                        //useful switches:
                        var PBC2 = Math.ceil((j%3)/3);               //positive for i=1,2, 0 OW
                        var NAD2 = Math.ceil((j%3)/3) - 1;           //negative for i=0,3, 0 OW
                        var NAB2 = Math.floor(j/2) - 1;              //negative for i=0,1, 0 OW
                        var PCD2 = Math.floor(j/2);                  //positive for i=2,3, 0 OW
                        //segements drawn in different order than numbering; use jprime to get the right mapping:
                        var jprime = (((1-j)+4)%4 + i)%4;
                        if (jprime==0) jprime = 4;

                        //segs 1-4
                        if(context == this.detailContext){
                            if(window.state.subdetectorView == 1) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'P0'+jprime+'X'].oldThresholdColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'P0'+jprime+'X'].thresholdColor), frame/this.nFrames);
                            else if(window.state.subdetectorView == 2) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'P0'+jprime+'X'].oldRateColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'P0'+jprime+'X'].rateColor), frame/this.nFrames);
                            if(fillColor==0xDEADBEEF) fillColor = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                        } else
                            fillColor = 'rgba('+(this.nHPGesegments/4*i+jprime+1)+', '+(this.nHPGesegments/4*i+jprime+1)+', '+(this.nHPGesegments/4*i+jprime+1)+', 1)';
                        this.drawL(context, j*Math.PI/2, this.crystalSide/6, 1/3*this.crystalSide, this.centerX + PBC*this.lineWeight + NAD*(-NAD2)*5/6*this.crystalSide + NAD*PBC2*1/6*this.crystalSide + PBC*(-NAD2)*1/6*this.crystalSide + PBC*PBC2*5/6*this.crystalSide, this.centerY + NAB*(-NAB2)*5/6*this.crystalSide + NAB*PCD2*1/6*this.crystalSide + PCD*(-NAB2)*1/6*this.crystalSide + PCD*PCD2*5/6*this.crystalSide + PCD*this.lineWeight, colorWheel[i], fillColor);

                        //segs 5-8
                        if(context == this.detailContext){
                            if(window.state.subdetectorView == 1) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'P0'+(jprime+4)+'X'].oldThresholdColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'P0'+(jprime+4)+'X'].thresholdColor), frame/this.nFrames);
                            else if(window.state.subdetectorView == 2) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'P0'+(jprime+4)+'X'].oldRateColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'P0'+(jprime+4)+'X'].rateColor), frame/this.nFrames);
                            if(fillColor==0xDEADBEEF) fillColor = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                        } else
                            fillColor = 'rgba('+(this.nHPGesegments/4*i+jprime+1+4)+', '+(this.nHPGesegments/4*i+jprime+1+4)+', '+(this.nHPGesegments/4*i+jprime+1+4)+', 1)';
                        this.drawL(context, j*Math.PI/2, this.crystalSide/6, this.crystalSide/2, this.centerX + (-NAD)*NAD2*this.crystalSide + PBC*PBC2*this.crystalSide + PBC*this.lineWeight, this.centerY + (-NAB)*NAB2*this.crystalSide + PCD*PCD2*this.crystalSide + PCD*this.lineWeight, colorWheel[i], fillColor);
                        
                    }
                    
                } else if(this.mode == 'GRIFFIN'){
                    
                    //cores
                    if(context == this.detailContext){
                        if(window.state.subdetectorView == 1){
                            fillColor  = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'N00A'].oldThresholdColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'N00A'].thresholdColor), frame/this.nFrames );
                            fillColor2 = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'N00B'].oldThresholdColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'N00B'].thresholdColor), frame/this.nFrames );
                        }
                        else if(window.state.subdetectorView == 2){ 
                            fillColor  = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'N00A'].oldRateColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'N00A'].rateColor), frame/this.nFrames );
                            fillColor2 = interpolateColor(parseHexColor(this.dataBus.HPGe[HPGeKey+'N00B'].oldRateColor), parseHexColor(this.dataBus.HPGe[HPGeKey+'N00B'].rateColor), frame/this.nFrames );
                        }
                        if(fillColor==0xDEADBEEF) fillColor = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                        if(fillColor2==0xDEADBEEF) fillColor2 = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                    } else {
                        fillColor  = 'rgba('+2*i+', '+2*i+', '+2*i+', 1)';
                        fillColor2 = 'rgba('+(2*i+1)+', '+(2*i+1)+', '+(2*i+1)+', 1)';
                    }

                    this.splitCrystal(context, this.centerX + NAD*this.crystalSide + PBC*this.lineWeight, this.centerY + NAB*this.crystalSide + PCD*this.lineWeight, this.crystalSide, i, colorWheel[i], fillColor, fillColor2);                    
                    
                }
                
            }
            
            //BGO//////////////////////////////
            for(j=0; j<2; j++){
                //useful switches
                var NA = j-1;
                var NB = (-1)*j;
                var PA = (j+1)%2;
                var PB = j;

                //are we on channel A or B for HV?
                var HVchan = 'HVA';
                if(j==1) HVchan = 'HVB';

                //back suppressors
                if(context == this.detailContext){
                    if(window.state.subdetectorView == 0) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+'N05X']['old'+HVchan+'color']), parseHexColor(this.dataBus.HPGe[BGOkey+'N05X'][HVchan+'color']), frame/this.nFrames);
                    else if(window.state.subdetectorView == 1) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+'N05X'].oldThresholdColor), parseHexColor(this.dataBus.HPGe[BGOkey+'N05X'].thresholdColor), frame/this.nFrames);
                    else if(window.state.subdetectorView == 2) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+'N05X'].oldRateColor), parseHexColor(this.dataBus.HPGe[BGOkey+'N05X'].rateColor), frame/this.nFrames);
                    if(fillColor==0xDEADBEEF) fillColor = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');

                } else{
                    if(window.state.subdetectorView == 0){
                        fillColor  ='rgba('+(4+2*i+j)+', '+(4+2*i+j)+', '+(4+2*i+j)+', 1)';
                    }
                    else
                        fillColor = 'rgba('+(this.nHPGesegments+i)+', '+(this.nHPGesegments+i)+', '+(this.nHPGesegments+i)+', 1)';
                }
                if(window.state.subdetectorView == 0){
                    this.drawHalfL(context, (i-1+j)*(Math.PI/2), this.suppressorWidth, this.backBGOouterWidth/2, this.centerX + NAD*this.backBGOinnerWidth/2 + PBC*this.backBGOinnerWidth/2 + PBC*2*this.lineWeight + (-NAB)*NA*this.lineWeight + PCD*NB*this.lineWeight, this.centerY + (NAB+PCD)*this.backBGOinnerWidth/2 + PCD*2*this.lineWeight + (-NAD)*NB*this.lineWeight + PBC*NA*this.lineWeight, orientation[j], false, colorWheel[i], fillColor);
                } else if(window.state.subdetectorView == 1 || window.state.subdetectorView == 2){
                    if(j==0) this.drawL(context, i*(Math.PI/2), this.suppressorWidth, this.backBGOouterWidth/2, this.centerX + NAD*this.backBGOinnerWidth/2 + PBC*this.backBGOinnerWidth/2 + PBC*this.lineWeight + (NAD+PBC)*this.suppressorWidth, this.centerY + (NAB+PCD)*this.backBGOinnerWidth/2 + PCD*this.lineWeight + (NAB+PCD)*this.suppressorWidth, colorWheel[i], fillColor);    
                }
                
                //side suppressors
                BGOsuffix = 'N0'+(3+1-j)+'X'; //side suppressors labeled -N03X and -N04X j->1-j here since drawing happens in reverse order
                if(context == this.detailContext){
                    if(window.state.subdetectorView == 0){
                        fillColor  = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].oldHVAcolor), parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].HVAcolor), frame/this.nFrames);
                        fillColor2 = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].oldHVBcolor), parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].HVBcolor), frame/this.nFrames);
                    }
                    else if(window.state.subdetectorView == 1) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].oldThresholdColor), parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].thresholdColor), frame/this.nFrames);
                    else if(window.state.subdetectorView == 2) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].oldRateColor), parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].rateColor), frame/this.nFrames);
                    if(fillColor==0xDEADBEEF) fillColor = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                    if(fillColor2==0xDEADBEEF) fillColor2 = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                } else{
                    if(window.state.subdetectorView == 0){
                        fillColor  = 'rgba('+(4+8+4*i+2*j)+', '+(4+8+4*i+2*j)+', '+(4+8+4*i+2*j)+', 1)';
                        fillColor2 = 'rgba('+(4+8+4*i+2*j+1)+', '+(4+8+4*i+2*j+1)+', '+(4+8+4*i+2*j+1)+', 1)';
                    }
                    else
                        fillColor = 'rgba('+(this.nHPGesegments+4+2*i+j)+', '+(this.nHPGesegments+4+2*i+j)+', '+(this.nHPGesegments+4+2*i+j)+', 1)';
                }
                this.drawHalfL(context, (i-1+j)*(Math.PI/2), this.suppressorWidth, this.sideBGOouterWidth/2, this.centerX +NAD*this.sideBGOinnerWidth/2 + PBC*this.sideBGOinnerWidth/2 + PBC*2*this.lineWeight + (-NAB)*NA*this.lineWeight + PCD*NB*this.lineWeight     , this.centerY + (NAB+PCD)*this.sideBGOinnerWidth/2 + PCD*2*this.lineWeight + (-NAD)*NB*this.lineWeight + PBC*NA*this.lineWeight, orientation[j], BGOstate, colorWheel[i], fillColor, fillColor2);

                //front suppressors
                BGOsuffix = 'N0'+(1+1-j)+'X'; //front suppressors labeled -N01X and -N02X; j->1-j here since drawing happens in reverse order
                if(context == this.detailContext){
                    if(window.state.subdetectorView == 0){
                        fillColor  = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].oldHVAcolor), parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].HVAcolor), frame/this.nFrames);
                        fillColor2 = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].oldHVBcolor), parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].HVBcolor), frame/this.nFrames);
                    }
                    else if(window.state.subdetectorView == 1) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].oldThresholdColor), parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].thresholdColor), frame/this.nFrames);
                    else if(window.state.subdetectorView == 2) fillColor = interpolateColor(parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].oldRateColor), parseHexColor(this.dataBus.HPGe[BGOkey+BGOsuffix].rateColor), frame/this.nFrames);
                    if(fillColor==0xDEADBEEF) fillColor = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                    if(fillColor2==0xDEADBEEF) fillColor2 = this.detailContext.createPattern(window.parameters.warningFill, 'repeat');
                } else{
                    if(window.state.subdetectorView == 0){
                        fillColor  = 'rgba('+(4+8+16+4*i+2*j)+', '+(4+8+16+4*i+2*j)+', '+(4+8+16+4*i+2*j)+', 1)';
                        fillColor2 = 'rgba('+(4+8+16+4*i+2*j+1)+', '+(4+8+16+4*i+2*j+1)+', '+(4+8+16+4*i+2*j+1)+', 1)';
                    }
                    else
                        fillColor = 'rgba('+(this.nHPGesegments+4+8+2*i+j)+', '+(this.nHPGesegments+4+8+2*i+j)+', '+(this.nHPGesegments+4+8+2*i+j)+', 1)';
                }

                this.drawHalfL(context, (i-1+j)*(Math.PI/2), this.suppressorWidth, this.frontBGOouterWidth/2 - this.sideSpacer, this.centerX + (PBC+NAD)*this.frontBGOinnerWidth/2 + PBC*this.lineWeight + (-NAB)*NA*this.sideSpacer + PCD*NB*this.sideSpacer + (-NAD)*this.sideSpacer, this.centerY + (NAB+PCD)*this.frontBGOinnerWidth/2 + PCD*this.lineWeight + (-NAB*PA + PBC*NA + PBC*PB + PCD*NB)*this.sideSpacer, orientation[j], BGOstate, colorWheel[i], fillColor, fillColor2);
            }  

        }
        
        //scale
        this.drawScale(this.detailContext);
        //title
        this.detailContext.fillStyle = '#999999';
        this.detailContext.font="24px 'Orbitron'";
        this.detailContext.fillText(this.scalePrefix+this.cloverShowing, 0.5*this.canvasWidth - this.detailContext.measureText(this.scalePrefix+this.cloverShowing).width/2, 0.85*this.canvasHeight);
        
        //hack to make sure the tt redraws when we go to HV view, which is segmented differently than the other views
        //if(context == this.TTdetailContext) this.TTdetailLayerDone = 1;
        if(context == this.detailContext && frame == this.nFrames)
            this.drawDetail(this.TTdetailContext, this.nFrames)
    };

    this.updateHPGe = function(){
        //HPGe + BGO
        //summary level
        for(key in this.dataBus.summary){

            detType = (key[2] == 'G') ? 'HPGe' : 'BGO';

            this.dataBus.summary[key].oldHVcolor = this.dataBus.summary[key].HVcolor;
            this.dataBus.summary[key].HVcolor = this.parseColor(this.dataBus.summary[key].HV, detType);
            this.dataBus.summary[key].oldThresholdColor = this.dataBus.summary[key].thresholdColor;
            this.dataBus.summary[key].thresholdColor = this.parseColor(this.dataBus.summary[key].threshold, detType);
            this.dataBus.summary[key].oldRateColor = this.dataBus.summary[key].rateColor;
            this.dataBus.summary[key].rateColor = this.parseColor(this.dataBus.summary[key].rate, detType);
        }
        

        //detail level
        //loop over detector elements
        for(key in this.dataBus.HPGe){
            detType = (key[2] == 'G') ? 'HPGe' : 'BGO';

            if(detType == 'HPGe'){
                this.dataBus.HPGe[key].oldHVcolor = this.dataBus.HPGe[key].HVcolor;
                this.dataBus.HPGe[key].HVcolor = this.parseColor(this.dataBus.HPGe[key].HV, detType);                    
            } else{
                this.dataBus.HPGe[key].oldHVAcolor = this.dataBus.HPGe[key].HVAcolor;
                this.dataBus.HPGe[key].HVAcolor = this.parseColor(this.dataBus.HPGe[key].HVA, detType);
                this.dataBus.HPGe[key].oldHVBcolor = this.dataBus.HPGe[key].HVBcolor;
                this.dataBus.HPGe[key].HVBcolor = this.parseColor(this.dataBus.HPGe[key].HVB,detType);
            }
            this.dataBus.HPGe[key].oldThresholdColor = this.dataBus.HPGe[key].thresholdColor;
            this.dataBus.HPGe[key].thresholdColor = this.parseColor(this.dataBus.HPGe[key].threshold, detType);
            this.dataBus.HPGe[key].oldRateColor = this.dataBus.HPGe[key].rateColor;
            this.dataBus.HPGe[key].rateColor = this.parseColor(this.dataBus.HPGe[key].rate, detType);
        }
    };

    this.fetchHPGeData = function(){
        var i, j, key;
        this.dataBus.totalRate = 0;

        //HPGe + BGO detail
        for(key in this.dataBus.HPGe){

            //thresholds
            this.dataBus.HPGe[key]['threshold'] = 0xDEADBEEF;
            if(window.JSONPstore['thresholds']){
                if(typeof window.JSONPstore['thresholds'][key] == 'number')
                    this.dataBus.HPGe[key]['threshold'] = window.JSONPstore['thresholds'][key];
            }

            //rates
            this.dataBus.HPGe[key]['rate'] = 0xDEADBEEF;
            if(window.JSONPstore['scalar']){
                if(window.JSONPstore['scalar'][key]){
                    if(typeof window.JSONPstore['scalar'][key]['TRIGREQ'] == 'number'){
                        this.dataBus.HPGe[key]['rate'] = window.JSONPstore['scalar'][key]['TRIGREQ'];
                        this.dataBus.totalRate += this.dataBus.HPGe[key]['rate'];
                    }
                }
            }

            //HV
            this.dataBus.HPGe[key]['HV'] = 0xDEADBEEF;
            if(window.JSONPstore['HV']){
                if(window.JSONPstore['HV'][key] == 'number')
                    this.dataBus.HPGe[key]['HV'] = window.JSONPstore['HV'][key];
            }
        }

        //HPGe + BGO summary
        for(key in this.dataBus.summary){
            //summary            
            for(i=0; i<4; i++){
                if(key[2] == 'G'){
                    this.dataBus.summary[key].HV = this.dataBus.HPGe[key+'N00A']['HV'];
                    if(this.mode == 'GRIFFIN'){
                        this.dataBus.summary[key].threshold = (this.dataBus.HPGe[key+'N00A']['threshold'] + this.dataBus.HPGe[key+'N00B']['threshold'])/2;
                        this.dataBus.summary[key].rate = (this.dataBus.HPGe[key+'N00A']['rate'] + this.dataBus.HPGe[key+'N00B']['rate'])/2;
                    } else if (this.mode == 'TIGRESS'){
                        this.dataBus.summary[key].threshold = this.dataBus.HPGe[key+'N00A']['threshold'] + this.dataBus.HPGe[key+'N00B']['threshold'];
                        this.dataBus.summary[key].rate = this.dataBus.HPGe[key+'N00A']['rate'] + this.dataBus.HPGe[key+'N00B']['rate'];
                        for(j=1; j<9; j++){
                            this.dataBus.summary[key].threshold += this.dataBus.HPGe[key+'P0'+j+'X']['threshold'];
                            this.dataBus.summary[key].rate += this.dataBus.HPGe[key+'P0'+j+'X']['rate'];
                        }
                        //this.dataBus.summary[key].threshold = this.dataBus.summary[key].threshold%0xDEADBEEF;  //drop any DEADBEEF that got added in
                        //this.dataBus.summary[key].rate = this.dataBus.summary[key].rate%0xDEADBEEF;
                        //this.dataBus.summary[key].threshold /= 10;
                        //this.dataBus.summary[key].rate /= 10;
                        if(this.dataBus.summary[key].threshold >= 0xDEADBEEF) 
                            this.dataBus.summary[key].threshold = 0xDEADBEEF;
                        else
                            this.dataBus.summary[key].threshold /= 10;
                        if(this.dataBus.summary[key].rate >= 0xDEADBEEF) 
                            this.dataBus.summary[key].rate = 0xDEADBEEF;
                        else
                            this.dataBus.summary[key].rate /= 10;
                    }
                } else if(key[2] == 'S'){
                    this.dataBus.summary[key].HV = 0;
                    for(j=1; j<6; j++){
                        this.dataBus.summary[key].HV += this.dataBus.HPGe[key+'N0'+j+'A'] / 10;
                        this.dataBus.summary[key].HV += this.dataBus.HPGe[key+'N0'+j+'B'] / 10;
                    }
                    this.dataBus.summary[key].threshold = this.dataBus.HPGe[key+'N01X']['threshold'] + this.dataBus.HPGe[key+'N02X']['threshold'] + this.dataBus.HPGe[key+'N03X']['threshold'] + this.dataBus.HPGe[key+'N04X']['threshold'] + this.dataBus.HPGe[key+'N05X']['threshold'];
                    this.dataBus.summary[key].rate = this.dataBus.HPGe[key+'N01X']['rate'] + this.dataBus.HPGe[key+'N02X']['rate'] + this.dataBus.HPGe[key+'N03X']['rate'] + this.dataBus.HPGe[key+'N04X']['rate'] + this.dataBus.HPGe[key+'N05X']['rate'];
                    //this.dataBus.summary[key].threshold = (this.dataBus.summary[key].threshold%0xDEADBEEF)/5;  //drop any DEADBEEF that got added in
                    //this.dataBus.summary[key].rate = (this.dataBus.summary[key].rate%0xDEADBEEF)/5;
                    if(this.dataBus.summary[key].threshold >= 0xDEADBEEF)
                        this.dataBus.summary[key].threshold = 0xDEADBEEF;
                    else
                        this.dataBus.summary[key].threshold /= 5;
                    if(this.dataBus.summary[key].rate >= 0xDEADBEEF)
                        this.dataBus.summary[key].rate = 0xDEADBEEF;
                    else
                        this.dataBus.summary[key].rate /= 5;
                }
            }
        }
        
    };

    this.defineHPGeText = function(cell){
        var i, segA, segB, cloverNumber, cloverName, quadrant, BGO, channelName, detName, suffix, title, ABX;
        var BGO = [];
        var toolTipContent = '';
        var pfx = (this.mode == 'TIGRESS') ? 'TI' : 'GR';

        //summary level//////////////////////////////////////////////////

        if(!this.detailShowing) {

            if(cell == 255){
                toolTipContent = '<br>Click to adjust scale.'
            } else{
                cloverNumber = Math.floor((cell-100)/8);
                cloverName = pfx+'G'+((cloverNumber<10) ? '0'+cloverNumber : cloverNumber );  //will match the HPGe summary ID of this clover
                if(this.cloversAbsent.indexOf(cloverNumber) == -1){  //not in the absentee list
                    quadrant = ((cell-100)%8)%4;
                    if (quadrant==2) quadrant = 3;
                    else if(quadrant==3) quadrant = 2;
                    //HPGE
                    if( (cell-100)%8 < 4 ){
                        if(this.mode == 'GRIFFIN'){
                            segA = cloverName+this.dataBus.colorQuads[quadrant]+'N00A';
                            segB = cloverName+this.dataBus.colorQuads[quadrant]+'N00B';

                            //report segment A:
                            nextLine = segA;
                            toolTipContent = '<br>' + nextLine + '<br>';
                            toolTipContent += this.baseTTtext(this.dataBus.HPGe[segA].HV, this.dataBus.HPGe[segA].threshold, this.dataBus.HPGe[segA].rate)

                            //report segment B:
                            nextLine = segB;
                            toolTipContent += '<br><br>' + nextLine + '<br>';
                            toolTipContent += this.baseTTtext(this.dataBus.HPGe[segA].HV, this.dataBus.HPGe[segB].threshold, this.dataBus.HPGe[segB].rate)
                        } else if(this.mode == 'TIGRESS'){
                            createTIGRESSsummaryTT(this.tooltip.ttDivID, cloverName+this.dataBus.colorQuads[quadrant], this.dataBus);
                        }
                    //BGO 
                    } else {
                        cloverName = pfx+'S'+((cloverNumber<10) ? '0'+cloverNumber : cloverNumber );
                        toolTipContent = '';
                        for(i=1; i<6; i++){
                            BGO[i] = cloverName+this.dataBus.colorQuads[quadrant]+'N0'+i+'X';
                            toolTipContent += ((i==1) ? '<br>' : '<br><br>') + BGO[i] + '<br>';
                            toolTipContent += this.baseTTtext(this.dataBus.HPGe[BGO[i]].HVA, this.dataBus.HPGe[BGO[i]].threshold, this.dataBus.HPGe[BGO[i]].rate, this.dataBus.HPGe[BGO[i]].HVB);
                        }
                    }
                } else {
                    toolTipContent = '<br>'+cloverName + ' absent.'
                }
            }
        }
        //HPGe detail level///////////////////////////////////////////////
        else{
            if(cell == 255){
                toolTipContent = '<br>Click to adjust scale.'
            } else {
                //HV view decodes detector from cell index algorithmically; rate view uses lookup table from DataStructures.  Haven't decided which I dislike less.
                if(window.state.subdetectorView == 0){ 
                    toolTipContent = cell;
                    cloverName = pfx+'S'+((this.cloverShowing<10) ? '0'+this.cloverShowing : this.cloverShowing);
                    //HPGe, front, side or back BGO?
                    if(cell<4){
                        cloverName = pfx+'G'+((this.cloverShowing<10) ? '0'+this.cloverShowing : this.cloverShowing);
                        detName = cloverName+this.dataBus.colorQuads[cell]+'N00A';
                        title = detName.slice(0,9) + 'X';
                        nextLine = this.TTtext([['HV',this.dataBus.HPGe[detName].HV,window.parameters.subdetectorUnit[0]],['Thresholds-A',this.dataBus.HPGe[detName].threshold,window.parameters.subdetectorUnit[1]],['Thresholds-B',this.dataBus.HPGe[detName.slice(0,9)+'B'].threshold,window.parameters.subdetectorUnit[1]],['Rate-A',this.dataBus.HPGe[detName].rate,window.parameters.subdetectorUnit[2]],['Rate-B',this.dataBus.HPGe[detName.slice(0,9)+'B'].rate,window.parameters.subdetectorUnit[2]]]);
                    } else if(cell<12){ //back
                        detName = cloverName+this.dataBus.colorQuads[Math.floor((cell-4)/2)]+'N05X';
                    } else if(cell<28){ //sides
                        suffix = (Math.floor( ((cell-12)%4) /2) == 0) ? 'N03X' : 'N04X';
                        detName = cloverName+this.dataBus.colorQuads[Math.floor((cell-12)/4)]+suffix;
                    } else{ //front
                        suffix = (Math.floor( ((cell-28)%4) /2) == 0) ? 'N01X' : 'N02X';
                        detName = cloverName+this.dataBus.colorQuads[Math.floor((cell-28)/4)]+suffix;
                    }
                    if(cell>3){
                        ABX = (cell%2 == 0) ? 'A' : 'B';
                        title = detName.slice(0,9) + ABX;
                        nextLine = this.baseTTtext(this.dataBus.HPGe[detName]['HV'+ABX], this.dataBus.HPGe[detName].threshold, this.dataBus.HPGe[detName].rate );
                    }

                    toolTipContent = '<br>' + title + '<br><br>' + nextLine;
                    this.pointingNow = detName;
                } else {
                    
                    channelName = this.dataBus.HPGeTTmap[(this.cloverShowing-1)*((this.mode=='TIGRESS')? 60:30) + cell];
                    detName = channelName.slice(0,5);

                    toolTipContent = '<br>' + channelName + '<br><br>';
                    if(detName.slice(2,3) == 'G')
                        toolTipContent += this.baseTTtext(this.dataBus.HPGe[channelName].HV, this.dataBus.HPGe[channelName].threshold, this.dataBus.HPGe[channelName].rate);
                    else if(detName.slice(2,3) == 'S')
                        toolTipContent += this.baseTTtext(this.dataBus.HPGe[channelName].HVA, this.dataBus.HPGe[channelName].threshold, this.dataBus.HPGe[channelName].rate, this.dataBus.HPGe[channelName].HVB);
                    this.pointingNow = channelName;    
                }
                
            }
        }

        toolTipContent += '<br>'
        return toolTipContent;

    };

    function createTIGRESSsummaryTT(wrapperID, cloverLeaf, dataBus){
        var i, elt, eltName1, eltName2;

        document.getElementById(wrapperID).innerHTML = ''; //kill off whatever used to be in there
        injectDOM('table', 'tigressTTtable', wrapperID, {'style':'text-align:center; margin:10px;'});
        injectDOM('tr', 'coreTitles', 'tigressTTtable', {});
        injectDOM('td', 'blank', 'coreTitles', {});
        injectDOM('td', 'spacer', 'coreTitles', {'style':'width:10px;'});
        injectDOM('td', 'coreAname', 'coreTitles', {'innerHTML':cloverLeaf+'N00A'});
        injectDOM('td', 'spacer', 'coreTitles', {'style':'width:50px;'});
        injectDOM('td', 'coreBname', 'coreTitles', {'innerHTML':cloverLeaf+'N00B'});

        injectDOM('tr', 'coreVolt', 'tigressTTtable', {});
        injectDOM('td', 'coreVoltTitle', 'coreVolt', {'style':'text-align:right', 'innerHTML':window.parameters.monitorValues[0]});
        injectDOM('td', 'spacer', 'coreVolt', {'style':'width:10px;'});
        injectDOM('td', 'coreAhv', 'coreVolt', {'innerHTML':( (dataBus.HPGe[cloverLeaf+'N00A'].HV < 0xDEADBEEF) ? dataBus.HPGe[cloverLeaf+'N00A'].HV.toFixed(0) + ' ' + window.parameters.subdetectorUnit[0] : 'Not Reporting')});
        injectDOM('td', 'spacer', 'coreVolt', {'style':'width:50px;'});
        injectDOM('td', 'coreBhv', 'coreVolt', {'innerHTML':( (dataBus.HPGe[cloverLeaf+'N00B'].HV < 0xDEADBEEF) ? dataBus.HPGe[cloverLeaf+'N00B'].HV.toFixed(0) + ' ' + window.parameters.subdetectorUnit[0] : 'Not Reporting')});

        injectDOM('tr', 'coreThreshold', 'tigressTTtable', {});
        injectDOM('td', 'coreThresholdTitle', 'coreThreshold', {'style':'text-align:right;', 'innerHTML':window.parameters.monitorValues[1]});
        injectDOM('td', 'spacer', 'coreThreshold', {'style':'width:10px;'});
        injectDOM('td', 'coreAthreshold', 'coreThreshold', {'innerHTML':( (dataBus.HPGe[cloverLeaf+'N00A'].threshold < 0xDEADBEEF) ? dataBus.HPGe[cloverLeaf+'N00A'].threshold.toFixed(0) + ' ' + window.parameters.subdetectorUnit[1] : 'Not Reporting')});
        injectDOM('td', 'spacer', 'coreThreshold', {'style':'width:50px;'});
        injectDOM('td', 'coreBthreshold', 'coreThreshold', {'innerHTML':( (dataBus.HPGe[cloverLeaf+'N00B'].threshold < 0xDEADBEEF) ? dataBus.HPGe[cloverLeaf+'N00B'].threshold.toFixed(0) + ' ' + window.parameters.subdetectorUnit[1] : 'Not Reporting')});

        injectDOM('tr', 'coreRate', 'tigressTTtable', {});
        injectDOM('td', 'coreRateTitle', 'coreRate', {'style':'text-align:right;', 'innerHTML':window.parameters.monitorValues[2]});
        injectDOM('td', 'spacer', 'coreRate', {'style':'width:10px;'});
        injectDOM('td', 'coreArate', 'coreRate', {'innerHTML':( (dataBus.HPGe[cloverLeaf+'N00A'].rate < 0xDEADBEEF) ? dataBus.HPGe[cloverLeaf+'N00A'].rate.toFixed(0) + ' ' + window.parameters.subdetectorUnit[2] : 'Not Reporting')});
        injectDOM('td', 'spacer', 'coreRate', {'style':'width:50px;'});
        injectDOM('td', 'coreBrate', 'coreRate', {'innerHTML':((dataBus.HPGe[cloverLeaf+'N00B'].rate < 0xDEADBEEF) ? dataBus.HPGe[cloverLeaf+'N00B'].rate.toFixed(0) + ' ' + window.parameters.subdetectorUnit[2] : 'Not Reporting')});

        injectDOM('tr', 'divider', 'tigressTTtable', {});
        injectDOM('td', 'line', 'divider', {'style':'border-bottom-style:solid; border-color:white; border-width:1px;', 'colspan':5})

        for(i=0; i<4; i++){
            elt = cloverLeaf+i;
            eltName1 = cloverLeaf + 'P0' + (2*i+1) + 'X';
            eltName2 = cloverLeaf + 'P0' + (2*i+2) + 'X';

            injectDOM('tr', elt+'Titles', 'tigressTTtable', {});
            injectDOM('td', 'blank', elt+'Titles', {});
            injectDOM('td', 'spacer', elt+'Titles', {'style':'width:10px;'});
            injectDOM('td', elt+'Aname', elt+'Titles', {'innerHTML':eltName1});
            injectDOM('td', 'spacer', elt+'Titles', {'style':'width:50px;'});
            injectDOM('td', elt+'Bname', elt+'Titles', {'innerHTML':eltName2});

            injectDOM('tr', elt+'Volt', 'tigressTTtable', {});
            injectDOM('td', elt+'VoltTitle', elt+'Volt', {'style':'text-align:right;', 'innerHTML':window.parameters.monitorValues[0]});
            injectDOM('td', 'spacer', elt+'Volt', {'style':'width:10px;'});
            injectDOM('td', elt+'Ahv', elt+'Volt', {'innerHTML':((dataBus.HPGe[eltName1].HV < 0xDEADBEEF) ? dataBus.HPGe[eltName1].HV.toFixed(0) + ' ' + window.parameters.subdetectorUnit[0] : 'Not Reporting')});
            injectDOM('td', 'spacer', elt+'Volt', {'style':'width:50px;'});
            injectDOM('td', elt+'Bhv', elt+'Volt', {'innerHTML':((dataBus.HPGe[eltName1].HV < 0xDEADBEEF) ? dataBus.HPGe[eltName2].HV.toFixed(0) + ' ' + window.parameters.subdetectorUnit[0] : 'Not Reporting')});

            injectDOM('tr', elt+'Threshold', 'tigressTTtable', {});
            injectDOM('td', elt+'ThresholdTitle', elt+'Threshold', {'style':'text-align:right;', 'innerHTML':window.parameters.monitorValues[1]});
            injectDOM('td', 'spacer', elt+'Threshold', {'style':'width:10px;'});
            injectDOM('td', elt+'Athreshold', elt+'Threshold', {'innerHTML':((dataBus.HPGe[eltName1].threshold < 0xDEADBEEF) ? dataBus.HPGe[eltName1].threshold.toFixed(0) + ' ' + window.parameters.subdetectorUnit[1] : 'Not Reporting')});
            injectDOM('td', 'spacer', elt+'Threshold', {'stlye':'width:50px;'});
            injectDOM('td', elt+'Bthreshold', elt+'Threshold', {'innerHTML':( (dataBus.HPGe[eltName2].threshold < 0xDEADBEEF) ? dataBus.HPGe[eltName2].threshold.toFixed(0) + ' ' + window.parameters.subdetectorUnit[1] : 'Not Reporting')});

            injectDOM('tr', elt+'Rate', 'tigressTTtable', {});
            injectDOM('td', elt+'RateTitle', elt+'Rate', {'style':'text-align:right;', 'innerHTML':window.parameters.monitorValues[2]});
            injectDOM('td', 'spacer', elt+'Rate', {'style':'width:10px;'});
            injectDOM('td', elt+'Arate', elt+'Rate', {'innerHTML':( (dataBus.HPGe[eltName1].rate < 0xDEADBEEF) ? dataBus.HPGe[eltName1].rate.toFixed(0) + ' ' + window.parameters.subdetectorUnit[2] : 'Not Reporting')});
            injectDOM('td', 'spacer', elt+'Rate', {'style':'width:50px;'});
            injectDOM('td', elt+'Brate', elt+'Rate', {'innerHTML':( (dataBus.HPGe[eltName2].rate < 0xDEADBEEF) ? dataBus.HPGe[eltName2].rate.toFixed(0) + ' ' + window.parameters.subdetectorUnit[2] : 'Not Reporting')});

            if(i!=3){
                injectDOM('tr', elt+'divider', 'tigressTTtable', {});
                injectDOM('td', elt+'line', elt+'divider', {'style':'border-bottom-style:solid; border-color:white; border-width:1px;', 'colspan':5});
            }   

        }
    }

}

//handle clicks on the subsystem spectrum menu
function clickSubsystemSpectrum(){
    var inputField = document.getElementById('subsystemSpectrumName'),
        loadButton = document.getElementById('loadSpectrumName');

    inputField.value = this.innerHTML;
    loadButton.onclick();
}









TIPwall.prototype = Object.create(Subsystem.prototype);

function TIPwall(){
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'TIPwall';
    var that = this;
    Subsystem.call(this);
    this.dataBus = new TIPwallDS();
    //make a pointer at window level back to this object, so we can pass by reference to the nav button onclick
    window.TIPwallpointer = that;
    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['TIPwall'];

    //drawing parameters
    //general
    this.centerX = this.canvasWidth/2;
    this.centerY = this.canvasHeight*0.4;
    this.lineWeight = 1;

    //CsI
    this.CsIy0 = this.canvasHeight*0.1;
    this.CsIcellSide = this.canvasHeight*0.12;
    this.CsIx0 = this.canvasWidth/2 - 2.5*this.CsIcellSide;

    document.getElementById('TIPwalllink').innerHTML = 'TIP Wall';

    //member functions///////////////////////////////////////////////////////////////////

    this.draw = function(frame){
    	var key, iAdj, i;

        this.context.strokeStyle = '#999999';
        this.context.lineWidth = this.lineWeight;

        //CsI wall:
        //once for display canvas...
        for(key in this.dataBus.TIPwall){
            iAdj = this.dataBus.TIPwall[key].index;
            if (iAdj>11) iAdj++;

            fill = colors(key, this.dataBus.TIPwall, frame, this.nFrames);
            this.context.fillStyle =  (fill == 0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;

            this.context.fillRect(this.CsIx0 + this.CsIcellSide*(iAdj%5), this.CsIy0 + this.CsIcellSide*Math.floor(iAdj/5), this.CsIcellSide, this.CsIcellSide);
            this.context.strokeRect(this.CsIx0 + this.CsIcellSide*(iAdj%5), this.CsIy0 + this.CsIcellSide*Math.floor(iAdj/5), this.CsIcellSide, this.CsIcellSide);

    	}
        if(!this.TTlayerDone){
        //...and again for tt encoding:
            for(key in this.dataBus.TIPwall){
                i = this.dataBus.TIPwall[key].index;
                iAdj = i;
                if (iAdj>11) iAdj++;

                this.TTcontext.fillStyle = 'rgba('+i+','+i+','+i+',1)';
                this.TTcontext.fillRect(Math.round(this.CsIx0 + this.CsIcellSide*(iAdj%5)), Math.round(this.CsIy0 + this.CsIcellSide*Math.floor(iAdj/5)), Math.round(this.CsIcellSide), Math.round(this.CsIcellSide));
            }
            this.TTlayerDone = 1;
        }

        this.drawScale(this.context, frame);
    };

    //do an initial populate:
    //this.update();
}

TIPball.prototype = Object.create(Subsystem.prototype);

function TIPball(){
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'TIPball';
    var that = this;
    Subsystem.call(this);
    this.dataBus = new TIPballDS();
    //make a pointer at window level back to this object, so we can pass by reference to the nav button onclick
    window.TIPballpointer = that;
    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['TIPball'];

    //member variables
    this.detsPerRing = [4,6,12,16,20,18,18,14,12,8];  //how many detectors are in each ring?
    this.ringTheta = [8, 17.5, 33, 48.5, 64, 79.5, 95, 111.9, 130.2, 148.5]; //average theta for each ring

    //drawing parameters
    this.cellSide = this.canvasWidth/25;
    this.gutterWidth = (0.9*(this.canvasHeight - this.scaleHeight) - 10*this.cellSide)/11; //this.cellSide*0.2;
    this.rowTop = 0.05*this.canvasHeight;  //incremented for each row.
    this.context.strokeStyle = '#999999';
    this.TTcontext.strokeStyle = '#987654';
    this.context.lineWidth = this.lineWeight;

    document.getElementById('TIPballlink').innerHTML = 'TIP Ball';

    //member functions///////////////////////////////////////////////////////////////////

    this.draw = function(frame){
        var i, j, index=0;

        if(frame==0) {
            this.context.clearRect(0,0,this.canvasWidth, this.canvasHeight-this.scaleHeight)
            this.context.textBaseline = 'top';
            this.context.font = '16px Raleway';
            this.context.fillStyle = '#999999';
            this.context.fillText('Av. Theta:', this.gutterWidth, 0);  //String.fromCharCode(0x03B8)
            this.context.fillText('Ring No.', this.canvasWidth - this.gutterWidth - this.context.measureText('Ring No.').width, 0);
        }

        for(i=0; i<this.detsPerRing.length; i++){
            for(j=0; j<this.detsPerRing[i]; j++){
                this.context.fillStyle = colors(this.dataBus.TTmap[this.DAQmap(index)], this.dataBus.TIPball, frame, this.nFrames);
                fill = colors(this.dataBus.TTmap[this.DAQmap(index)], this.dataBus.TIPball, frame, this.nFrames);
                this.context.fillStyle =  (fill == 0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;
                //draw dashboard:
                this.context.fillRect(this.canvasWidth/2 - this.cellSide*this.detsPerRing[i]/2 + this.cellSide*j, this.rowTop, this.cellSide, this.cellSide);
                this.context.strokeRect(this.canvasWidth/2 - this.cellSide*this.detsPerRing[i]/2 + this.cellSide*j, this.rowTop, this.cellSide, this.cellSide);

                //and for the tooltip:
                if(!this.TTlayerDone){
                    this.TTcontext.fillStyle = 'rgba('+this.DAQmap(index)+','+this.DAQmap(index)+','+this.DAQmap(index)+',1)';
                    this.TTcontext.fillRect(this.canvasWidth/2 - this.cellSide*this.detsPerRing[i]/2 + this.cellSide*j, this.rowTop, this.cellSide, this.cellSide);
                    this.TTcontext.strokeRect(this.canvasWidth/2 - this.cellSide*this.detsPerRing[i]/2 + this.cellSide*j, this.rowTop, this.cellSide, this.cellSide);
                }

                index++;
            
            }
            //labels:
            if(frame==0){
                this.context.textBaseline = 'middle';
                this.context.font = '16px Raleway'
                this.context.fillStyle = '#999999';
                this.context.fillText(this.ringTheta[i].toFixed(1)+String.fromCharCode(0x00B0), this.gutterWidth, this.rowTop+this.cellSide/2);
                this.context.fillText(i, this.canvasWidth - this.gutterWidth - this.context.measureText(i).width, this.rowTop+this.cellSide/2);
            } 

            //move down to the next row:
            this.rowTop += this.cellSide + this.gutterWidth;
            //Ring 0 is a bit extra offset:
            if(i==0) this.rowTop += 2*this.gutterWidth;
        }
        this.rowTop = 0.05*this.canvasHeight;
        this.TTlayerDone = 1;

        if(frame==0 || frame == this.nFrames){
            this.context.textBaseline = 'alphabetic'
            this.drawScale(this.context, frame);
        }
    };

    //this.draw indexes each cell starting from 0 and counting up along each ring, starting from ring 0;
    //this function takes that index, and maps it onto the dataBus index for the channel that should be in that position.
    this.DAQmap = function(index){
        return index+1;
    };

    //do an initial populate:
    //this.update();
}


/*
//paper JS imlementation
function TIPwall(){
    var that = this;
    window.TIPwallpointer = that;
    this.dataBus = new TIPwallDS();
    this.name = 'TIPwall';
    this.linkWrapperID = 'SubsystemLinks';
    this.topNavID = 'SubsystemsButton';

    //insert nav link
    injectDOM('button', this.name+'link', this.linkWrapperID, {
        'class' : 'navLink',
        'onclick' : function(){swapFade(this.id, this.parentPointer, window.subsystemScalars); rePaint();},
        'innerHTML' : this.name,
        'type' : 'button'
    });
    document.getElementById(this.name+'link').parentPointer = this;

    //scale canvas
    this.monitor = document.getElementById(window.parameters.wrapper);
    this.canvasWidth = 0.48*$(this.monitor).width();
    this.canvasHeight = 0.8*$(this.monitor).height();
    //detector view
    injectDOM('canvas', 'paperTIPcanvas', window.parameters.wrapper, {
        'class':'monitor', 
        'style':'top:' + ($('#SubsystemLinks').offset().top + $('#SubsystemLinks').height()*1.25 + 5) +'px;'
    });


    //inject paperScript
    injectDOM('script', 'TIPpaper', 'body', {
        'type' : 'text/paperscript',
        'canvas' : 'paperTIPcanvas',
        'innerHTML' : 'deployTIP()'
    });


    deployTIP();

    this.update = function(){};
    this.view = function(){
        return 'paperTIPcanvas';
    };
}

function summonTooltip(x, y){
    var tt = document.getElementById('paperTooltip');
    tt.style.display = 'block';
    tt.style.left = x+'px';
    tt.style.top = y+'px';
}

function dismissTooltip(){
    var tt = document.getElementById('paperTooltip');
    tt.style.display = 'none';          
}

function deployTIP(){
    var dataBus = window.TIPwallpointer.dataBus,
        key, iAdj, origin,
        paths = [];

    for(key in dataBus.TIPwall){
        iAdj = dataBus.TIPwall[key].index;
        if(iAdj>11) iAdj++;

        paths[paths.length] = new Path();
        paths[paths.length-1].closed = true;
        origin = new Point(this.CsIx0 + this.CsIcellSide*(iAdj%5), this.CsIy0 + this.CsIcellSide*Math.floor(iAdj/5));
        paths[paths.length-1].add(  origin, 
                                    new Point(origin.x+this.CsIcellSide, origin.y), 
                                    new Point(origin.x+this.CsIcellSide, origin.y+this.CsIcellSide), 
                                    new Point(origin.x, origin.y+this.CsIcellSide) );
        paths[paths.length-1].fillColor = '#FFFFFF';
        paths[paths.length-1].strokeStyle = '#000000';
        path.channel = key;
    }

            var path = new Path();
            path.closed = true;
            path.add(new Point(100,100), new Point(150, 100), new Point(150, 150), new Point(100,150));
            path.fillColor = '#FF0000';
            path.channel = 'DESCANT-0';
            var finalColor = 'rgba(255,255,255,1)',
                currentColor = 'rgba(0,0,0,1)',
                frame = 0;

            var path2 = new Path();
            path2.closed = true;
            path2.add(new Point(200,200), new Point(250, 200), new Point(250, 250), new Point(200,250));
            path2.fillColor = '#00FF00';
            path2.channel = 'DESCANT-1';

    function onMouseMove(event) {
        project.activeLayer.selected = false;
        if (event.item){
            event.item.selected = true;
            document.getElementById('tooltip').innerHTML = event['_item'].channel;
            summonTooltip(event.event.clientX, event.event.clientY);
        } else
            dismissTooltip();
    }

    console.log('loaded paper')
};
*/function VME(){
	var VMEStyle, string, cellSize, that = this;
	window.VMEpointer = that;

	//member variables
	this.wrapperID = window.parameters.wrapper;	    //ID of wrapping div
	this.canvasID = 'VMECanvas';		            //ID of canvas to paint clock on
    this.linkWrapperID = 'VMELinks';                //ID of div to contain clock view header
    this.sidebarID = 'VMESidebar';                  //ID of div to contain clock sidebar
    this.activeElt = 'VME0';

	this.wrapper = document.getElementById(this.wrapperID);

    //add top level nav button:
    injectDOM('button', 'VMEButton', 'statusLink', {
        'class' : 'navLink',
        'innerHTML' : 'VME',
        'onclick' : function(){swapView('VMELinks', 'VMECanvas', 'VMEMenus', 'VMEButton');}
    });

    //deploy right bar menu:
    deployMenu('VMEMenus', ['VME'] , ['Crate Summary']);
    //insert a table and maybe some buttons into the right bar
    string = '';
    string += '<h3 id="VMEContentTitle" style="text-align:center; margin-top:0px;">VME 0</h3>\n'
    string += '<table id="VMEContentTable">\n';
    string +=     '<tr id="VMEContentTitle">\n';
    string +=         '<td></td>\n';
    string +=         '<td>Voltage [V]</td>\n';
    string +=         '<td style="padding-left:1em;">Current [A]</td>\n';
    string +=     '</tr>\n';
    string +=     '<tr>\n'
    string +=         '<td>+12 V</td>\n'
    string +=         '<td id="p12voltage" class="VMEContentCell">0</td>\n'
    string +=         '<td id="p12current" class="VMEContentCell">0</td>\n'
    string +=     '</tr>\n';
    string +=     '<tr>\n'
    string +=         '<td>+5 V</td>\n'
    string +=         '<td id="p5voltage" class="VMEContentCell">0</td>\n'
    string +=         '<td id="p5current" class="VMEContentCell">0</td>\n'
    string +=     '</tr>\n';
    string +=     '<tr>\n'
    string +=         '<td>+3.3 V</td>\n'
    string +=         '<td id="p3voltage" class="VMEContentCell">0</td>\n'
    string +=         '<td id="p3current" class="VMEContentCell">0</td>\n'
    string +=     '</tr>\n';
    string +=     '<tr>\n'
    string +=         '<td>-12 V</td>\n'
    string +=         '<td id="n12voltage" class="VMEContentCell">0</td>\n'
    string +=         '<td id="n12current" class="VMEContentCell">0</td>\n'
    string +=     '</tr>\n';
    string += '</table>\n';
    string += '<table id="VMEContentTable2">\n';
    string +=     '<tr>\n'
    string +=         '<td>Fan Temp</td>\n'
    string +=         '<td id="fanTemp" class="VMEStatusCell">0 '+String.fromCharCode(0x00B0)+'F</td>\n'
    string +=     '</tr>\n';
    string +=     '<tr>\n'
    string +=         '<td>Fan Speed</td>\n'
    string +=         '<td id="fanSpeed" class="VMEStatusCell">0 rpm</td>\n'
    string +=     '</tr>\n';
    string +=     '<tr>\n'
    string +=         '<td>PS Time</td>\n'
    string +=         '<td id="psTime" class="VMEStatusCell">0 hrs</td>\n'
    string +=     '</tr>\n';
    string +=     '<tr>\n'
    string +=         '<td>Fan Time</td>\n'
    string +=         '<td id="fanTime" class="VMEStatusCell">0 hrs</td>\n'
    string +=     '</tr>\n';
    string += '</table>\n';

    document.getElementById('VMEContent').innerHTML = string;
    injectDOM('button', 'VMEContentPwrCycle', 'VMEContent', {
        'class' : 'bigButton',
        'style' : 'width:auto; height:auto; padding:0.5em; margin-top:1em;',
        'innerHTML' : 'Power Cycle',
        'type' : 'button',
        'onclick' : function(){
            confirm('Confirm VME Power Cycle', 'Confirming will power cycle VME ' + window.VMEpointer.activeElt.slice(3, window.VMEpointer.activeElt.length) + '; are you sure you want to do this?', powerCycleVME.bind(null,window.VMEpointer.activeElt));
            document.getElementById('tempDiv').style.top = window.innerHeight*0.2;
        }
    });
    document.getElementById('VMEContent').style.textAlign = 'center';

    //nav wrapper div
    injectDOM('div', this.linkWrapperID, this.wrapperID, {
        'class' : 'navPanel',
        'style' : 'text-align:center; width:50%; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;'
    });
    //nav header
    injectDOM('h1', 'VMELinksBanner', this.linkWrapperID, {
        'class':'navPanelHeader', 
        'style':'float:left; margin-top:0px;',
        'innerHTML':ODB.topLevel.expName+' VME Status'
    });

    //the VME view is done entirely with dom elements; most convenient to extend the central div to accommodate.
    cellSize = document.getElementById(this.linkWrapperID).offsetWidth / 100;
    //VME divs
    injectDOM('div', 'VMEWrapper', this.linkWrapperID, {'style':'clear:left;'});
    for(i=0; i<window.parameters.nVME; i++){
        VMEStyle = 'display:inline-block; margin-left:'+(2*cellSize)+'px; margin-right:'+(2*cellSize)+'px; margin-bottom:'+2*cellSize+'px; margin-top:'+2*cellSize+'px;'
        injectDOM('div', 'VME'+i, 'VMEWrapper', {'class':'VME', 'style':VMEStyle, 'onclick':function(){showVME(this.id)}});
        injectDOM('div', 'VME'+i+'title', 'VME'+i, {'innerHTML':'VME'+i});
        if(i%4==3)
            injectDOM('br', 'break', 'VMEWrapper', {});
    }

	//deploy a canvas for the clock view; this is actually just a dummy to stay consistent with all the other views, so we can use the same transition functions easily.
    injectDOM('canvas', this.canvasID, this.wrapperID, {'class':'monitor', 'style':'top:' + ($('#VMELinks').height() + 5) +'px;'});

    this.update = function(){

    	//update sidebar with whatever clock is showing:
    	showVME(this.activeElt);

    };
    this.update();
    document.getElementById('VMEarrow').onclick();
}

function showVME(id){
	glowMe.apply(window.VMEpointer, [id]);

    //keep track of which clock is highlit:
    window.VMEpointer.activeElt = id;

    //update table
    document.getElementById('VMEContentTitle').innerHTML = 'VME' + id.slice(3,id.length);
}

function powerCycleVME(id){
	//turn VME off

	//turn VME back on again.
}













function Waffle(InputLayer, headerDiv, AlarmServices){

    	var i, j, k, n, columns;

        //pointer voodoo:
        var that = this;
        //make a pointer at window level back to this object, so we can pass by reference to the nav button onclick
        window.HVpointer = that;

        window.HVview = 0; //index of which crate is currently on display in the HV view.
        this.nCrates = window.parameters.moduleSizes.length;

        //columns for HV monitor:
        this.cols = [];
        for(i=0; i<this.nCrates; i++){
          window.parameters.columns[i] = 0;
          for(j=0; j<window.parameters.moduleSizes[i].length; j++){
            window.parameters.columns[i] += window.parameters.moduleSizes[i][j];
            if (window.parameters.moduleSizes[i][j] == 0) window.parameters.columns[i]++;
          }
          this.cols[i] = window.parameters.columns[i];
        }

        //member data:
        this.rows = window.parameters.rows + 1;     //number of rows in the waffle; +1 for primary row
        this.canvasID = [];                         //canvas ID to draw the waffles on
        this.prevAlarmStatus = [];                       //previous iteration's alarmStatus
        this.alarmStatus = [];                           //3D array containing the alarm level for each cell [mainframe][row][column] = alarm level
        this.wrapperDiv = window.parameters.wrapper;//div ID of top level div
        this.InputLayer = InputLayer;               //div ID of wrapper for input fields  TODO: resundant with sidebarID
        //this.headerDiv = headerDiv;                 //div ID of waffle header  TODO: depricated?
        this.chx = 0;                               //x channel of input sidebar focus
        this.chy = 1;                               //y channel of input sidebar focus
        this.linkWrapperID = 'mainframeLinks';      //ID of div containing nav links
        this.topNavID = 'HVmonitorButton';
        this.sidebarID = 'InputLayer';
        this.monitor = document.getElementById(this.wrapperDiv);
        this.AlarmServices = AlarmServices;         //Alarm serivce object the waffle will fire events at
        this.dataBus = [];
        for(i=0; i<this.nCrates; i++){
            this.dataBus[i] = new HVDS(this.rows, this.cols[i]);  //data structure to manage info.
        }
        this.viewStatus = -1;                       //indicates which view is on top: -1=summary, n>-1=bar chart n.  TODO: redundant with window.HVview?
        this.canvas = [];
        this.context = [];
        //index address of where the input panel is pointing:
        this.dialogX;
        this.dialogY;
        //prefix / postfix text to use in HV tooltip:
        this.prefix = ["Demand Voltage: ", "Reported Voltage: ", "Reported Current: ", "Voltage Ramp Up Speed: ", "Voltage Ramp Down Speed", "Temperature: ", "Status: "],
        this.postfix = ["V", "V", "uA", "V/s", "V/s", "C", ""],
        //fill meter limits:
        this.currentMin = 0;
        this.currentMax = 1;
        this.temperatureMin = 0;    


        //make sure the waffle is pointing at a channel that actually has something in it before the initial populate:
        i=0;
        while(window.parameters.moduleSizes[window.HVview][i] == 0) i++;
        this.chx = i;

        //generate the canvas IDs:
        for (i=0; i<this.nCrates; i++){
            this.canvasID[i] = 'HVgrid'+i;
        }

        //deploy the sidebar
        this.deploySidebar = function(){

            //wrapper div
            injectDOM('div', this.sidebarID, this.wrapperDiv, {'class':'RightSidebar'});
            document.getElementById(this.sidebarID).setAttribute('align', 'left');

            //title
            injectDOM('h2', 'inputTitle', this.sidebarID, {'style':'margin-left:10%; margin-top:25px; font-family: "Orbitron", sans-serif;', 'innerHTML':'Sin Titulo'});
            document.getElementById('inputTitle').setAttribute('align', 'left');

            //input form
            injectDOM('form', 'setValues', this.sidebarID, {'style':'margin-bottom:0px;'});

            //on/off radios:
            injectDOM('input', 'offButton', 'setValues', {
                'style' : 'margin-left:10%; margin-bottom:10px',
                'name' : 'HVswitch',
                'type' : 'radio',
                'value' : 'off'
            });
            injectDOM('p', 'offSwitch', 'setValues', {'style':'display:inline', 'innerHTML':'Off'});
            injectDOM('input', 'onButton', 'setValues', {
                'style' : 'margin-left:2%; margin-bottom:10px; display:inline;',
                'name' : 'HVswitch',
                'type' : 'radio',
                'value' : 'on'
            });
            injectDOM('p', 'onSwitch', 'setValues', {'style':'display:inline', 'innerHTML':'On'});
            //submit updates:
            injectDOM('input', 'submitParameters', 'setValues', {
                'class' : 'bigButton',
                'style' : 'z-index:10000',
                'onclick' : function(){updateParameter()},
                'type' : 'button',
                'value' : 'Commit'
            });
            document.getElementById('submitParameters').setAttribute('disabled', 'true');

            //status report:
            injectDOM('p', 'status', 'setValues', {'style':'margin-left:10%', 'innerHTML':'Status:'});

            //voltage fill meter
            injectDOM('p', 'voltageMeterTitle', 'setValues', {
                'style' : 'margin-left:10%; margin-bottom:0px; display:inline; position:relative; top:-18px;',
                'innerHTML' : 'Voltage [V]'
            });
            injectDOM('canvas', 'voltageMeter', 'setValues', {'style':'margin-left:2px', 'align':'right'});
            //current fill meter
            injectDOM('p', 'currentMeterTitle', 'setValues', {
                'style' : 'margin-left:10%; margin-bottom:0px; display:inline; position:relative; top:-18px;',
                'innerHTML' : 'Current [uA]'
            });
            injectDOM('canvas', 'currentMeter', 'setValues', {'style':'margin-left:2px;', 'align':'right'});
            //temperature fill meter
            injectDOM('p', 'temperatureMeterTitle', 'setValues', {
                'style' : 'margin-left:10%; margin-bottom:0px; display:inline; position:relative; top:-18px;',
                'innerHTML' : 'Temperature [C]'
            });                    
            injectDOM('canvas', 'temperatureMeter', 'setValues', {'stlye':'margin-left2px', 'align':'right'});

            //demand voltage
            injectDOM('p', 'FieldText', 'setValues', {'style':'margin-left:10%', 'innerHTML':'Demand Voltage [V]'});
            injectDOM('input', 'demandVoltage', 'setValues', {
                'style' : 'margin-bottom:10px; margin-top: 5px; margin-left:10%; margin-right:5%;',
                'name' : 'textbox',
                'type' : 'text',
                'value' : 'default',
                'size' : '6'
            });
            injectDOM('div', 'voltageSlider', 'setValues', {'class':'slider'});
            //demand voltage ramp up
            injectDOM('p', 'RampText', 'setValues', {'style':'margin:0px; margin-left:10%; margin-top:20px;', 'innerHTML':'Voltage Ramp Up Speed [V/s]'});
            injectDOM('input', 'demandRampSpeed', 'setValues', {
                'style' : 'margin-bottom:10px; margin-top: 5px; margin-left:10%; margin-right:5%;',
                'name' : 'textbox',
                'type' : 'text',
                'value' : 'default',
                'size' : '6'
            });
            injectDOM('div', 'rampSlider', 'setValues', {'class':'slider'});
            //demand voltage ramp down
            injectDOM('p', 'RampTextDown', 'setValues', {'style':'margin:0px; margin-left:10%; margin-top:20px;', 'innerHTML':'Voltage Ramp Down Speed [V/s]'});
            injectDOM('input', 'demandRampDownSpeed', 'setValues', {
                'style' : 'margin-bottom:10px; margin-top: 5px; margin-left:10%; margin-right:5%;',
                'name' : 'textbox',
                'type' : 'text',
                'value' : 'default',
                'size' : '6'
            });
            injectDOM('div', 'rampDownSlider', 'setValues', {'class':'slider'});

            //space canvas:
            injectDOM('canvas', 'inputSpacer', this.sidebarID, {'style' : 'margin-left:10%; margin-top:5%;', 'width':'200px', 'height':'5px'});
            //draw on the canvas:
            var ILcanvas = document.getElementById('inputSpacer');
            var ILcontext = ILcanvas.getContext('2d');
            ILcontext.strokeStyle = 'rgba(255,255,255,0.9)'
            ILcontext.beginPath();
            ILcontext.moveTo(0,0);
            ILcontext.lineTo(200,0);
            ILcontext.stroke();

            //channel changing form:
            injectDOM('form', 'changeChannel', this.sidebarID, {});
            //title
            injectDOM('h4', 'ccTitle', 'changeChannel', {'style':'margin-left:10%; margin-bottom:10px;', 'innerHTML':'Change Channel:'});
            //cards:
            injectDOM('p', 'cardTitle', 'changeChannel', {'style':'display:inline; margin-left:10%; margin-right:1%', 'innerHTML':'Card'});
            injectDOM('select', 'CardList', 'changeChannel', {'style':'width:80px;'});
            injectDOM('br', 'break', 'changeChannel', {});
            //channels:
            injectDOM('p', 'channelTitle', 'changeChannel', {
                'style' : 'display:inline; margin-left:10%; position:relative; top:-20px; margin-right:1%;',
                'innerHTML' : 'Channel'
            });
            injectDOM('select', 'ChannelList', 'changeChannel', {'style':'width:80px; position:relative; top:-20px;'});
            //submit button:
            injectDOM('input', 'getChannelButton', 'changeChannel', {
                'class' : 'link',
                'style' : 'position:relative; top:-30px; width: 50px; height:50px; font-size:24px; margin-left:3%; margin-top:10px; border-color:black',
                'type' : 'button',
                'value' : 'Go',
                'onclick' : function(){window.refreshInput = 1; gotoNewChannel(event, window.HVpointer);}
            });
        };

        //deploy a sidebar to interact with this element:
        this.deploySidebar();

        //deploy some sliders in the sidebar  TODO: push into deploySidebar()?
        var sliderWidth = parseFloat($(document.getElementById('InputLayer')).width())*0.5;
        this.voltageSlider = new Slider(this.sidebarID, 'volageSliderText', 'demandVoltage', 'voltageSlider', 'voltageSliderBKG', 'voltageSliderKnob', 'voltageKnobStyle', 'voltageSliderText', ODB.HV.demandVoltage[0], ODB.HV.demandVoltage[1], window.parameters.statusPrecision, window.parameters.voltUnit, sliderWidth );
        this.rampSlider = new Slider(this.sidebarID, 'rampSliderText', 'demandRampSpeed', 'rampSlider', 'rampSliderBKG', 'rampSliderKnob', 'rampKnobStyle', 'rampSliderText', ODB.HV.voltRampSpeed[0], ODB.HV.voltRampSpeed[1], window.parameters.statusPrecision, window.parameters.rampUnit,  sliderWidth);
        this.rampDownSlider = new Slider(this.sidebarID, 'rampDownSliderText', 'demandRampDownSpeed', 'rampDownSlider', 'rampDownSliderBKG', 'rampDownSliderKnob', 'rampDownKnobStyle', 'rampDownSliderText', ODB.HV.voltRampSpeed[0], ODB.HV.voltRampSpeed[1], window.parameters.statusPrecision, window.parameters.rampUnit,  sliderWidth);

        //fill meters  TODO: put these on the waffle object instead of window?
        window.meter = new FillMeter('voltageMeter', 'InputLayer', 0, ODB.HV.demandVoltage[0], ODB.HV.demandVoltage[1], window.parameters.voltUnit, window.parameters.statusPrecision);
        window.currentMeter = new FillMeter('currentMeter', 'InputLayer', 0, this.currentMin, this.currentMax, window.parameters.currentUnit, window.parameters.statusPrecision);
        window.temperatureMeter = new FillMeter('temperatureMeter', 'InputLayer', 0, this.temperatureMin, ODB.HV.tempTolerance, window.parameters.temperatureUnit, window.parameters.statusPrecision);

        //determine dimesions of canvas:
        this.totalWidth = Math.round(0.5*$('#'+this.wrapperDiv).width());
        //cell dimensions controlled by total width, since width more visually important here:
        this.cellSide = [];
        this.totalHeight = [];
        for(i=0; i<this.nCrates; i++){
            this.cellSide[i] = (this.totalWidth - 60) / Math.max(20, this.cols[i]);
            this.totalHeight[i] = 16*this.cellSide[i];
        }

        //DOM insertions////////////////////////////////////
        //inject top level nav button
        injectDOM('button', this.topNavID, 'statusLink', {
            'class' : 'navLink',
            'innerHTML' : 'HV Monitor',
            'onclick' : function(){
                swapView(window.HVpointer.linkWrapperID, 'HVgrid0', 'InputLayer', window.HVpointer.topNavID); 
                rePaint();
            }
        });

        //header
        injectDOM('div', this.linkWrapperID, this.wrapperDiv, {'class':'navPanel'});
        //title
        injectDOM('h1', this.linkWrapperID+'Banner', this.linkWrapperID, {'class':'navPanelHeader', 'innerHTML':ODB.topLevel.expName+' HV Mainframes'});
        injectDOM('br', 'break', this.linkWrapperID, {});
        //mainframe navigation
        for(i=0; i<this.nCrates; i++){
            injectDOM('button', 'Main'+(i+1), this.linkWrapperID, {
                'class' : (i==0)? 'navLinkDown' : 'navLink',
                'innerHTML' : 'Mainframe '+(i+1),
                'onclick' : function(){swapHVmainframe(this.crate); rePaint();}
            });
            document.getElementById('Main'+(i+1)).crate = i;
        }
        injectDOM('br', 'break', this.linkWrapperID, {});
        //card navigation
        for(i=0; i<this.nCrates; i++){
            injectDOM('div', this.linkWrapperID+i, this.linkWrapperID, {'class':'cardNavPanel'});
            for(j=0; j<window.parameters.moduleSizes[i].length; j++){
                injectDOM('button', 'crate'+i+'card'+j, this.linkWrapperID+i, {
                    'class' : 'navLink',
                    'innerHTML' : 'Slot '+j,
                    'type' : 'button',
                    'onclick' : function(){barChartButton(this)}
                });
                document.getElementById('crate'+i+'card'+j).cardNumber = j;
            }

            //inject canvas into DOM for waffle to paint on:
            injectDOM('canvas', this.canvasID[i], this.wrapperDiv, {
                'class' : 'monitor',
                'width' : this.totalWidth,
                'height' : this.totalHeight[i]
            });
            this.canvas[i] = document.getElementById(this.canvasID[i]);
            this.context[i] = this.canvas[i].getContext('2d');

        }

        //finished DOM insertions//////////////////////////////////////

        //set up module labels:
        this.moduleLabels = [];
        for(i=0; i<16; i++){
            this.moduleLabels[i] = 'Slot ' + i;
        }

        //adjust height to accommodate card and module labels:
        for(i=0; i<this.nCrates; i++){
            this.context[i].font = Math.min(16, this.cellSide[i])+'px Raleway';
            this.longestModuleLabel = 0;
            for(j = 0; j<window.parameters.moduleSizes[i].length; j++){
                this.longestModuleLabel = Math.max(this.longestModuleLabel, this.context[i].measureText(this.moduleLabels[j]).width);
            }
            this.totalHeight[i] += this.longestModuleLabel + 50;
            this.canvas[i].setAttribute('height', this.totalHeight[i]);
        }

        //waffle dimensions; leave gutters for labels & title
        this.waffleWidth = [];
        this.waffleHeight = [];
        this.leftEdge = [];
        for(i=0; i<this.nCrates; i++){
            this.waffleWidth[i] = this.cellSide[i]*this.cols[i];
            this.waffleHeight[i] = this.totalHeight[i];
            //want waffle and navbar centered nicely:
            this.leftEdge[i] = (this.totalWidth - (this.waffleWidth[i] + 1.5*this.context[i].measureText('Prim').width))/2;
            //push navbar over to match:
            document.getElementById(this.linkWrapperID).setAttribute('style', 'left:'+(24 + 100*this.leftEdge[i]/$('#'+this.wrapperDiv).width() )+'%;');
        }

        //make a tooltip for each crate:
        this.tooltip = [];
        for(i=0; i<this.nCrates; i++){
            this.tooltip[i] = new Tooltip(this.canvasID[i], 'MFTT'+i, this.wrapperDiv, this.prefix, this.postfix);
            //give the tooltip a pointer back to this object:
            this.tooltip[i].obj = that;
            //tooltip looks for members canvasWidth and canvasHeight to make sure its in a valid place:
            this.canvasWidth = document.getElementById(this.canvasID[0]).width;
            this.canvasHeight = document.getElementById(this.canvasID[0]).height;
        }

        //establish animation parameters:
        this.FPS = 30;
        this.duration = 0.5;
        this.nFrames = this.FPS*this.duration;

        //style card nav buttons
        var newRule;
        for(j=0; j<this.nCrates; j++){
            for(i=0; i<window.parameters.moduleSizes[j].length; i++){
                var buttonWidth, fontsize;
                buttonWidth = Math.max(window.parameters.moduleSizes[j][i],1)*0.9*this.cellSide[j] + (Math.max(window.parameters.moduleSizes[j][i],1)-1)*0.1*this.cellSide[j];
                if(window.parameters.moduleSizes[j][i] == 4) fontsize = 0.9*this.cellSide[j]*0.5;
                else fontsize = 0.9*this.cellSide[j]*0.3;

                if(window.parameters.moduleSizes[j][i] != 0)
                    newRule = "width:"+buttonWidth+"px; height:"+0.9*this.cellSide[j]+"px; margin-right:"+0.05*this.cellSide[j]+"px; margin-left:"+0.05*this.cellSide[j]+"px; margin-top:"+0.05*this.cellSide[j]+"px; float:left; border-radius: 5px; display: inline; font-family: 'Raleway', sans-serif; font-size:"+fontsize+"px; padding:0px;";
                else{ 
                    newRule = "width:"+buttonWidth+"px; height:"+0.9*this.cellSide[j]+"px; margin-right:"+0.05*this.cellSide[j]+"px; margin-left:"+0.05*this.cellSide[j]+"px; margin-top:"+0.05*this.cellSide[j]+"px; float:left; border-radius: 5px; display: inline; font-family: 'Raleway', sans-serif; font-size:"+this.cellSide[j]/2+"px; padding:0px; color:#CC0000;";
                    document.getElementById('crate'+j+'card'+i).setAttribute('onclick', '');
                    document.getElementById('crate'+j+'card'+i).innerHTML = 'X'
                }
                document.getElementById('crate'+j+'card'+i).setAttribute('style', newRule);
            }
        }

        document.getElementById(this.linkWrapperID+0).style.display = 'block';
        //header size:
        this.headerHeight = [];
        for(i=0; i<this.nCrates; i++){
            document.getElementById(this.linkWrapperID+i).style.display = 'block';
            this.headerHeight[i] = $('#'+this.linkWrapperID).height();
            document.getElementById(this.linkWrapperID+i).style.display = 'none';
            //make the vertical spacing between the waffle and nav header nice:
            $('#'+this.canvasID[i]).css('top', ( $('#mainframeLinks').offset().top + (this.headerHeight[i])+5)+'px !important;' );
        }
        //turn top crate's slot navigation on:
        document.getElementById(this.linkWrapperID+window.HVview).style.display = 'block';


        //declare bar charts & canvases to paint them on:
        this.barCharts = [];
        var newCanvas;
        for(j=0; j<this.nCrates; j++){
            this.barCharts[j] = [];
            for(i=0; i<window.parameters.moduleSizes[j].length; i++){
                injectDOM('canvas', 'crate'+j+'bar'+i, this.wrapperDiv, {
                    'class' : 'monitor',
                    'width' : this.totalWidth,
                    'height' : this.totalHeight[i],
                    'style' : 'top:' + ($('#mainframeLinks').offset().top + $('#mainframeLinks').offset().height +5) + 'px'
                });
                this.barCharts[j][i] = new BarGraph('crate'+j+'bar'+i, i, Math.max(window.parameters.moduleSizes[j][i],1)*12, 'Slot '+i, 'Reported Voltage [V]', 0, window.parameters.scaleMaxima[0], window.parameters.barChartPrecision, that, j);
            }
        }

        //set up arrays:
        this.startColor = [];
        this.endColor = [];
        for(j=0; j<this.nCrates; j++){
            this.startColor[j] = [];
            this.endColor[j] = [];
            for(i=0; i<this.rows; i++){
        	    this.startColor[j][i] = [];
            	this.endColor[j][i] = [];
            }
        }

        //declare alarmStatus and prevAlarmStatus as arrays of appropriate dimension:
        for(k=0; k<this.nCrates; k++){
            this.alarmStatus[k] = [];
            this.prevAlarmStatus[k] = [];
            for(i=0; i<this.rows; i++){
                this.alarmStatus[k][i] = [];
                this.prevAlarmStatus[k][i] = [];
                //primary row spans multi-columns:
                if(i==0) columns = window.parameters.moduleSizes[k].length;
                else columns = this.cols[k];
                for(j=0; j<columns; j++){
                    this.alarmStatus[k][i][j] = [];
                    this.prevAlarmStatus[k][i][j] = [];
                    for(var n=0; n<3; n++){
                        this.alarmStatus[k][i][j][n] = 0;
                        this.prevAlarmStatus[k][i][j][n] = 0;
                    }
                }
            }
        }

        //array of values from the waffle to report in the tooltip
        this.reportedValues = [];
        for(i=0; i<this.nCrates; i++){
            this.reportedValues[i] = [this.dataBus[i].demandVoltage, this.dataBus[i].reportVoltage, this.dataBus[i].reportCurrent, this.dataBus[i].demandVrampUp, this.dataBus[i].demandVrampDown, this.dataBus[i].reportTemperature, this.dataBus[i].rampStatus];
        }

        //make waffles clickable to set a variable for a channel:
        for(i=0; i<this.nCrates; i++){
            this.canvas[i].onclick = function(event){clickWaffle(event, that)};
        }

        //draw the legends on the main views once only:
        this.legendTop = [];
            for(j=0; j<this.nCrates; j++){
                //draw legend:
                this.context[j].strokeStyle = '#000000';
                this.context[j].lineWidth = 2;
                this.legendTop[j] = this.totalHeight[j]*0.85;
                var legendColors = ['rgba(0,255,0,0.3)', 'rgba(255,255,0,0.3)', 'rgba(255,0,0,0.5)', 'rgba(0,0,255,0.5)', 'rgba(0,0,0,0.3)', 'rgba(0,0,0,0.9)'];
                var legendString = ['All OK', 'Ramping', 'Alarm!', 'Ext. Disable', 'Off', 'Absent'];
                for(i = 0; i<6; i++){
                    this.context[j].font = Math.min(16, fitFont(this.context[j], legendString[i], (this.canvasWidth*0.8/6 - this.cellSide[j]*1.1)*0.9  )) + 'px Raleway';
                    this.context[j].fillStyle = '#FFFFFF';
                    this.context[j].fillRect(this.canvasWidth*0.1 + i*this.canvasWidth*0.8/6, this.legendTop[j], this.cellSide[j], this.cellSide[j]);
                    this.context[j].fillStyle = legendColors[i];
                    this.context[j].fillRect(this.canvasWidth*0.1 + i*this.canvasWidth*0.8/6, this.legendTop[j], this.cellSide[j], this.cellSide[j]);
                    this.context[j].strokeRect(this.canvasWidth*0.1 + i*this.canvasWidth*0.8/6, this.legendTop[j], this.cellSide[j], this.cellSide[j]);
                    this.context[j].fillStyle = '#999999';
                    this.context[j].textBaseline = 'middle';
                    this.context[j].fillText(legendString[i], this.canvasWidth*0.1 + i*this.canvasWidth*0.8/6 + this.cellSide[j]*1.1, this.legendTop[j] + this.cellSide[j]/2);
                    this.context[j].textBaseline = 'bottom';
                    
                }
            }
            

        ///////////////////member functions/////////////////////////////////////////////////////////
        //decide which canvas to present:
        this.view = function(){
            if(this.viewStatus == -1)
                return this.canvasID+window.HVview;
            else return 'crate'+window.HVview+'bar'+this.viewStatus;
        };

        //determine per cell color info for start and finish.
        //Color info is packed as four numbers: red, green, blue, alpha
        this.cellColorUpdate = function(crate){
            var R, G, B, A, color, primary;
            for(var i=0; i<this.rows; i++){
                //primary row spans multi-columns:
                if(i==0) columns = window.parameters.moduleSizes[crate].length;
                else columns = this.cols[crate];
            	for(var j=0; j<columns; j++){
                    if(i > 0)
                        primary = primaryBin(window.parameters.moduleSizes[crate],j);
                    else primary = j;

    	         	//start values:
                    //show green on all clear:
    	            if( this.prevAlarmStatus[crate][i][j][0] == 0 && this.prevAlarmStatus[crate][i][j][1] == 0 && this.prevAlarmStatus[crate][i][j][2] == 0){
                        R = 0;
                        G = 255;
                        B = 0;
                        A = 0.3;
                    //else show grey if the channel is off:
                    } else if(this.prevAlarmStatus[crate][i][j][0] == -1){
                        R = 0;
                        G = 0;
                        B = 0;
                        A = 0.3;
                    //else show yellow if channel is ramping & no temperature or current alarms:
                    } else if(this.prevAlarmStatus[crate][i][j][0] == -2 && this.prevAlarmStatus[crate][i][j][1] == 0 && this.prevAlarmStatus[crate][i][j][2] == 0){
                        R = 255;
                        G = 255;
                        B = 0;
                        A = 0.3;
                    //blue for external disable:
                    } else if(this.prevAlarmStatus[crate][i][j][0] == -3){
                        R = 0;
                        G = 0;
                        B = 255;
                        A = 0.5;
                    //else show red for alarm:
                    } else {
                        R = 255;
                        G = 0;
                        B = 0;
                        A = Math.max(this.prevAlarmStatus[crate][i][j][0], this.prevAlarmStatus[crate][i][j][1], this.prevAlarmStatus[crate][i][j][2])*0.7 + 0.3;  //enforce minimum 0.3 to make it clearly red
                        if(A>1) {A = 1;}
    	            }

                    //12- and 24-channel cards don't have primary channels, show black (also empty slots):
                    if( (i==0 && window.parameters.moduleSizes[crate][j] == 1) || (i==0 && window.parameters.moduleSizes[crate][j] == 2) || window.parameters.moduleSizes[crate][primary] == 0 ){
                        R = 0;
                        G = 0;
                        B = 0;
                        A = 0.9;
                    }
                    this.startColor[crate][i][j] = [R,G,B,A];

                    //end values:
                    if(this.alarmStatus[crate][i][j][0] == 0 && this.alarmStatus[crate][i][j][1] == 0 && this.alarmStatus[crate][i][j][2] == 0){
                        R = 0;
                        G = 255;
                        B = 0;
                        A = 0.3;
                    } else if(this.alarmStatus[crate][i][j][0] == -1){
                        R = 0;
                        G = 0;
                        B = 0;
                        A = 0.3;
                    } else if(this.alarmStatus[crate][i][j][0] == -2 && this.alarmStatus[crate][i][j][1] == 0 && this.alarmStatus[crate][i][j][2] == 0){
                        R = 255; 
                        G = 255;
                        B = 0;
                        A =0.3;
                    } else if(this.alarmStatus[crate][i][j][0] == -3){
                        R = 0;
                        G = 0;
                        B = 255;
                        A = 0.5;
                    } else {
                        R = 255;
                        G = 0;
                        B = 0;
                        A = Math.max(this.alarmStatus[crate][i][j][0], this.alarmStatus[crate][i][j][1], this.alarmStatus[crate][i][j][2])*0.7 + 0.3;  //enforce minimum 0.3 to make it clearly red
                        if(A>1) {A = 1;}
                    }
                    if( (i==0 && window.parameters.moduleSizes[crate][j] == 1) || window.parameters.moduleSizes[crate][primary] == 0 ){
                        R = 0;
                        G = 0;
                        B = 0;
                        A = 0.9;
                    }
                    this.endColor[crate][i][j] = [R,G,B,A];
    	       }
            }
        };

        this.draw = function(frame){

            var i, j;
            var R, G, B, A;
            var color;
            var columns;
            var cornerX, cornerY;

            //whiteout old canvas:
            this.context[window.HVview].globalAlpha = 1;
            this.context[window.HVview].clearRect(this.leftEdge[window.HVview],0,this.totalWidth,this.legendTop[window.HVview]);
            this.context[window.HVview].fillStyle = "rgba(255,255,255,1)"
            this.context[window.HVview].fillRect(this.leftEdge[window.HVview],0,this.cellSide[window.HVview]*this.cols[window.HVview],this.cellSide[window.HVview]*this.rows);

            for(i=0; i<this.rows; i++){
                //primary row spans multi-columns:
                if(i==0) columns = window.parameters.moduleSizes[window.HVview].length;
                else columns = this.cols[window.HVview];
                for(var j=0; j<columns; j++){
                    R = this.startColor[window.HVview][i][j][0] + (this.endColor[window.HVview][i][j][0] - this.startColor[window.HVview][i][j][0])*frame/this.nFrames;
                    G = this.startColor[window.HVview][i][j][1] + (this.endColor[window.HVview][i][j][1] - this.startColor[window.HVview][i][j][1])*frame/this.nFrames;
                    B = this.startColor[window.HVview][i][j][2] + (this.endColor[window.HVview][i][j][2] - this.startColor[window.HVview][i][j][2])*frame/this.nFrames;
                    A = this.startColor[window.HVview][i][j][3] + (this.endColor[window.HVview][i][j][3] - this.startColor[window.HVview][i][j][3])*frame/this.nFrames;
                    color = "rgba("+R+","+G+","+B+","+A+")";
            
                    this.context[window.HVview].fillStyle = color;
                    cornerY = i*this.cellSide[window.HVview];
                    //primary row has different size bins than the rest:
                    if(i != 0){
                        cornerX = this.leftEdge[window.HVview] + j*this.cellSide[window.HVview];
                        this.context[window.HVview].fillRect(cornerX, cornerY,this.cellSide[window.HVview],this.cellSide[window.HVview]);
                    }
                    else{
                        cornerX = 0;
                        for(var sum=0; sum<j; sum++){
                            cornerX = cornerX + Math.max(window.parameters.moduleSizes[window.HVview][sum],1);
                        }
                        cornerX = this.leftEdge[window.HVview] + cornerX*this.cellSide[window.HVview];
                        this.context[window.HVview].fillRect(cornerX, cornerY,this.cellSide[window.HVview]*Math.max(window.parameters.moduleSizes[window.HVview][j],1),this.cellSide[window.HVview]);

                    }
                }
            }

            /*
            //highlight cell in focus:
            this.context[window.HVview].strokeStyle = '#FFFFFF';
            this.context[window.HVview].lineWidth = 3;
            this.context[window.HVview].strokeRect(this.leftEdge[window.HVview],0,this.cellSide[window.HVview],this.cellSide[window.HVview])
            //this.context[window.HVview].strokeRect(this.leftEdge[window.HVview] + this.cellSide[window.HVview]*this.chx, this.cellSide[window.HVview]*this.chy, this.cellSide[window.HVview]*Math.max(window.parameters.moduleSizes[window.HVview][j],1),this.cellSide[window.HVview]);
            this.context[window.HVview].stroke();
            this.context[window.HVview].strokeStyle = '#000000';
            this.context[window.HVview].lineWidth = 1;
            */
                        

            this.drawWaffleDecorations(frame);
            this.drawWaffleLabels();
        };

        this.drawWaffleDecorations = function(frame){

            var i, j;

            var modDivCopy = [0];
            for(i=0; i < window.parameters.moduleSizes[window.HVview].length; i++){
                modDivCopy[i+1] = modDivCopy[i] + Math.max(window.parameters.moduleSizes[window.HVview][i],1);
            }
            modDivCopy.shift();

            //style lines:
            this.context[window.HVview].fillStyle = 'rgba(0,0,0,1)';
            this.context[window.HVview].lineWidth = 1;

            //draw border:
            this.context[window.HVview].strokeRect(this.leftEdge[window.HVview],0,this.cellSide[window.HVview]*this.cols[window.HVview], this.cellSide[window.HVview]*this.rows);

            //draw inner lines:
            for(i=1; i<this.rows; i++){
                this.context[window.HVview].beginPath();
                if(i==1) this.context[window.HVview].lineWidth = 3;
                else this.context[window.HVview].lineWidth = 1;
                this.context[window.HVview].moveTo(this.leftEdge[window.HVview],i*this.cellSide[window.HVview]);
                this.context[window.HVview].lineTo(this.leftEdge[window.HVview] + this.cellSide[window.HVview]*this.cols[window.HVview],i*this.cellSide[window.HVview]);
                this.context[window.HVview].stroke();       
            }
            for(j=1; j<this.cols[window.HVview]; j++){
                this.context[window.HVview].beginPath();
                if(j==modDivCopy[0]){
                    this.context[window.HVview].lineWidth = 3;
                    modDivCopy.shift();
                }
                else this.context[window.HVview].lineWidth = 1;
                if(this.context[window.HVview].lineWidth == 1){
                    this.context[window.HVview].moveTo(this.leftEdge[window.HVview] + j*this.cellSide[window.HVview],this.cellSide[window.HVview]);
                    this.context[window.HVview].lineTo(this.leftEdge[window.HVview] + j*this.cellSide[window.HVview],this.cellSide[window.HVview]*this.rows);
                } else {
                    this.context[window.HVview].moveTo(this.leftEdge[window.HVview] + j*this.cellSide[window.HVview],0);
                    this.context[window.HVview].lineTo(this.leftEdge[window.HVview] + j*this.cellSide[window.HVview],this.cellSide[window.HVview]*this.rows);
                }
                this.context[window.HVview].stroke();
            }

        };

        this.drawWaffleLabels = function(){
            var i, j;
            var moduleWidth, modRotation, modAlign, modHeight;
            
            this.context[window.HVview].fillStyle = 'white'; //'black'
            this.context[window.HVview].globalAlpha = 0.3;    //0.6

            //channel labels:
            var labelFontSize = Math.min(16, this.cellSide[window.HVview]);
            this.context[window.HVview].font=labelFontSize+"px Raleway";
            this.context[window.HVview].fillText('Prim', this.leftEdge[window.HVview] + this.cellSide[window.HVview]*this.cols[window.HVview]+10, this.cellSide[window.HVview]/2 +8 );
            for(i=1; i<this.rows; i++){
                this.context[window.HVview].fillText(i-1, this.leftEdge[window.HVview] + this.cellSide[window.HVview]*this.cols[window.HVview]+10, i*this.cellSide[window.HVview] + this.cellSide[window.HVview]/2 +8 );
            }

            //module labels:
            var moduleDivisions = [0];
            var vertOffset;
            for(i=0; i < window.parameters.moduleSizes[window.HVview].length; i++){
                moduleDivisions[i+1] = moduleDivisions[i] + Math.max(window.parameters.moduleSizes[window.HVview][i],1);
            }
            for(j=1; j<moduleDivisions.length; j++){
                var moduleWidth = moduleDivisions[j] - moduleDivisions[j-1];

                if(moduleWidth*this.cellSide[window.HVview] < 1.2*this.context[window.HVview].measureText(this.moduleLabels[j-1]).width){
                    modRotation = -Math.PI/2;  //2.4
                    modAlign = 'right';
                    modHeight = 0;
                    vertOffset = 15;
                } else {
                    modRotation = 0;
                    modAlign = 'center';
                    modHeight = labelFontSize;
                    vertOffset = 25;
                }
                this.context[window.HVview].save();
                this.context[window.HVview].translate(this.leftEdge[window.HVview] + (moduleWidth/2 + moduleDivisions[j-1])*this.cellSide[window.HVview], this.rows*this.cellSide[window.HVview]+vertOffset);
                this.context[window.HVview].rotate(modRotation);
                this.context[window.HVview].textAlign = modAlign;
                this.context[window.HVview].fillText(this.moduleLabels[j-1], 0,labelFontSize/2);
                this.context[window.HVview].restore();
            }
        };        

        //wrapper for transition from old state to new state via this.animate:
        this.update = function(){
            var i,j,k,columns;

            this.fetchNewData();

            //update alarms & colors to prepare for animation transition:
            for(k=0; k<this.nCrates; k++){
                for(i=0; i<this.rows; i++){
                    //primary row spans multi-columns:
                    if(i==0) columns = window.parameters.moduleSizes[k].length;
                    else columns = this.cols[k];
                    for(j=0; j<columns; j++){
                        this.prevAlarmStatus[k][i][j][0] = this.alarmStatus[k][i][j][0];
                        this.prevAlarmStatus[k][i][j][1] = this.alarmStatus[k][i][j][1];
                        this.prevAlarmStatus[k][i][j][2] = this.alarmStatus[k][i][j][2];
                        this.alarmStatus[k][i][j][0] = this.dataBus[k].alarmStatus[i][j][0];
                        this.alarmStatus[k][i][j][1] = this.dataBus[k].alarmStatus[i][j][1]; 
                        this.alarmStatus[k][i][j][2] = this.dataBus[k].alarmStatus[i][j][2];
                        //this.cellColorUpdate(k);
                    }
                }
                this.cellColorUpdate(k);
            }

            //update peripherals:
            for(k=0; k<this.nCrates; k++){
                for(i=0; i<this.barCharts[k].length; i++){
                    for(j=0; j<this.barCharts[k][i].nBars; j++){
                        var arrayCoords = getPointer(i, j, that, k);
                        this.barCharts[k][i].dataBus.barChartData[j] = this.dataBus[k].reportVoltage[arrayCoords[0]][arrayCoords[1]];
                        this.barCharts[k][i].dataBus.barChartAlarms[j] = this.dataBus[k].alarmStatus[arrayCoords[0]][arrayCoords[1]];
                    }
                    this.barCharts[k][i].update(this.barCharts[k][i].dataBus.barChartData, this.barCharts[k][i].dataBus.barChartAlarms);
                }
            }

            channelSelect(that);
            for(i=0; i<this.nCrates; i++){
                this.tooltip[i].update();
            }

            //animation fires only if canvas is showing:
            this.animate();

        };

        //determine which cell pixel x,y falls in, with this.leftEdge,0 being the top left corner of the canvas; return -1 if no corresponding cell.
        this.findCell = function(x, y){
            var cell, slot;

            var chx = Math.floor((x-this.leftEdge[window.HVview]) / this.cellSide[window.HVview]);
            var chy = Math.floor(y / this.cellSide[window.HVview]);
            slot = primaryBin(window.parameters.moduleSizes[window.HVview], chx)

            if(chx < this.cols[window.HVview] && chx > -1 && chy < this.rows && chy > -1){
                cell = [];
                if(chy == 0){
                    chx = slot;
                }
                cell[0] = chy;
                cell[1] = chx;
                if( (chy == 0 && window.parameters.moduleSizes[window.HVview][chx] == 1) || window.parameters.moduleSizes[window.HVview][slot] == 0 ) cell = -1;
            } else 
                cell = -1;

            return cell   
        };

        //establish the tooltip text for the cell returned by this.findCell; return length of longest line:
        this.defineText = function(cell){
            var toolTipContent = '<br>';
            var nextLine, buffer;
            var cardIndex;
            var i;

            var row = cell[0];
            var col = cell[1];

            //decide which card we're pointing at:
            if(row == 0) cardIndex = col;
            else cardIndex = primaryBin(window.parameters.moduleSizes[window.HVview], col);

            //Title for normal channels:
            if(row != 0) nextLine = this.moduleLabels[cardIndex]+', Ch. '+channelMap(col, row, window.parameters.moduleSizes[window.HVview], this.rows)+'<br>';
            //Title for primary channels:
            else nextLine = this.moduleLabels[cardIndex]+' Primary <br>';
            toolTipContent += nextLine;

            //channel Name
            nextLine = this.dataBus[window.HVview].channelName[row][col]+'<br>';
            toolTipContent += nextLine;            

            //fill out tooltip content:
            for(i=0; i<this.reportedValues[window.HVview].length; i++){
                //establish prefix:
                nextLine = '<br/>'+this.tooltip[window.HVview].prefix[i];
                if(this.tooltip[window.HVview].prefix[i] !== '') nextLine += ' ';

                //pull in content; special cases for the status word and reported current:
                //status word:
                if(i == 6){
                    nextLine += ((this.dataBus[window.HVview].channelMask[row][col] == 0) ? 'Off' : parseStatusWord(this.reportedValues[window.HVview][i][row][col]));
                }
                //current:
                else if(i == 2){
                        if(window.parameters.moduleSizes[window.HVview][cardIndex]==4 && row!=0) nextLine += '--';
                        else nextLine += Math.round( this.reportedValues[window.HVview][i][row][col]*1000)/1000 + ' ' + this.tooltip[window.HVview].postfix[i];                
                } else {
                    nextLine += Math.round( this.reportedValues[window.HVview][i][row][col]*1000)/1000 + ' ' + this.tooltip[window.HVview].postfix[i];
                }

                //append to tooltip:
                toolTipContent += nextLine;
 
            }
            toolTipContent += '<br><br>';
            document.getElementById(this.tooltip[window.HVview].ttDivID).innerHTML = toolTipContent;

            return 0;
        };

        //get new data:
        this.fetchNewData = function(){
            
            var testParameter, i, j, k, data, ODBindex, columns, slot, variablesRecord, settingsRecord,
            chName = [],
            reqVoltage = [],
            measVoltage = [],
            measCurrent = [],
            rampUp = [],
            rampDown = [],
            measTemperature = [],
            repoChState = [],
            repoChStatus = [],
            voltageLimit = [],
            currentLimit = [],
            paths = [];
        
            //fetch all the HV parameters from the chunk of ODB hanging around locally:
            for(k=0; k<this.nCrates; k++){
                chName[k]          = window.localODB['HV'+k].chName;  
                reqVoltage[k]      = window.localODB['HV'+k].reqVoltage;  
                measVoltage[k]     = window.localODB['HV'+k].measVoltage;
                measCurrent[k]     = window.localODB['HV'+k].measCurrent; 
                rampUp[k]          = window.localODB['HV'+k].rampUp;
                rampDown[k]        = window.localODB['HV'+k].rampDown;
                measTemperature[k] = window.localODB['HV'+k].measTemperature;
                repoChState[k]     = window.localODB['HV'+k].repoChState;
                repoChStatus[k]    = window.localODB['HV'+k].repoChStatus;
                voltageLimit[k]    = window.localODB['HV'+k].voltageLimit;
                currentLimit[k]    = window.localODB['HV'+k].currentLimit;        
            }

            for(k=0; k<this.nCrates; k++){
                for(i=0; i<this.rows; i++){
                    //primary row spans multi-columns, only has entries for 48 channel cards:        
                    if(i==0) columns = window.parameters.moduleSizes[k].length;
                    else columns = this.cols[k];

                    for(j=0; j<columns; j++){
                  
                        if (i>0) slot = primaryBin(window.parameters.moduleSizes[k], j);
                        else slot = j;
                        //don't populate the primary of a 12 channel card, or any channel corresponding to an empty slot:
                        if( (i!=0 || window.parameters.moduleSizes[k][j]==4) && window.parameters.moduleSizes[k][slot]!=0 ){
                               
                            this.dataBus[k].channelName[i][j] = 'channel'+i+j;
                            this.dataBus[k].demandVoltage[i][j] = -9999;
                            this.dataBus[k].reportVoltage[i][j] = -9999;
                            this.dataBus[k].reportCurrent[i][j] = -9999;
                            this.dataBus[k].demandVrampUp[i][j] = -9999;
                            this.dataBus[k].demandVrampDown[i][j] = -9999;
                            this.dataBus[k].reportTemperature[i][j] = -9999;
                            this.dataBus[k].channelMask[i][j] = 1;
                            this.dataBus[k].rampStatus[i][j] = 7;
                            this.dataBus[k].voltLimit[i][j] = -9999;
                            this.dataBus[k].currentLimit[i][j] = -9999;

                            ODBindex = getMIDASindex(i, j, k);
                            this.dataBus[k].channelName[i][j]       = chName[k][ODBindex];
                            this.dataBus[k].demandVoltage[i][j]     = parseFloat(reqVoltage[k][ODBindex]);
                            this.dataBus[k].reportVoltage[i][j]     = parseFloat(measVoltage[k][ODBindex]);   
                            this.dataBus[k].reportCurrent[i][j]     = parseFloat(measCurrent[k][ODBindex]);
                            
                            this.dataBus[k].demandVrampUp[i][j]     = parseFloat(rampUp[k][ODBindex]);
                            this.dataBus[k].demandVrampDown[i][j]   = parseFloat(rampDown[k][ODBindex]);
                            this.dataBus[k].reportTemperature[i][j] = parseFloat(measTemperature[k][ODBindex]);
                            this.dataBus[k].channelMask[i][j]       = ( parseInt(repoChState[k][ODBindex]) && parseInt(repoChStatus[k][ODBindex]) ) ? 1 : 0 ;
                            this.dataBus[k].rampStatus[i][j]        = parseInt(repoChStatus[k][ODBindex], 16);
                            this.dataBus[k].voltLimit[i][j]         = parseFloat(voltageLimit[k][ODBindex]);
                            this.dataBus[k].currentLimit[i][j]      = parseFloat(currentLimit[k][ODBindex]);

                            //48ch cards report the currents in mA, convert to uA: 
                            if(i==0){
                                this.dataBus[k].reportCurrent[i][j] = this.dataBus[k].reportCurrent[i][j]*1000;
                                this.dataBus[k].currentLimit[i][j] = this.dataBus[k].currentLimit[i][j]*1000;
                            }
                                
                        } else if (i!=0 || window.parameters.moduleSizes[k][j]==4){  //keep the array filled, even for empty slots to avoid unpredictable behavior
                            this.dataBus[k].channelName[i][j] = 'channel'+i+j;
                            this.dataBus[k].demandVoltage[i][j] = 0;
                            this.dataBus[k].reportVoltage[i][j] = 0;
                            this.dataBus[k].reportCurrent[i][j] = 0;
                            this.dataBus[k].demandVrampUp[i][j] = 0;
                            this.dataBus[k].demandVrampDown[i][j] = 0;
                            this.dataBus[k].reportTemperature[i][j] = 0;
                            this.dataBus[k].channelMask[i][j] = 0;
                            this.dataBus[k].rampStatus[i][j] = 0;
                            this.dataBus[k].voltLimit[i][j] = 0;
                            this.dataBus[k].currentLimit[i][j] = 0;
                        }

                        //give the necessary information to the AlarmService, so it can report the state of any channel that trips an alarm below:
                        if(j==0){
                            this.AlarmServices.demandVoltage[k][i] = [];
                            this.AlarmServices.reportVoltage[k][i] = [];
                            this.AlarmServices.reportCurrent[k][i] = [];
                            this.AlarmServices.reportTemperature[k][i] = [];
                        }
                        this.AlarmServices.demandVoltage[k][i][j] = this.dataBus[k].demandVoltage[i][j];
                        this.AlarmServices.reportVoltage[k][i][j] = this.dataBus[k].reportVoltage[i][j];
                        this.AlarmServices.reportCurrent[k][i][j] = this.dataBus[k].reportCurrent[i][j];
                        this.AlarmServices.reportTemperature[k][i][j] = this.dataBus[k].reportTemperature[i][j];
                    }
                }
            }

            //see if any of the new data raises any alarms:
            this.raiseAlarm();

        };

        //push problems out to the alarm service
        this.raiseAlarm = function(){
            var i, j, k;
            //determine alarm status
            for(k=0; k<this.nCrates; k++){
                for(i=0; i<this.rows; i++){
                    //primary row spans multi-columns:
                    if(i==0) columns = window.parameters.moduleSizes[k].length;
                    else columns = this.cols[k];
                    for(j=0; j<columns; j++){
                        //construct the parameter to be tested against the voltage alarm:
                        testParameter = Math.abs(this.dataBus[k].demandVoltage[i][j] - this.dataBus[k].reportVoltage[i][j]); 

                        //determine alarm status for each cell, recorded as [i][j][voltage alarm, current alarm, temperature alarm]
                        //alarmStatus == 0 indicates all clear, 0 < alarmStatus <= 1 indicates alarm intensity, alarmStatus = -1 indicates channel off,
                        //and alarmStatus == -2 for the voltage alarm indicates voltage ramping, -3 for misc disabled conditions:
                        if(testParameter < ODB.HV.voltageTolerance)  this.dataBus[k].alarmStatus[i][j][0] = 0;
                        else this.dataBus[k].alarmStatus[i][j][0] = Math.min( (testParameter - ODB.HV.voltageTolerance) / window.parameters.scaleMaxima[0], 1);
                        if(this.dataBus[k].rampStatus[i][j] == 3 || this.dataBus[k].rampStatus[i][j] == 5){
                            this.dataBus[k].alarmStatus[i][j][0] = -2;
                        }
                        if(this.dataBus[k].rampStatus[i][j] == 256)
                            this.dataBus[k].alarmStatus[i][j][0] = -3;

                        if(this.dataBus[k].reportCurrent[i][j] < ODB.HV.currentTolerance)  this.dataBus[k].alarmStatus[i][j][1] = 0;
                        else  this.dataBus[k].alarmStatus[i][j][1] = Math.min( (this.dataBus[k].reportCurrent[i][j] - ODB.HV.currentTolerance) / window.parameters.scaleMaxima[1], 1);

                        if(this.dataBus[k].reportTemperature[i][j] < ODB.HV.tempTolerance)  this.dataBus[k].alarmStatus[i][j][2] = 0;
                        else  this.dataBus[k].alarmStatus[i][j][2] = Math.min( (this.dataBus[k].reportTemperature[i][j] - ODB.HV.tempTolerance) / window.parameters.scaleMaxima[2], 1);

                        if(this.dataBus[k].channelMask[i][j] == 0){
                            this.dataBus[k].alarmStatus[i][j][0] = -1;
                            this.dataBus[k].alarmStatus[i][j][1] = -1;
                            this.dataBus[k].alarmStatus[i][j][2] = -1;
                        }

                        //register alarms in AlarmServices object:
                        //voltage alarms:
                        if(this.dataBus[k].alarmStatus[i][j][0] > 0){
                            AlarmServices.voltageAlarms[AlarmServices.voltageAlarms.length] = [i,j,k,this.dataBus[k].alarmStatus[i][j][0]];
                        }
                        //current alarms:
                        if(this.dataBus[k].alarmStatus[i][j][1] > 0){
                            AlarmServices.currentAlarms[AlarmServices.currentAlarms.length] = [i,j,k,this.dataBus[k].alarmStatus[i][j][0]];
                        }
                        //temperature alarms:
                        if(this.dataBus[k].alarmStatus[i][j][2] > 0){
                            AlarmServices.temperatureAlarms[AlarmServices.temperatureAlarms.length] = [i,j,k,this.dataBus[k].alarmStatus[i][j][0]];   
                        }
                        
                    }
                }
            }
        };

        this.animate = function(){
            //var i, 
            //topHV = window.HVview;

            if(window.onDisplay.slice(0,6) == 'HVgrid' /*|| window.freshLoad*/){
                /*
                for(i=0; i<this.nCrates; i++){  
                    if(i!=topHV){
                        window.HVview = i;
                        this.draw(this.nFrames);
                    }
                }
                */
                //window.HVview = topHV;
                animate(this, 0);
            } /*else{
                for(i=0; i<this.nCrates; i++){
                    window.HVview = i;
                    this.draw(this.nFrames);      
                }
                window.HVview = topHV;
            }*/
        };

        //do an initial populate of the waffle:
        this.fetchNewData();
        //don't double count the alarms:
        window.AlarmServices.wipeAlarms();
        //also, draw the input sidebar for 0,0 on first call:
        channelSelect(that);
}











//some useful globals

//define the onclick behavior of the waffle:
function clickWaffle(event, obj){

            window.refreshInput = 1;

            var superDiv = document.getElementById(obj.wrapperDiv);
            var inputDiv = document.getElementById(obj.InputLayer);

            //form coordinate system chx, chy with origin at the upper left corner of the div, and 
            //bin as the waffle binning: 
            var chx = Math.floor( (event.pageX - obj.leftEdge[window.HVview] - superDiv.offsetLeft - obj.canvas[window.HVview].offsetLeft) / obj.cellSide[window.HVview]);
            var chy = Math.floor( (event.pageY - superDiv.offsetTop - obj.canvas[window.HVview].offsetTop) / obj.cellSide[window.HVview]);

            //are we on the primary of a card that doesn't have a primary, or an empty slot??
            var suppressClick = 0;
            var cardIndex = primaryBin(window.parameters.moduleSizes[window.HVview], chx);
            if( (chy==0 && window.parameters.moduleSizes[window.HVview][cardIndex] == 1) || window.parameters.moduleSizes[window.HVview][cardIndex] == 0 ) suppressClick = 1;

            if(chx<obj.cols[window.HVview] && chx>=0 && chy<obj.rows && chy>=0 && window.onDisplay == obj.canvasID[window.HVview] && suppressClick==0){
                obj.chx = chx;
                obj.chy = chy;
                channelSelect(obj);
            }

}

//map the active grid cooridnates onto MIDAS's channel numbering:
function getMIDASindex(row, col, crate){
    
    var MIDASindex = 0;
    var moduleNumber, i;

    if(row != 0){
        //count up regular channels
        MIDASindex += window.parameters.rows*col + row-1;
        moduleNumber = primaryBin(window.parameters.moduleSizes[crate], col);
        for(i=0; i<moduleNumber+1; i++){
            //add on primary channels
            if(window.parameters.moduleSizes[crate][i] == 4) MIDASindex++;
            //remove overcounting for empty cards:
            if(window.parameters.moduleSizes[crate][i] == 0) MIDASindex -= 12;
        }
    } else{
        moduleNumber = col;
        //add up all the channels from previous cards:
        for(i=0; i<moduleNumber; i++){
            if(window.parameters.moduleSizes[crate][i] == 1) MIDASindex += 12;
            if(window.parameters.moduleSizes[crate][i] == 2) MIDASindex += 24;
            if(window.parameters.moduleSizes[crate][i] == 4) MIDASindex += 49;
        }
        //MIDASindex++;
    }

    return MIDASindex;
}

//given a module number and channel number, return the [row, col] that the corresponding data will be found in in the various waffle.<dataArrays>
function getPointer(module, channel, waffle, crate){
    var i;
    var row = 0;
    var col = 0;

    //column:
    for(i=0; i<module; i++){
        col += Math.max(window.parameters.moduleSizes[crate][i],1);
    }
    col += Math.floor(channel/(waffle.rows-1));

    row = 1 + channel%(waffle.rows-1);

    return [row, col];
}

//map the channel-sized bins in the primary row into the appropriate primary groups:
function primaryBin(moduleSizes, chx){
    var primary = 0;
    var i = 0;
    while(chx>=0){
        chx = chx - Math.max(moduleSizes[i],1);
        i++;
    }
    return i-1;
}

//map the bin coordinates chx and chy onto a channel number:
function channelMap(chx, chy, moduleSizes, rows){
    var primary = primaryBin(moduleSizes, chx);
    if (moduleSizes[primary] == 1) return chy - 1;
    else{
        var channelNo = (rows-1)*chx + chy-1;
        for(var i=0; i<primary; i++){
            channelNo -= (rows-1)*Math.max(moduleSizes[i],1);
        }
        return channelNo;
    }
}

//set up channel navigation dropdowns and modify on the fly:
function configureDropdowns(ChannelListDD, CardListDD, moduleLabels, moduleSizes){

    var i;
    var option = [];

    //establish card list
    var colDD = document.getElementById(CardListDD);
    for(i=0; i<moduleLabels.length; i++){
        if(parseInt(moduleSizes[i]) ){
            option[i] = document.createElement('option');
            option[i].text = moduleLabels[i];
            colDD.add(option[i], null);
        }
    }

    //establish channel list
    var rowDD = document.getElementById(ChannelListDD);
    for(i=0; i<12; i++){
        option[i] = document.createElement('option');
        option[i].text = i;
        rowDD.add(option[i], null);
    }

}

//reconfigure channel drop down to respond to changes in module:
function reconfigureChannelList(moduleLabels, moduleSizes, ChannelListDD){

    var i, index, nChan;

    //fetch whatever's in the card dropdown:
    var cardName = getInput('changeChannel', 0);

    //...and channel dropdown:
    var channelNumber = getInput('changeChannel', 1);

    //translate cardName into an index:
    for(i=0; i<moduleLabels.length; i++){
        if(cardName == moduleLabels[i]) index = i;
    }

    //decide how many channels should be in the channel dropdown:
    if(moduleSizes[index] == 4) nChan = 48;
    else if(moduleSizes[index] == 2) nChan = 24;
    else nChan = 12;

    //establish channel list
    var option = [];
    var rowDD = document.getElementById(ChannelListDD);
    for(i=0; i<49; i++){
        rowDD.remove(0);
    }
    var startIndex = 0;
    if(nChan == 48){
        option[0] = document.createElement('option');
        option[0].text = 'Primary';
        rowDD.add(option[0], null);
        startIndex++;
    }
    for(i=startIndex; i<nChan+startIndex; i++){
        option[i] = document.createElement('option');
        option[i].text = i-startIndex;
        rowDD.add(option[i], null);
    }

    //keep the channel number in the same place if possible:
    if(channelNumber == 'Primary' && nChan==12) setInput('changeChannel',1,0); 
    else if(channelNumber >= nChan) setInput('changeChannel',1,0);
    else setInput('changeChannel',1,channelNumber);

}

//swap from one mainframe view to another:
function swapHVmainframe(inbound){
    var i;

    //if a bar chart is showing, dismiss it:
    if(window.HVpointer.viewStatus >= 0){
        fadeOut('crate'+window.HVview+'bar'+window.HVpointer.viewStatus)
        document.getElementById('crate'+window.HVview+'card'+window.HVpointer.viewStatus).setAttribute('class', 'navLink');
    }
    window.HVpointer.viewStatus = -1;

    //fade canvases:
    fadeOut(window.HVpointer.canvasID[window.HVview]);
    fadeIn(window.HVpointer.canvasID[inbound])

    //highlight buttons
    document.getElementById('Main'+(window.HVview+1)).setAttribute('class', 'navLink');
    document.getElementById('Main'+(inbound+1)).setAttribute('class', 'navLinkDown');
    //switch nav bars
    $('#'+window.HVpointer.linkWrapperID+window.HVview).css('display', 'none');
    $('#'+window.HVpointer.linkWrapperID+inbound).css('display', 'block');
    $('#'+window.HVpointer.linkWrapperID+window.HVview).css('z-index', -1);
    $('#'+window.HVpointer.linkWrapperID+inbound).css('z-index', 10);

    //keep tabs on what's showing where
    window.HVpointer.viewStatus=-1;
    window.HVview = inbound;
    window.onDisplay = window.HVpointer.canvasID[inbound];

    //make sure the waffle is pointing at a channel that actually has something in it before the initial populate:
    window.HVpointer.chy = 1;
    i=0;
    while(window.parameters.moduleSizes[inbound][i] == 0) i++;
    window.HVpointer.chx = i;

    //point the input sidebar at the new crate:
    channelSelect(window.HVpointer);
}

//bar chart response:
function barChartButton(button){
    var inbound;

    button.setAttribute('class', 'navLinkDown');
    if(window.HVpointer.viewStatus >= 0){
        document.getElementById('crate'+window.HVview+'card'+window.HVpointer.viewStatus).setAttribute('class', 'navLink');
    }
    window.HVpointer.viewStatus = button.cardNumber;

    inbound = 'crate'+window.HVview+'bar'+window.HVpointer.viewStatus

    if(inbound != window.onDisplay){
        fadeOut(window.onDisplay);
        fadeIn(inbound);
        window.onDisplay = inbound;
    }
}










ZDS.prototype = Object.create(Subsystem.prototype);

function ZDS(){
    //detector name, self-pointing pointer, pull in the Subsystem template, 
    //establish a databus and create a global-scope pointer to this object:
    this.name = 'ZDS';
    var that = this;
    Subsystem.call(this);
    this.dataBus = new ZDSDS();

    //make a pointer at window level back to this object, so we can pass by reference to the nav button onclick
    window.ZDSpointer = that;

    //list of elements with distinct minima and maxima on subdetector views:
    this.subdetectors = ['ZDS'];

    //drawing parameters///////////////////////////////////////
    this.centerX = this.canvasWidth/2;
    this.centerY = this.canvasHeight*0.42;
    this.radius  = this.canvasHeight*0.3;

    //member functions///////////////////////////////////////////////////////////////////


    this.draw = function(frame){
    	var i=0, key, ring, sector, fill;

    	this.context.strokeStyle = '#999999';
        fill = colors('ZDS01XN00X', this.dataBus.ZDS, frame, this.nFrames);
        this.context.fillStyle = (fill==0xDEADBEEF) ? this.context.createPattern(window.parameters.warningFill, 'repeat') : fill;

        this.context.beginPath();
        this.context.arc(this.centerX, this.centerY, this.radius, 0, Math.PI*2);
        this.context.closePath();
        this.context.fill();
        this.context.stroke();

        if(!this.TTlayerDone){
	        this.TTcontext.fillStyle = 'rgba(0,0,0,1)';
    	    this.TTcontext.beginPath();
        	this.TTcontext.arc(this.centerX, this.centerY, this.radius, 0, Math.PI*2);
	        this.TTcontext.closePath();
    	    this.TTcontext.fill();
    	    this.TTlayerDone = 1;
    	}

        //scale
        if(frame==this.nFrames || frame==0) this.drawScale(this.context);
    };
}//SHARC////////////////////////////////////////////////////////////
//SHARC assets: x0, y0 = center of shape
//Quad back summary - azimuthal segments, colors sorted azimuthally
quadBack = function(context, x0, y0, innerRad, outerRad, squish, colors, TT){
    
    var angularStep = (2*Math.PI)/colors.length;

    for(i=0; i<colors.length; i++){
        azimuthalSegment(context, x0, y0, innerRad, outerRad, angularStep, Math.PI-(i+1)*angularStep, squish, colors[i], TT);
    }

}

//draws a wedge shaped segment
azimuthalSegment = function(context, x0, y0, innerRad, outerRad, arc, orientation, squish, color, TT){
    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    context.save();
    context.translate(x0, y0);
    context.scale(1,squish);
    context.rotate(-orientation);
    context.beginPath();
    context.arc(0,0,innerRad, 0, -arc, true);
    context.lineTo(outerRad*Math.cos(arc), -outerRad*Math.sin(arc));
    context.arc(0,0,outerRad, -arc, 0, false);
    context.closePath();
    context.fill();
    context.stroke();
    context.restore();
}

//Quad front summary - radial segments.  Colors should be sorted first by array position (ie quadrant), then by smallest to largest radius.
quadFront = function(context, x0, y0, innerRad, outerRad, squish, colors, TT){

    var radStep = (outerRad - innerRad)/4;

    for(i=0; i<colors.length; i++){
        annularSegment(context, x0, y0, innerRad+(i%4)*radStep, innerRad + ((i%4)+1)*radStep, Math.PI/2, Math.PI/2*Math.floor(i/4), squish, colors[i], TT);
    }

}

//draws a macaroni-shaped segment that extends <arc> radians CCW from angle <orientation>
annularSegment = function(context, x0, y0, innerRad, outerRad, arc, orientation, squish, color, TT){
    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    context.save();
    context.translate(x0, y0);
    context.scale(-1,squish);
    context.rotate(-orientation);
    context.beginPath();
    context.arc(0,0,innerRad, 0, -arc, true);
    context.lineTo(outerRad*Math.cos(arc), -outerRad*Math.sin(arc));
    context.arc(0,0,outerRad, -arc, 0, false);
    context.closePath();
    context.fill();
    context.stroke();
    context.restore();

}

//stack of four horizontal parallelograms for summary view; colors stack bottom to top:
horizStack = function(context, X0, Y0, width, height, colors, pitch, TT){
    var i, y0, x0, dX, dY, stripWidth;

    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    //for the pads:
    if(colors.length==1){
        horizPara(context, X0, Y0, width, height, colors[0], pitch, TT);  
        return;
    }

    if(pitch == 'h'){
        //center of first strip:
        y0 = Y0 + 1.5*height/4,
        x0 = X0 - 1.5*height/4*Math.tan(Math.PI/6),
        dX = height/4*Math.tan(Math.PI/6),
        dY = height/4;
        for(i=0; i<4; i++){
            horizPara(context, x0+i*dX, y0-i*dY, width - 0.75*height*Math.tan(Math.PI/6), height/4, colors[i], pitch, TT );
        }
    } else {
        stripWidth = (height-width*Math.tan(Math.PI/6))/4;
        x0 = X0;
        y0 = Y0 + 1.5*stripWidth;
        dY = stripWidth;
        dX = 0;
        for(i=0; i<4; i++){
            horizPara(context, x0+i*dX, y0-i*dY, width, (height-width*Math.tan(Math.PI/6))/4+width*Math.tan(Math.PI/6), colors[i], pitch, TT );
        }
    }



}

//paralellogram with horizontal stripes - pitch = 'h' for top and bottom parallel to x or 'v' for left and right parallel to y
horizPara = function(context, x0, y0, width, height, color, pitch, TT){

    var theta = Math.PI/6,
        yLength, xLength,
        //cx, cy coords of bottom left corner
        cx = x0 - width/2,
        cy = y0 + height/2;

    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.beginPath();
    context.moveTo(cx,cy);
    if(pitch == 'h'){
        yLength = height / Math.cos(theta);
        xLength = width - height*Math.tan(theta);
        context.lineTo(cx + height*Math.tan(theta), cy - height);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+xLength, cy);
    } else{
        xLength = width / Math.cos(theta);
        yLength = height - width*Math.tan(theta);
        context.lineTo(cx, cy-yLength);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+width, cy - (height-yLength) )
    }
    context.closePath();
    context.fill();
    context.stroke();

}

//stack of four vertical parallelograms for summary view; colors stack left to right:
vertStack = function(context, X0, Y0, width, height, colors, pitch, TT){
    var i, y0, x0, dX, dY, stripWidth;

    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    //for the pads:
    if(colors.length==1){
        vertPara(context, X0, Y0, width, height, colors[0], pitch, TT);  
        return;
    }

    if(pitch == 'h'){
        //center of first strip:
        y0 = Y0,
        x0 = X0 - 1.5*(width - height*Math.tan(Math.PI/6))/4,
        dX = (width - height*Math.tan(Math.PI/6))/4,
        dY = 0;
        for(i=0; i<4; i++){
            vertPara(context, x0+i*dX, y0, (width + 3*height*Math.tan(Math.PI/6))/4, height, colors[i], pitch, TT );
        }
    } else {
        stripWidth = width/4/Math.cos(Math.PI/6);
        dY = stripWidth*Math.sin(Math.PI/6);
        dX = width/4;
        x0 = X0 - 1.5*dX;
        y0 = Y0 + 1.5*dY;
        for(i=0; i<4; i++){
            vertPara(context, x0+i*dX, y0-i*dY, width/4, (height-0.75*width*Math.tan(Math.PI/6)), colors[i], pitch, TT );
        }
    }



}

//paralellogram with vertical stripes
vertPara = function(context, x0, y0, width, height, color, pitch, TT){

    var theta = Math.PI/6,
        yLength, xLength,
        //cx, cy coords of bottom left corner
        cx = x0 - width/2,
        cy = y0 + height/2;

    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.beginPath();
    context.moveTo(cx,cy);
    if(pitch == 'h'){
        yLength = height / Math.cos(theta);
        xLength = width - height*Math.tan(theta);
        context.lineTo(cx + height*Math.tan(theta), cy - height);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+xLength, cy);
    } else{
        xLength = width / Math.cos(theta);
        yLength = height - width*Math.tan(theta);
        context.lineTo(cx, cy-yLength);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+width, cy - (height-yLength) )
    }
    context.closePath();
    context.fill();
    context.stroke();

}

radialQuadrant = function(context, x0, y0, innerRad, outerRad, arc, orientation, colors, TT){
    var i,
        segments = colors.length,
        radStep = (outerRad - innerRad) / segments;

    context.save();
    context.translate(x0,y0);
    context.rotate(orientation);

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<segments; i++){
        context.fillStyle = colors[i];
        context.beginPath();
        context.arc(0,0,innerRad + i*radStep, -arc/2, arc/2, false);
        context.arc(0,0,innerRad + (i+1)*radStep, arc/2, -arc/2, true);
        context.closePath();
        context.fill();
        context.stroke();
    }

    context.restore();

}

azimuthalQuadrant = function(context, x0, y0, innerRad, outerRad, arc, orientation, colors, TT){
    var i,
        segments = colors.length,
        angleStep = arc / segments;

    context.save();
    context.translate(x0,y0);
    context.rotate(orientation);

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<segments; i++){
        context.fillStyle = colors[i];
        context.beginPath();
        context.arc(0,0,innerRad, -arc/2 + i*angleStep, -arc/2 + (i+1)*angleStep  , false);
        context.arc(0,0,outerRad, -arc/2 + (i+1)*angleStep, -arc/2 + i*angleStep, true);
        context.closePath();
        context.fill();
        context.stroke();
    }

    context.restore();

}

boxFront = function(context, x0,y0, height, width, colors, TT){
    var i,
        nStrips = colors.length,
        stripWidth = height/nStrips;

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<nStrips; i++){
        context.fillStyle = (colors[i]==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : colors[i];
        context.fillRect(x0, y0+i*stripWidth, width, stripWidth);
        context.strokeRect(x0, y0+i*stripWidth, width, stripWidth);
    }
}

boxBack = function(context, x0,y0, height, width, colors, TT){
    var i,
        nStrips = colors.length,
        stripWidth = width/nStrips;

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<nStrips; i++){
        context.fillStyle = (colors[i]==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : colors[i];
        context.fillRect(x0+i*stripWidth, y0, stripWidth, height);
        context.strokeRect(x0+i*stripWidth, y0, stripWidth, height);
    }
}

padSummaries = function(context, x0, y0, scale, colors, TT){

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';   

    context.fillStyle = colors[0];
    context.fillRect(x0-1.5*scale, y0-scale/2, scale, scale);
    context.strokeRect(x0-1.5*scale, y0-scale/2, scale, scale);

    context.fillStyle = colors[1];
    context.fillRect(x0+0.5*scale, y0-scale/2, scale, scale);
    context.strokeRect(x0+0.5*scale, y0-scale/2, scale, scale);    

}

//draw elliptical arc:
ellipse = function(context, centerX, centerY, horizRadius, startAngle, endAngle){
    context.save();
    context.translate(centerX, centerY);
    context.scale(1, 0.3);
    context.beginPath();
    context.arc(0, 0, horizRadius, 2*Math.PI - startAngle, 2*Math.PI - endAngle);
    context.restore();
    context.closePath();
    context.stroke();
}

//draw spokes from center ellipse to outer ellipse
ellipseSpoke = function(context, centerX, centerY, horizRadiusInner, horizRadiusOuter, phase, nSpokes, spokeNumber){

    //angle between spokes
    var sectionArc = 2*Math.PI / nSpokes;
    //angle of this spoke; recall the internet counts its angles backwards :(
    var phi = 2*Math.PI - (phase + spokeNumber*sectionArc);

    context.save();
    context.translate(centerX, centerY);
    context.scale(1, 0.3);
    //context.beginPath();
    context.moveTo(horizRadiusInner*Math.cos(phi), horizRadiusInner*Math.sin(phi));
    context.lineTo(horizRadiusOuter*Math.cos(phi), horizRadiusOuter*Math.sin(phi));
    context.restore();
    context.stroke();

}

//color in a particular annular section
fillAnnularSection = function(drawOption, context, centerX, centerY, innerRadius, outerRadius, startAngle, endAngle){

    context.save();
    context.translate(centerX, centerY);
    context.scale(1, 0.3);
    context.beginPath();
    context.moveTo(innerRadius*Math.cos(2*Math.PI - startAngle), innerRadius*Math.sin(2*Math.PI - startAngle));
    context.arc(0, 0, innerRadius, 2*Math.PI - startAngle, 2*Math.PI - endAngle, true);
    context.lineTo(outerRadius*Math.cos(2*Math.PI - endAngle), outerRadius*Math.sin(2*Math.PI - endAngle));
    context.arc(0, 0, outerRadius, 2*Math.PI - endAngle, 2*Math.PI - startAngle, false);
    context.closePath();
    context.restore();
    if(drawOption == 'fill' || drawOption == 'both') context.fill();
    if(drawOption == 'stroke' || drawOption == 'both')context.stroke();

}

//DESCANT////////////////////////////////////////////////////////////////////////////////////////

hex = function(context, centerX, centerY, side, phi){

    var i;

    //center to vertex distance:
    var spoke = side / 2 / Math.sin(Math.PI/6);

    //find coords of 6 vertices relative to center:
    var x = [];
    var y = [];

    for(i=0; i<6; i++){
        x[i] = spoke*Math.cos(phi + i*Math.PI/3);
        y[i] = spoke*Math.sin(phi + i*Math.PI/3);

        //alert(x[i]+' '+y[i]);
    }

    //draw hexagon:
    context.save();
    context.translate(centerX, centerY);
    context.beginPath();
    context.moveTo(x[0], y[0]);
    for(i=1; i<7; i++){
        context.lineTo(x[i%6], y[i%6]);
    }
    context.restore();
    context.stroke();

}

whiteDetector = function(context, centerX, centerY, scale, phi, bkg){
    context.strokeStyle = '#999999';//'rgba(255,255,255,1)';
    context.save();
    context.translate(centerX, centerY);
    context.beginPath();
    context.moveTo(scale*41.5, scale*(71.9));
    context.lineTo(scale*(-41.5), scale*(71.9));
    context.lineTo(scale*(-93), 0);
    context.lineTo(scale*(-41.5), scale*(-79.6));
    context.lineTo(scale*41.5, scale*(-79.6));
    context.lineTo(scale*93, 0);
    context.closePath();
    context.restore();
    context.fill();
    if(bkg == 0)context.stroke();
}

redDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999'; //'rgba(255,0,0,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(rotation);
    context.beginPath();
    context.moveTo(scale*37.4, scale*(-87.1));
    context.lineTo(scale*(-51.6), scale*(-83.3));
    context.lineTo(scale*(-101.8), 0);
    context.lineTo(scale*(-51.6), scale*(83.3));
    context.lineTo(scale*37.4, scale*(87.1));
    context.lineTo(scale*73.1, 0);
    context.closePath();
    context.restore();
    context.fill();
    if(bkg == 0)context.stroke();
}

blueDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999';//'rgba(0,150,255,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(rotation);
    context.beginPath();
    context.moveTo(scale*52.6, scale*(-79.4));
    context.lineTo(scale*(-45.1), scale*(-79.4));
    context.lineTo(scale*(-97.6), 0);
    context.lineTo(scale*(-45.1), scale*(79.4));
    context.lineTo(scale*52.6, scale*(79.4));
    context.lineTo(scale*99.2, 0);
    context.closePath();
    context.restore();
    context.fill();
    if(bkg == 0)context.stroke();
}

greenLeftDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999';//'rgba(0,255,0,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(-1*Math.PI/2 + rotation);
    context.beginPath();
    context.moveTo(scale*41.5, scale*(-71.9));
    context.lineTo(scale*(-41.5), scale*(-71.9));
    context.lineTo(scale*(-93), 0);
    context.lineTo(scale*(-41.5), scale*(79.6));
    context.lineTo(scale*41.5, scale*(79.6));
    context.lineTo(scale*62.3, scale*47.6);
    context.closePath();
    context.restore();  
    context.fill();
    if(bkg == 0)context.stroke(); 
}

greenRightDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999';//'rgba(0,255,0,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(Math.PI/2 + rotation);
    context.beginPath();
    context.moveTo(scale*41.5, scale*(-71.9));
    context.lineTo(scale*(-41.5), scale*(-71.9));
    context.lineTo(scale*(-62.3), scale*47.6);
    context.lineTo(scale*(-41.5), scale*(79.6));
    context.lineTo(scale*41.5, scale*(79.6));
    context.lineTo(scale*93, 0);
    context.closePath();
    context.restore();   
    context.fill();
    if(bkg == 0)context.stroke();
}

//Color Scales///////////////////////////////////////////////////////////////////////////////////

//map [0,1] onto [#000000, #FF0000]
redScale = function(scale){
    var R = scale*255;
    return constructHexColor([R,0,0]);
}

//map [0,1] onto [#000000, #0000FF]
blueScale = function(scale){
    var B = scale*255;
    return constructHexColor([0,0,B]);
}

//map [0,1] onto [#000000, #00FF00]
greenScale = function(scale){
    var G = scale*255;
    return constructHexColor([0,G,0]);
}

colorScale = function(colors,scale){
    return constructHexColor([scale*(colors[3]-colors[0])+colors[0], scale*(colors[4]-colors[1])+colors[1], scale*(colors[5]-colors[2])+colors[2]]);
}

//map [0,1] onto various color scales
scalepickr = function(scale, palette){
    //map scale onto [0,360]:
    var H = scale*300 / 60;
    if(H>5) H=5;
    if(H<0) H=0;
    var R, G, B;
    var start0, start1, start2, start3, start4, start5;
    if (palette == 'Sunset'){
        start0 = [0,0,0];
        start1 = [0,0,0x52];
        start2 = [0xE6,0,0x5C];
        start3 = [255,255,0];        
        start4 = [255,0x66,0];
        start5 = [255,0,0];        
    } else if (palette == 'ROOT Rainbow'){
        start0 = [0xFF,0x00,0x00];
        start1 = [0xFF,0xFF,0x00];
        start2 = [0x00,0xFF,0x00];
        start3 = [0x00,0xFF,0xFF];
        start4 = [0x00,0x00,0xFF];
        start5 = [0x66,0x00,0xCC];
        H = -1*(H-5);
    } else if (palette == 'Greyscale'){
        start0 = [0x00,0x00,0x00];
        start1 = [0x22,0x22,0x22];
        start2 = [0x55,0x55,0x55];
        start3 = [0x88,0x88,0x88];        
        start4 = [0xBB,0xBB,0xBB];
        start5 = [0xFF,0xFF,0xFF];
    } else if (palette == 'Red Scale'){
        start0 = [0x00,0x00,0x00];
        start1 = [0x33,0x00,0x00];
        start2 = [0x66,0x00,0x00];
        start3 = [0x99,0x00,0x00];
        start4 = [0xCC,0x00,0x00];
        start5 = [0xFF,0x00,0x00];
    } else if (palette == 'Mayfair'){
        start0 = [0x1E,0x4B,0x0F];
        start1 = [0x0E,0xBE,0x57];
        start2 = [0xE4,0xAB,0x33];
        start3 = [0xEC,0x95,0xF7];
        start4 = [0x86,0x19,0x4A];
        start5 = [0xFF,0x10,0x10];
    } else if (palette == 'Test'){
        start0 = [0x5E,0x1F,0x14];
        start1 = [0x74,0x4D,0x3E];
        start2 = [0x9D,0x47,0x05];
        start3 = [0xDF,0x67,0x19];
        start4 = [0xFE,0x83,0x54];
        start5 = [0x251,0x15,0x29];
    }
    if(H>=0 && H<1){
        R = start0[0] + Math.round(H*(start1[0]-start0[0]));
        G = start0[1] + Math.round(H*(start1[1]-start0[1]));
        B = start0[2] + Math.round(H*(start1[2]-start0[2]));
    } else if(H>=1 && H<2){
        R = start1[0] + Math.round((H-1)*(start2[0]-start1[0]));
        G = start1[1] + Math.round((H-1)*(start2[1]-start1[1]));
        B = start1[2] + Math.round((H-1)*(start2[2]-start1[2]));
    } else if(H>=2 && H<3){
        R = start2[0] + Math.round((H-2)*(start3[0]-start2[0]));
        G = start2[1] + Math.round((H-2)*(start3[1]-start2[1]));
        B = start2[2] + Math.round((H-2)*(start3[2]-start2[2]));
    } else if(H>=3 && H<4){
        R = start3[0] + Math.round((H-3)*(start4[0]-start3[0]));
        G = start3[1] + Math.round((H-3)*(start4[1]-start3[1]));
        B = start3[2] + Math.round((H-3)*(start4[2]-start3[2]));
    } else if(H>=4 && H<=5){
        R = start4[0] + Math.round((H-4)*(start5[0]-start4[0]));
        G = start4[1] + Math.round((H-4)*(start5[1]-start4[1]));
        B = start4[2] + Math.round((H-4)*(start5[2]-start4[2]));  
    }

    return constructHexColor([R,G,B]);

}

//Misc///////////////////////////////////////////////////////////////////////////


function interpolateColor(oldColor, newColor, scale){
    var R, G, B;

    if(oldColor == 0xDEADBEEF || newColor == 0xDEADBEEF) return 0xDEADBEEF;

    R = Math.round((newColor[0] - oldColor[0])*scale + oldColor[0]);
    G = Math.round((newColor[1] - oldColor[1])*scale + oldColor[1]);
    B = Math.round((newColor[2] - oldColor[2])*scale + oldColor[2]);

    return 'rgba('+R+','+G+','+B+',1)';
}

function roundBox(context, leftX, topY, width, height, cornerRadius){
    
    context.moveTo(leftX, topY+cornerRadius);
    context.beginPath();
    context.arc(leftX+cornerRadius, topY+cornerRadius, cornerRadius, Math.PI, 3*Math.PI/2);
    context.lineTo(leftX+width-cornerRadius,topY);
    context.arc(leftX+width-cornerRadius, topY+cornerRadius, cornerRadius, 3*Math.PI/2, 0);
    context.lineTo(leftX+width, topY+height-cornerRadius);
    context.arc(leftX+width-cornerRadius, topY+height-cornerRadius, cornerRadius, 0, Math.PI/2);
    context.lineTo(leftX + cornerRadius, topY+height);
    context.arc(leftX+cornerRadius, topY+height-cornerRadius, cornerRadius, Math.PI/2, Math.PI);
    context.closePath();
}

function strokePolygon(context, nSides, x0, y0, spoke, phi){
    var i;
    context.save();
    context.translate(x0, y0);
    context.rotate(phi);
    context.moveTo(0, -spoke);
    for(i=0; i<nSides; i++){
        context.rotate(2*Math.PI/nSides);
        context.lineTo(0, -spoke);
    }
    context.stroke();
    context.restore();
}

//take a hex color string '#012345' and parse it into [R,G,B]
function parseHexColor(color){
    var R, G, B;

    if(color==0xDEADBEEF) return 0xDEADBEEF
        
    var number = String(color).slice(1,7)

    R = parseInt(number.slice(0,2), 16);
    G = parseInt(number.slice(2,4), 16);
    B = parseInt(number.slice(4,6), 16);

    return [R,G,B];
}

//invert the above function:
function constructHexColor(color){
    var R = Math.round(color[0]);
    var G = Math.round(color[1]);
    var B = Math.round(color[2]);

    R = R.toString(16);
    G = G.toString(16);
    B = B.toString(16);

    if(R.length == 1) R = '0'+R;
    if(G.length == 1) G = '0'+G;
    if(B.length == 1) B = '0'+B;

    return '#'+R+G+B;
}
/*
//draw a nicer sidebar background
function tabBKG(canvasID, side){

    var canvas = document.getElementById(canvasID);
    var context = canvas.getContext('2d');

    var width = $(canvas).width();
    var height = $(canvas).height();
    //console.log(canvasID + ': ' + height)
    var cornerRad = 20;
    var tailRad = 50;
    var lineWeight = 2;

    context.clearRect(0,0,width,height);

    if(side == 'left'){
        context.save()
        context.translate(width,0);
        context.scale(-1,1);   
    }

    context.fillStyle = '#4C4C4C';
    context.lineWidth = lineWeight;
    context.beginPath();
    context.moveTo(width,lineWeight);
    context.lineTo(cornerRad, lineWeight);
    context.arc(cornerRad+lineWeight, cornerRad+lineWeight, cornerRad, -Math.PI/2, -Math.PI, true);
    context.lineTo(lineWeight, height - cornerRad - tailRad);
    context.arc(cornerRad+lineWeight, height - tailRad - cornerRad, cornerRad, -Math.PI, Math.PI/2, true);
    context.lineTo(width - tailRad, height - tailRad);
    context.arc(width - tailRad, height, tailRad, -Math.PI/2, 0);
    context.closePath();
    context.fill();
    context.stroke();

    if(side== 'left'){
        context.restore();
    }

}
*/
//atom spinner:
function drawSpinner(canvasID, label){
    
    var canvas = document.getElementById(canvasID);
    var context = canvas.getContext('2d');
    var string = (label) ? label : 'LOADING';

        $('#spinner').css('left', window.innerWidth/2 - 100);
        $('#spinner').css('top', window.innerHeight/2 - 100);

    context.lineWidth = 5;
    context.strokeStyle = '#FFFFFF';
    context.fillStyle = 'rgba(0,0,0,0.7)';
    roundBox(context, 5, 5, 190, 190, 5);
    context.lineWidth = 1;
    context.fill();
    context.stroke();

    context.fillStyle = '#FFFFFF';
    context.font = '16px Arial'
    context.fillText(string, 100-context.measureText(string).width/2, 145);
    window.nProtons = 0;
    window.nNucleons = 0;

/*
    window.spinLoop = setInterval(function(){
        context = document.getElementById('spinner').getContext('2d');

        //choose proton or neutron:
        var nucleon = (Math.random() < 0.5) ? 'p' : 'n';
        window.nNucleons++;
        if(nucleon == 'p') window.nProtons++;
        //choose position on canvas
        var radius = Math.random()*15;
        var phi = Math.random()*Math.PI*2;

        //draw:
        context.strokeStyle = '#FFFFFF';
        context.fillStyle = (nucleon == 'p') ? '#FF0000' : '#0000FF';
        context.beginPath();
        context.arc(100+radius*Math.cos(phi), 100+radius*Math.sin(phi), 5, 0, Math.PI*2);
        context.closePath();
        context.fill();
        context.stroke();

        context.clearRect(20,20, 160, 55);
        context.fillStyle = 'rgba(0,0,0,0.7)'
        context.fillRect(20,20, 160, 55);
        context.fillStyle = '#FFFFFF';
        context.fillText('Z = '+window.nProtons, 70-context.measureText('Z = '+window.nProtons).width/2, 70);
        context.fillText('A = '+window.nNucleons, 130-context.measureText('N = '+window.nProtons).width/2, 70);

    }, 3);
*/    
}

function curveText(text, context, x0, y0, rad, startAngle){
    var textWidth = context.measureText(text).width,
        charRotation = startAngle,
        character, charWidth, nextChar, nextWidth, bothWidth, kern, extraRotation, charSegment;

    for (var i=0, l=text.length; i<l; i++) {
        character = nextChar || text[i];
        charWidth = nextWidth || context.measureText(character).width;

        // Rotate so the letter base makes a circle segment instead of a tangent
        extraRotation = (Math.PI/2) - Math.acos((charWidth/2) / rad);

        context.save();
        context.translate(x0, y0);
        context.rotate(charRotation);
        context.translate(0, -rad);
        context.rotate(extraRotation);
        context.fillText(character,0,0);
        context.restore();

        nextChar = text[i+1] || '';
        nextWidth = context.measureText(nextChar).width;

        bothWidth = context.measureText(character+nextChar).width;
        kern = bothWidth - charWidth - nextWidth;

        charSegment = (charWidth+kern) / textWidth; // percent of total text size this takes up
        charRotation += charSegment * (context.measureText(text).width/rad);
    }           
}

function arrow(context, x0, y0, x1, y1, headScale){
    context.beginPath();
    context.moveTo(x0,y0);
    context.lineTo(x1,y1);

    context.save();
    context.translate(x1, y1);
    context.rotate(Math.atan((x1-x0)/(y1-y0)));
    context.moveTo(-headScale, headScale);
    context.lineTo(0,0);
    context.lineTo(headScale, headScale);
    context.restore();
}

function closeX(context, x0, y0, radius){
    context.strokeStyle = '#FFFFFF';
    context.fillStyle = '#FF0000';
    context.lineWidth = 1;

    context.beginPath();
    context.arc(x0, y0, radius, 0, Math.PI*2, true);
    context.closePath();
    context.fill();
    context.stroke();

    context.beginPath();
    context.lineWidth = 1;
    context.moveTo(x0 - 0.4*radius, y0 - 0.4*radius);
    context.lineTo(x0 + 0.4*radius, y0 + 0.4*radius);
    context.stroke();
    
    context.moveTo(x0 + 0.4*radius, y0 - 0.4*radius);
    context.lineTo(x0 - 0.4*radius, y0 + 0.4*radius);
    context.stroke();
}

//draws a digit like on an old digital clock.  cells is an array describing which cells
//are lit, indexed 0-5 around the edge starting on top, and 6 for the middle bar.
function digitalDigit(cells, context, height, x0, y0){

    var cellWidth = 0.05*height,
        width = 0.5*height,
        cellHeight = 0.5*height;

    context.save();
    context.setTransform(1, -Math.tan(Math.PI/12), 0, 1, 0, 0);
    context.rotate(Math.tan(Math.PI/12));

    if(cells[0]){
        context.beginPath();
        context.moveTo(x0+cellWidth, y0);
        context.lineTo(x0+cellWidth+width, y0);
        context.lineTo(x0+width, y0+cellWidth);
        context.lineTo(x0+2*cellWidth, y0+cellWidth);
        context.closePath();
        context.fill();
    }

    if(cells[1]){
        context.beginPath();
        context.moveTo(x0+width+2*cellWidth, y0+cellWidth);
        context.lineTo(x0+width+2*cellWidth, y0+cellWidth+cellHeight);
        context.lineTo(x0+width+cellWidth, y0+cellHeight);
        context.lineTo(x0+width+cellWidth, y0+2*cellWidth);
        context.closePath();
        context.fill();
    }

    if(cells[2]){
        context.beginPath();
        context.moveTo(x0+width+2*cellWidth, y0+3*cellWidth+cellHeight);
        context.lineTo(x0+width+2*cellWidth, y0+3*cellWidth+2*cellHeight);
        context.lineTo(x0+width+cellWidth, y0+2*cellWidth+2*cellHeight);
        context.lineTo(x0+width+cellWidth, y0+4*cellWidth+cellHeight);     
        context.closePath();
        context.fill();   
    }

    if(cells[3]){
        context.beginPath();
        context.moveTo(x0+cellWidth+width, y0+4*cellWidth+2*cellHeight);
        context.lineTo(x0+cellWidth, y0+4*cellWidth+2*cellHeight);
        context.lineTo(x0+2*cellWidth, y0+3*cellWidth+2*cellHeight);
        context.lineTo(x0+width, y0+3*cellWidth+2*cellHeight);
        context.closePath();
        context.fill();
    }

    if(cells[4]){
        context.beginPath();
        context.moveTo(x0, y0+3*cellWidth+cellHeight);
        context.lineTo(x0, y0+3*cellWidth+2*cellHeight);
        context.lineTo(x0+cellWidth, y0+2*cellWidth+2*cellHeight);
        context.lineTo(x0+cellWidth, y0+4*cellWidth+cellHeight);
        context.closePath();
        context.fill();
    }

    if(cells[5]){
        context.beginPath();
        context.moveTo(x0, y0+cellWidth+cellHeight);
        context.lineTo(x0, y0+cellWidth);
        context.lineTo(x0+cellWidth, y0+2*cellWidth);
        context.lineTo(x0+cellWidth, y0+cellHeight);
        context.closePath();
        context.fill();
    }

    if(cells[6]){
        context.beginPath();
        context.moveTo(x0+cellWidth, y0+2*cellWidth+cellHeight);
        context.lineTo(x0+2*cellWidth, y0+1.5*cellWidth+cellHeight);
        context.lineTo(x0+width, y0+1.5*cellWidth+cellHeight);
        context.lineTo(x0+width+cellWidth, y0+2*cellWidth+cellHeight);
        context.lineTo(x0+width, y0+2.5*cellWidth+cellHeight);
        context.lineTo(x0+2*cellWidth, y0+2.5*cellWidth+cellHeight);
        context.closePath();
        context.fill();
    }

    context.restore();

}

//draw a flow-chart like branch
//    |         x0, y0
//    ---       
//      |       
//  ----------  x1, y1
//  |  |  |  |  combLength
//context == context to draw in
//combColors == array containing color of each comb end; length = number of comb tines (4 in ascii art above)
//combWidth == width of base of comb in px
//combLength length of tines
//branchColor == color of 3 branch segments and comb spine
//x0, y0 == coordinates of branch root
//x1, y1 == coordinates of branch / comb join
function drawBranch(context, combColors, combWidth, combLength, branchColor, x0, y0, x1, y1){

    var nTine = combColors.length,
        tineSpacing = combWidth / (nTine-1),
        branchHeight = y1-y0;
        branchWidth = x1-x0;
        i;

    //draw branch and spine of comb:
    context.strokeStyle = branchColor;
    context.beginPath();
    context.moveTo(x0, y0);
    context.lineTo(x0, y0 + branchHeight/2);
    context.lineTo(x0 + branchWidth, y0 + branchHeight/2);
    context.lineTo(x0 + branchWidth, y0 + branchHeight);
    context.moveTo(x0 + branchWidth - combWidth / 2 - parseFloat(context.lineWidth)/2, y0 + branchHeight);
    context.lineTo(x0 + branchWidth + combWidth / 2 + parseFloat(context.lineWidth)/2, y0 + branchHeight);
    context.stroke();

    //draw tines
    for(i=0; i<nTine; i++){
        context.strokeStyle = combColors[i];
        context.beginPath();
        context.moveTo(x0 + branchWidth - combWidth / 2 + i*tineSpacing, y0 + branchHeight + parseFloat(context.lineWidth)/2);
        context.lineTo(x0 + branchWidth - combWidth / 2 + i*tineSpacing, y0 + branchHeight + combLength);
        context.stroke();
    }
}
//meter that fills to show the level of a scalar, with decorations.
function FillMeter(cvas, wrapperDiv, width, min, max, unit, precision){

    this.oldFillLevel = 0;
    this.fillLevel = 0;
    this.min = min;
    this.max = max;
    this.unit = unit;
    this.xPos = 0;  //left margin of value label
    this.wrapperDiv = wrapperDiv;
    this.precision = precision;

    //fetch canvas:
    this.canvas = document.getElementById(cvas);
    this.context = this.canvas.getContext('2d');
    this.context.font = "16px Raleway";

    //determine canvas width:
    var divWidth = parseFloat($('#'+wrapperDiv).css('width'));
    //remove margins and spacing:
    var canvWidth = 0.88*divWidth;
    //remove title length:
    canvWidth = canvWidth - $(document.getElementById(cvas+'Title')).width()*1.1;
    //set canvas dimensions
    this.canvas.width = canvWidth;
    this.canvas.height = 45;

    //width == 0 requests autoscaling of bar 
    if(width == 0){
        //leave some room for max reporting and right margin:
        this.width = canvWidth - 0.25*divWidth;
        
    } else this.width = width;

    //center of left end semicircle:
    this.leftX0 = divWidth*0.02;//this.width*0.1;
    this.leftY0 = this.canvas.height / 2;
    //meter half-thickness:
    this.radius = 5;
    //center of right end semicircle:
    this.rightX0 = this.leftX0 + this.width; //this.width*0.8;
    this.rightY0 = this.canvas.height / 2;
    //boundary of fill line:
    this.fillTo = this.fillLevel*(this.rightX0 - this.leftX0) + this.leftX0;

    //animation parameters:
    this.duration = 0.4; //seconds
    this.FPS = 30;
    this.nFrames = this.duration*this.FPS;

    //flag to indicate bar is pointing at a channel that doesn't report current
    this.notReporting = 0;

    //set up empty meter:
       //draw bar shadow:
        this.context.lineWidth = 1;
        this.context.beginPath();
        this.context.arc(this.leftX0+1, this.leftY0+1, this.radius, Math.PI/2, 3*Math.PI/2);
        this.context.arc(this.rightX0+1, this.rightY0+1, this.radius, 3*Math.PI/2, Math.PI/2);
        this.context.closePath();
        this.context.stroke();

        //draw empty bar:
        this.context.lineWidth = 1;
        this.context.beginPath();
        this.context.arc(this.leftX0, this.leftY0, this.radius, Math.PI/2, 3*Math.PI/2);
        this.context.arc(this.rightX0, this.rightY0, this.radius, 3*Math.PI/2, Math.PI/2);
        this.context.closePath();
        this.context.stroke();    

    //change the fill level and related parameters
    this.setNewFillLevel = function(newLevel){
        //empty meter if nothing to report:
        if(newLevel == '--') newLevel = this.min;

        //establish fill level
        this.oldFillLevel = this.fillLevel;
        this.fillLevel = this.fillLevel = (newLevel - this.min) / (this.max - this.min);
        this.fillTo = newLevel*(this.rightX0 - this.leftX0) + this.leftX0;

    };

    //draw a meter at frame <frame> when transitioning between this.oldFillLevel and this.fillLevel:
    this.draw = function(frame){

        //fill level for this frame:
        var frameFill = this.oldFillLevel + (this.fillLevel - this.oldFillLevel) * frame / this.nFrames;

        //determine fill coordinate:
        var fillLimit = frameFill*(this.rightX0 - this.leftX0) + this.leftX0;

        //draw empty bar:
        this.context.lineWidth = 1;
        this.context.fillStyle = 'rgba(255,255,255,1)';
        this.context.beginPath();
        this.context.arc(this.leftX0, this.leftY0, this.radius, Math.PI/2, 3*Math.PI/2);
        this.context.arc(this.rightX0, this.rightY0, this.radius, 3*Math.PI/2, Math.PI/2);
        this.context.closePath();
        this.context.fill();
        this.context.stroke();

        //draw bar fill:
        this.context.lineWidth = 1;
        this.context.fillStyle = 'rgba(0,0,255,0.3)';
        this.context.beginPath();
        this.context.arc(this.leftX0, this.leftY0, this.radius, Math.PI/2, 3*Math.PI/2);
        this.context.arc(fillLimit, this.rightY0, this.radius, 3*Math.PI/2, Math.PI/2);
        this.context.closePath();
        this.context.fill();    

        //quote value above fill position:
        this.context.clearRect(0,0, this.rightX0+this.width, this.rightY0-this.radius);
        this.context.fillStyle = 'rgba(255,255,255,0.9)';
        this.context.font = "16px Raleway";
        if(this.notReporting){ 
            fillString = 'Unavailable';
            this.context.font = '10px Raleway';
        } 
        else fillString = (frameFill*(this.max-this.min)+this.min).toFixed(this.precision)+' '+this.unit;
        this.xPos = fillLimit - this.context.measureText(fillString).width/2;
        if(this.xPos < this.leftX0) {
            this.xPos = this.leftX0
        }
        if(this.xPos + this.context.measureText(fillString).width > this.rightX0){
            this.xPos = this.rightX0 - this.context.measureText(fillString).width;
        }
        this.context.fillText(fillString, this.xPos, this.leftY0-1.7*this.radius);

        //quote meter max to right of meter:
        this.context.font = '12px Raleway';
        this.context.clearRect(this.rightX0+this.radius, 0, this.width, 45);
        if(this.notReporting == 0) this.context.fillText('Max: '+this.max.toFixed(0)+' '+this.unit, this.rightX0 + 1.5*this.radius, this.rightY0 + 5);
        
    };

    //wrapper for transition from old state to new state via this.animate:
    this.update = function(newLevel){

        if(newLevel == '--'){
            this.notReporting = 1;
        } else {
            this.notReporting = 0;
        }
            //set up member variables for animation:
            this.setNewFillLevel(newLevel);

            //animate:
            animate(this, 0);

    };

}function histofit(){

	///////////////////////////////////////////
	/////member variables//////////////////////
	///////////////////////////////////////////
	//Input
	this.x = []; //independent variables
	this.y = []; //dependent variables
	this.fxn = null; //function to fit, form: function(independent variable, [array of fittable parameters])
	this.guess = []; //initial fit guess

	//Output
	this.param = []; //fit parameters

	//Config
	this.stepSize = 1;  //initial size of step to take along gradient towards minima

	///////////////////////////////////////////
	/////member functions//////////////////////
	///////////////////////////////////////////

	//log probability of n counts in a bin where lambda were expected:
	this.logPoisson = function(n, lambda){
		var i, N=0;
		for(i=1; i<=n; i++)
			N += i;
//console.log([n, lambda, N])
		return n*Math.log(lambda) - lambda - N;
	}

	//negative log likelihood of seeing the observed spectrum given the theory function and <param> array
	this.NegLL = function(param){
		var lambda, i, 
		nll = 0;

		for(i=0; i<this.x.length; i++){
			lambda = this.fxn.bind(this, this.x[i], param)();
//console.log(lambda)
			nll -= this.logPoisson(this.y[i], lambda);
		}
//console.log(nll)
		return nll;
	}

	//derivative in negative log likelihood space along parameter index <dim> at parameter config <param>:
	this.nllDer = function(param, dim){
		var tol = 0.000001,
			dtol1, dtol2, Xhi=[], Xlo=[], Xhi2=[], Xlo2=[], vary, D;

		for(vary = 0; vary < param.length; vary++){
			Xhi[vary] = param[vary];
			Xlo[vary] = param[vary];
			Xhi2[vary] = param[vary];
			Xlo2[vary] = param[vary];
		}
	    Xhi[dim]  += tol;
	    Xlo[dim]  -= tol;
	    Xhi2[dim] += tol / 2;
	    Xlo2[dim] -= tol / 2;

	    dtol = (this.NegLL.bind(this, Xhi)() - this.NegLL.bind(this, Xlo)()) / (2*tol);
	    dtol2 = (this.NegLL.bind(this, Xhi2)() - this.NegLL.bind(this, Xlo2)()) / tol;

	    D = (4*dtol2-dtol)/3;
//console.log(Xhi)
//console.log(Xlo)
//console.log(D)
	    return D;
	}

	//gradient in negative log likelihood space:
	this.nllGrad = function(param){
		var grad = [],
			i, length=0;

		for(i=0; i<param.length; i++){
			grad[i] = this.nllDer(param, i);
			length += Math.pow(grad[i],2);
		}
		length = Math.sqrt(length);
		//normalize
		for(i=0; i<param.length; i++){
			grad[i] /= length;
		}

//console.log(grad)
		return grad;
	}

	//converge a fit
	this.fitit = function(){
		var i, grad, NLL, newNLL,
			dNLL = 1000,
			tolerance = 0.0001,
			limit = 1000;

		//demand same length of this.x and this.y
		if(this.x.length != this.y.length){
			console.log('length of input and output arrays must be equal; fit aborted.')
			return;
		}

		for(i=0; i<this.guess.length; i++)
			this.param[i] = this.guess[i];

		while(Math.abs(dNLL) > tolerance && limit>0){

			NLL = this.NegLL(this.param);
			grad = this.nllGrad(this.param);
//console.log(grad)
			//step towards mimium
			for(i=0; i<this.param.length; i++){
				this.param[i] -= grad[i]*this.stepSize;
			}

			newNLL = this.NegLL(this.param);

			//take smaller steps as we approach minimum
			if(newNLL > NLL)
				this.stepSize = this.stepSize/2;

			dNLL = newNLL - NLL;
			limit--;

		}
		this.stepSize = 1;

	}
};
//collect the form input and do something with it.  Expect form 'setValues', which
//begins with a pair of radio buttons for channel on off, then has an arbitrary 
//no. of text fields for inputting whatever else.

function updateParameter(){

	var i;
    
	var userInputs = [];

    //clear commit button highlighting:
    unhighlight('submitParameters');

    //loop over all elements in the form except the first three (off/on/submit)
	for(i=3; i<document.getElementById('setValues').elements.length; i++){
		userInputs[i-3] = getInput('setValues', i);
	}

    //determine where this cell falls in MIDAS vector:
    var ODBindex = getMIDASindex(window.HVpointer.dialogY, window.HVpointer.dialogX, window.HVview);

    //switch channel on/off
    if(document.getElementById('onButton').checked == true){
      ODBSet("/Equipment/HV-"+window.HVview+"/Settings/ChState["+ODBindex+"]",1);
    }
    else{
      ODBSet("/Equipment/HV-"+window.HVview+"/Settings/ChState["+ODBindex+"]",0);
    }

    //set demand voltage:
    ODBSet("/Equipment/HV-"+window.HVview+"/Variables/Demand["+ODBindex+"]", parseFloat(userInputs[0]));

    //set ramp up voltage:
    ODBSet("/Equipment/HV-"+window.HVview+"/Settings/Ramp Up Speed["+ODBindex+"]", parseFloat(userInputs[1]));

    //set ramp down voltage:
    ODBSet("/Equipment/HV-"+window.HVview+"/Settings/Ramp Down Speed["+ODBindex+"]", parseFloat(userInputs[2]));

    //once the ODB has been updated, kick the loop to update immediately:
    clearTimeout(window.loop);
    startLoop();

}

//extract information from the field at position <fieldIndex> from a form with id = <formID>
function getInput(formId, fieldIndex){
    var oForm = document.getElementById(formId);
    var oText = oForm.elements[fieldIndex];
    return oText.value;
}

//set values in fields:
function setInput(formId, fieldIndex, setval){
    var oForm = document.getElementById(formId);
    var oText = oForm.elements[fieldIndex];
    oText.value = setval;
}

//dismiss the form without doing anything else:
function abortUpdate(InputLayer){
	var inputDiv = document.getElementById(InputLayer);
	divFade(inputDiv, 'out', 0);
}

//fade the form in / out:
function divFade(targetDiv, direction, frame){

	var FPS = 40;
	var duration = 0.1;
	var nFrames = FPS*duration;
	var alpha;
	var maxOpacity = 0;

	if(frame <= nFrames){
		if(direction === 'in'){
			alpha = maxOpacity*frame/nFrames;
			$(targetDiv).css('background', 'rgba(0,0,0,'+alpha+')');
			targetDiv.style.display = 'block';

		} else if(direction === 'out'){
			alpha = maxOpacity-maxOpacity*frame/nFrames;
			$(targetDiv).css('background', 'rgba(0,0,0,'+alpha+')');
		}
		frame++;

		setTimeout(function(){divFade(targetDiv, direction, frame)}, 1000/FPS);
	} else if(direction === 'out'){
		targetDiv.style.display = 'none';
	}

}

//plugs a new cell into the input interface; used for both onclicks on the waffles, and on button submits 
//in the sidepanel view.
function channelSelect(waffle){

    var inputTitle

    //determine horizontal binning
    var xIndex;
    if(waffle.chy == 0) xIndex = primaryBin(window.parameters.moduleSizes[window.HVview], waffle.chx);
    else xIndex = waffle.chx;

    //Throw up to global so the setter remembers where we're pointing.  TODO: refactor without globals?
    window.HVpointer.dialogX = xIndex;//waffle.chx;
    window.HVpointer.dialogY = waffle.chy;
	
    var superDiv = document.getElementById(waffle.wrapperDiv);
    var inputDiv = document.getElementById(waffle.InputLayer);

    //set text in dialog box:
    if(waffle.chy != 0) inputTitle = 'Parameters for <br>'+waffle.moduleLabels[primaryBin(window.parameters.moduleSizes[window.HVview], waffle.chx)]+', Ch. '+channelMap(waffle.chx, waffle.chy, window.parameters.moduleSizes[window.HVview], waffle.rows) + ' (' + waffle.dataBus[window.HVview].channelName[waffle.chy][xIndex] + ')';
    else inputTitle = 'Parameters for <br>'+waffle.moduleLabels[primaryBin(window.parameters.moduleSizes[window.HVview], waffle.chx)]+' Primary';
    document.getElementById('inputTitle').innerHTML = inputTitle;

    //these objects get updated every masterLoop:
    //report status word:
    document.getElementById('status').innerHTML = 'Status: '+ ((waffle.dataBus[window.HVview].channelMask[waffle.chy][xIndex] == 0) ? 'Off' : parseStatusWord(waffle.dataBus[window.HVview].rampStatus[waffle.chy][xIndex]));
    //report current & update voltage slider and meter maximum:
    if(waffle.chy == 0 || window.parameters.moduleSizes[window.HVview][primaryBin(window.parameters.moduleSizes[window.HVview], waffle.chx)]==1 || window.parameters.moduleSizes[window.HVview][primaryBin(window.parameters.moduleSizes[window.HVview], waffle.chx)]==2){
        waffle.voltageSlider.max = waffle.dataBus[window.HVview].voltLimit[waffle.chy][xIndex];
        meter.max = waffle.dataBus[window.HVview].voltLimit[waffle.chy][xIndex];
        currentMeter.max = waffle.dataBus[window.HVview].currentLimit[waffle.chy][xIndex];
        currentMeter.update(Math.round(waffle.dataBus[window.HVview].reportCurrent[waffle.chy][xIndex]*10000)/10000)
    }
    else{
        waffle.voltageSlider.max = waffle.dataBus[window.HVview].voltLimit[0][primaryBin(window.parameters.moduleSizes[window.HVview], waffle.chx)];
        meter.max = waffle.dataBus[window.HVview].voltLimit[0][primaryBin(window.parameters.moduleSizes[window.HVview], waffle.chx)];
        currentMeter.max = waffle.dataBus[window.HVview].currentLimit[0][primaryBin(window.parameters.moduleSizes[window.HVview], waffle.chx)];
        currentMeter.update('--');
    }

    //update meter position after maximum has been adjusted:
    meter.update(Math.round(waffle.dataBus[window.HVview].reportVoltage[waffle.chy][xIndex]*10000)/10000);
    temperatureMeter.update(Math.round(waffle.dataBus[window.HVview].reportTemperature[waffle.chy][xIndex]*100)/100);

    if(window.refreshInput){
        //set defaults
        if (waffle.dataBus[window.HVview].channelMask[waffle.chy][xIndex] == 1) document.getElementById('onButton').checked = true;
        else document.getElementById('offButton').checked = true;

        //manage sliders
        waffle.voltageSlider.update(Math.round(waffle.dataBus[window.HVview].demandVoltage[waffle.chy][xIndex]*10000)/10000);
        waffle.rampSlider.update(Math.round(waffle.dataBus[window.HVview].demandVrampUp[waffle.chy][xIndex]*10000)/10000);
        waffle.rampDownSlider.update(Math.round(waffle.dataBus[window.HVview].demandVrampDown[waffle.chy][xIndex]*10000)/10000);
        window.refreshInput = 0;

        //set the module
        setInput('changeChannel',0,waffle.moduleLabels[primaryBin(window.parameters.moduleSizes[window.HVview], waffle.chx)]);
        //update channel number list
        reconfigureChannelList(waffle.moduleLabels, window.parameters.moduleSizes[window.HVview], 'ChannelList');
        //set the channel number
        setInput('changeChannel',1,channelMap(waffle.chx, waffle.chy, window.parameters.moduleSizes[window.HVview], waffle.rows));
        if(waffle.chy==0) setInput('changeChannel',1,'Primary');

        //abandon the please update me flag when navigating away from the channel:
        unhighlight('submitParameters');
    }

    //only actually display if the click was on the waffle and not the rest of the canvas:
    if(waffle.chx < waffle.cols && waffle.chy < waffle.rows){
        divFade(inputDiv, 'in', 0);
    }

}

//point interface at new channel indicated by user in the 'changeChannel' form.
function gotoNewChannel(event, waffle){
    var i;
 
    //determine y bin:
    var yVal = getInput('changeChannel', 1);
    if(yVal != 'Primary') yVal = parseInt(yVal);
    if (yVal == 'Primary') waffle.chy = 0;
    else waffle.chy = yVal%(waffle.rows-1)+1;

    //determine x bin:
    var xName = getInput('changeChannel', 0);
    //have to map column titles onto index
    var xVal;
    for(var i=0; i<window.parameters.moduleSizes[window.HVview].length; i++){
        if(waffle.moduleLabels[i] == xName) xVal = i;
    }
    waffle.chx = 0;
    for(i=0; i<xVal; i++) waffle.chx += Math.max(window.parameters.moduleSizes[window.HVview][i], 1);
    if(yVal != 'Primary') waffle.chx += Math.floor(yVal/(waffle.rows-1));

    channelSelect(waffle);
}

function parseStatusWord(statusCode){

    if(statusCode == 0) return 'Off';
    else if(statusCode == 1) return 'On';
    else if(statusCode == 3) return 'Ramping Up';
    else if(statusCode == 5) return 'Ramping Down';
    else if(statusCode == 256) return 'External Disable';
    else return 'Unknown Error';
}




/*
Copyright (c) 2014 Bill Mills

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
function spectrumViewer(canvasID){

	////////////////////////////////////////////////////////////////////////
	//member variables//////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	//canvas & context
	this.canvasID = canvasID; //canvas ID
	this.canvas = document.getElementById(canvasID); //dom element pointer to canvas
	this.canvas.style.backgroundColor = '#333333';
	this.context = this.canvas.getContext('2d'); //context pointer
	this.stage = new createjs.Stage(canvasID);  //transform the canvas into an easelJS sandbox
	this.containerMain = new createjs.Container(); //layer for main plot
	this.containerOverlay = new createjs.Container(); //layer for overlay: cursors, range highlights
	this.containerPersistentOverlay = new createjs.Container(); //layer for persistent overlay features
	this.containerFit = new createjs.Container(); //layer for fit curves
	this.stage.addChild(this.containerMain);
	this.stage.addChild(this.containerOverlay);
	this.stage.addChild(this.containerPersistentOverlay);
	this.stage.addChild(this.containerFit);

	//axes & drawing
	this.fontScale = Math.min(Math.max(this.canvas.width / 50, 10), 16); // 10 < fontScale < 16
	this.context.font = this.fontScale + 'px Arial';
	this.leftMargin = Math.max(7*this.fontScale, this.canvas.width*0.05); //px
	this.rightMargin = 20; //px
	this.bottomMargin = 50; //px
	this.topMargin = 20; //px
	this.xAxisPixLength = this.canvas.width - this.leftMargin - this.rightMargin; //px
	this.yAxisPixLength = this.canvas.height - this.topMargin - this.bottomMargin; //px
	this.binWidth = 0; //px
	this.XaxisLimitMin = 0; //default min channel to show on x-axis
	this.XaxisLimitMax = 2048; //default max channel to show on x-axis
	this.YaxisLimitMin = 0; //default min counts to show on y-axis
	this.YaxisLimitMax = 500; //default max counts to show on y-axis
	this.XaxisLimitAbsMax = 512; //highest maximum allowed on the x-axis
	this.XaxisLength = this.XaxisLimitMax-this.XaxisLimitMin; //length of x-axis in bins
	this.YaxisLength = this.YaxisLimitMax-this.YaxisLimitMin; //height of y-axis in counts
	this.countHeight = 0; //height of one count
	this.axisColor = '#999999'; //color for axes
	this.axisLineWidth = 1; //weight of axis lines in px
	this.nXticks = 6; //default number of ticks on the x axis
	this.nYticks = 5; //default number of ticks on the y axis
	this.tickLength = 5; //default tick length in px
	this.xLabelOffset = 5; //default x label offset in px
	this.yLabelOffset = 5; //default y label offset in px
	this.AxisType = 0; //0 == linear, 1 == log
	this.baseFont = '16px Arial'; //default base font
	this.expFont = '12px Arial'; //default font for exponents
	this.xAxisTitle = 'Channels'; //default x-axis title
	this.yAxisTitle = 'Counts'; //default y-axis title
	this.drawCallback = function(){}; //callback after plotData, no arguments passed.
	this.demandXmin = null; //override values for x and y limits, to be used in favour of automatically detected limits.
	this.demandXmax = null;
	this.demandYmin = null;
	this.demandYmax = null;
	this.minY = 0; //minimum Y value currently being plotted
	this.maxY = 1000000; //max Y value currently being plotted
	this.chooseLimitsCallback = function(){};

	//data
	this.plotBuffer = {}; //buffer holding all the spectra we have on hand, packed as 'name':data[], where data[i] = counts in channel i
	this.fakeData = {};
	this.fakeData.energydata0 = [200,48,42,48,58,57,59,72,85,68,61,60,72,147,263,367,512,499,431,314,147,78,35,22,13,9,16,7,10,13,5,5,3,1,2,4,0,1,1,1,0,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,111,200,80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,80,120,70,20,20,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,300,650,200,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
	this.entries = {}; //number of entries in each displayed spectrum
	this.dataColor = ["#FFFFFF", "#FF0000", "#00FFFF", "#44FF44", "#FF9900", "#0066FF", "#FFFF00", "#FF00CC", "#00CC00", "#994499"]; //colors to draw each plot line with
	this.colorAssignment = [null, null, null, null, null, null, null, null, null, null]; //holds the data series key in the array position corresponding to the color to draw it with from this.dataColor
	this.hideSpectrum = {}; //any spectrum name used as a key holding a truthy value here will be skipped during plotting

	//fitting
	this.fitTarget = null //id of the spectrum to fit to
	this.fitted = false; //has the spectrum been fit since the last repaint?
	this.fitModeEngage = false; //are we currently fitting the spectrum?
	this.FitLimitLower = -1; //fitting limits
	this.FitLimitUpper = -1;
	this.fitCallback = function(){}; //callback to run after fitting, arguments are (center, width)
	this.MLfit = true; //do a maximum likelihood fit for putting gaussians on peaks; otherwise fit just estimates gaussian form mode and half-max

    //cursors
    this.cursorX = 0; //x-bin of cursor
    this.cursorY = 0; //y-bin of cursor
    this.mouseMoveCallback = function(){}; //callback on moving the cursor over the plot, arguments are (x-bin, y-bin)
    this.highlightColor = '#8e44ad'; //color of drag highlight

    //click interactions
    this.XMouseLimitxMin = 0; //limits selected with the cursor
    this.XMouseLimitxMax = 0;
    this.clickBounds = [];

	//plot repaint loop
	this.RefreshTime = 3; //seconds to wait before a plot refresh when requested
	this.refreshHandler = null; //pointer to the plot's setTimeout when a repaint is requested

	////////////////////////////////////////////////////////////////
	//member functions//////////////////////////////////////////////
	////////////////////////////////////////////////////////////////
	//draw the plot frame
	this.drawFrame = function(){
		var binsPerTick, countsPerTick, i, label;
		var axis, tick, text;

		//determine bin render width
		this.binWidth = this.xAxisPixLength / (this.XaxisLimitMax - this.XaxisLimitMin);
		//determine the scale render height per count for linear view:
		this.countHeight = this.yAxisPixLength / this.YaxisLength;

		//clear canvas
		this.containerMain.removeAllChildren();
		this.containerOverlay.removeAllChildren();

		//draw principle axes:
		axis = new createjs.Shape();
		axis.graphics.ss(this.axisLineWidth).s(this.axisColor);
		axis.graphics.mt(this.leftMargin, this.topMargin);
		axis.graphics.lt(this.leftMargin, this.canvas.height-this.bottomMargin);
		axis.graphics.lt(this.canvas.width - this.rightMargin, this.canvas.height - this.bottomMargin);
		axis.graphics.lt(this.canvas.width - this.rightMargin, this.topMargin);
		this.containerMain.addChild(axis);


		//Decorate x axis////////////////////////////////////////////////////////
		//decide how many ticks to draw on the x axis; come as close to a factor of the number of bins as possible:
		this.nXticks = 6;
		while( Math.floor(this.XaxisLength / this.nXticks) == Math.floor(this.XaxisLength / (this.nXticks-1)) )
			this.nXticks--;
		//draw at most one tick per bin:
		if(this.XaxisLength < (this.nXticks-1) )
			this.nXticks = this.XaxisLength+1;

		//how many bins should there be between each tick?
		binsPerTick = Math.floor((this.XaxisLimitMax - this.XaxisLimitMin) / (this.nXticks-1));

		//draw x axis ticks & labels:
		for(i=0; i<this.nXticks; i++){
			//ticks
			tick = new createjs.Shape();
			tick.graphics.ss(this.axisLineWidth).s(this.axisColor);
			tick.graphics.mt(this.leftMargin + i*binsPerTick*this.binWidth, this.canvas.height - this.bottomMargin);
			tick.graphics.lt(this.leftMargin + i*binsPerTick*this.binWidth, this.canvas.height - this.bottomMargin + this.tickLength);
			this.containerMain.addChild(tick);

			//labels
			label = (this.XaxisLimitMin + i*binsPerTick).toFixed(0);
			text = new createjs.Text(label, this.context.font, this.axisColor);
			text.textBaseline = 'top';
			text.x = this.leftMargin + i*binsPerTick*this.binWidth - this.context.measureText(label).width/2;
			text.y = this.canvas.height - this.bottomMargin + this.tickLength + this.xLabelOffset;
			this.containerMain.addChild(text);

		}

		//Decorate Y axis/////////////////////////////////////////////////////////
		//decide how many ticks to draw on the y axis; come as close to a factor of the number of bins as possible:
		this.nYticks = 5;
		while( Math.floor(this.YaxisLength / this.nYticks) == Math.floor(this.YaxisLength / (this.nYticks-1)) )
			this.nYticks--;

		//how many counts should each tick increment?
		countsPerTick = Math.floor(this.YaxisLength / (this.nYticks-1));

		//draw y axis ticks and labels:
		for(i=0; i<this.nYticks; i++){
			//ticks
			tick = new createjs.Shape();
			tick.graphics.ss(this.axisLineWidth).s(this.axisColor);
			tick.graphics.mt(this.leftMargin, this.canvas.height - this.bottomMargin - i*countsPerTick*this.countHeight);
			tick.graphics.lt(this.leftMargin - this.tickLength, this.canvas.height - this.bottomMargin - i*countsPerTick*this.countHeight);
			this.containerMain.addChild(tick);

			//labels
			//this.context.textBaseline = 'middle';
			if(this.AxisType == 0){ //linear scale
				label = (this.YaxisLimitMax<10000) ? (i*countsPerTick + this.YaxisLimitMin).toFixed(0) : (i*countsPerTick + this.YaxisLimitMin).toExponential(1);
				text = new createjs.Text(label, this.context.font, this.axisColor);
				text.textBaseline = 'middle';
				text.x = this.leftMargin - this.tickLength - this.yLabelOffset - this.context.measureText(label).width;
				text.y = this.canvas.height - this.bottomMargin - i*countsPerTick*this.countHeight;
				this.containerMain.addChild(text);
			} else {  //log scale
				label = i*countsPerTick + Math.floor(Math.log10(this.YaxisLimitMin));
				//exponent
				text = new createjs.Text(label, this.context.expFont, this.axisColor);
				text.textBaseline = 'middle';
				text.x = this.leftMargin - this.tickLength - this.yLabelOffset - this.context.measureText(label).width;
				text.y = this.canvas.height - this.bottomMargin - i*countsPerTick*this.countHeight - 10;
				this.containerMain.addChild(text);
				//base
				text = new createjs.Text(10, this.context.baseFont, this.axisColor);
				text.textBaseline = 'middle';
				text.x = this.leftMargin - this.tickLength - this.yLabelOffset - this.context.measureText('10'+label).width;
				text.y = this.canvas.height - this.bottomMargin - i*countsPerTick*this.countHeight;
				this.containerMain.addChild(text);				
			}
		}

		//x axis title:
		text = new createjs.Text(this.xAxisTitle, this.context.font, this.axisColor);
		text.textBaseline = 'bottom';
		text.x = this.canvas.width - this.rightMargin - this.context.measureText(this.xAxisTitle).width;
		text.y = this.canvas.height - this.fontScale/2;
		this.containerMain.addChild(text);

		//y axis title:
		text = new createjs.Text(this.yAxisTitle, this.context.font, this.axisColor);
		text.textBaseline = 'alphabetic';
		text.rotation = -90;
		text.x = this.leftMargin*0.25;
		text.y = this.context.measureText(this.yAxisTitle).width + this.topMargin;
		this.containerMain.addChild(text);		

	};

	//update the plot
	this.plotData = function(RefreshNow){
		var i, j, data, thisSpec, totalEntries, color,
		thisData = [];
		this.entries = {};
		var text, histLine;
		
		//abandon the fit when re-drawing the plot
		this.fitted = false;

		//get the axes right
		this.chooseLimits();	

		this.drawFrame();

		// Now the limits are set loop through and plot the data points
		j = 0; //j counts plots in the drawing loop
		for(thisSpec in this.plotBuffer){
			//skip hidden spectra
			if(this.hideSpectrum[thisSpec]) continue;			

			color = this.dataColor[this.colorAssignment.indexOf(thisSpec)];
			text = new createjs.Text(thisSpec + ': '+this.entries[thisSpec] + ' entries', this.context.font, color);
			text.textBaseline = 'top';
			text.x = this.canvas.width - this.rightMargin - this.context.measureText(thisSpec + ': '+this.entries[thisSpec] + 'entries').width - this.fontScale;
			text.y = (j+1)*this.fontScale;
			this.containerMain.addChild(text);

			// Loop through the data spectrum that we have
			histLine = new createjs.Shape();
			histLine.graphics.ss(this.axisLineWidth).s(color);
			//histLine.graphics.mt(this.leftMargin, this.canvas.height - this.bottomMargin);
			for(i=Math.floor(this.XaxisLimitMin); i<Math.floor(this.XaxisLimitMax); i++){

				// Protection at the end of the spectrum (minimum and maximum X)
				if(i<this.XaxisLimitMin || i>this.XaxisLimitMax) continue;

				// Protection in Overlay mode for spectra which are shorter (in x) than the longest spectrum overlayed.
				if(i==this.plotBuffer[thisSpec].length){
					//left side of bar
					histLine.graphics.lt( this.leftMargin + (i-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin );				
				} else if(i<this.plotBuffer[thisSpec].length){

					if(this.AxisType==0){
						//draw canvas line:
						//left side of bar
						if(i != Math.floor(this.XaxisLimitMin))
							histLine.graphics.lt( this.leftMargin + (i-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin - Math.max(0,(this.plotBuffer[thisSpec][i] - this.YaxisLimitMin))*this.countHeight );
						else
							histLine.graphics.mt( this.leftMargin + (i-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin - Math.max(0,(this.plotBuffer[thisSpec][i] - this.YaxisLimitMin))*this.countHeight );
						//top of bar
						histLine.graphics.lt( this.leftMargin + (i+1-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin - Math.max(0,(this.plotBuffer[thisSpec][i] - this.YaxisLimitMin))*this.countHeight );
					}

					if(this.AxisType==1){
						//draw canvas line:
						if(this.plotBuffer[thisSpec][i] > 0){
							//left side of bar
							if( i != Math.floor(this.XaxisLimitMin))
								histLine.graphics.lt( this.leftMargin + (i-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin - Math.max(0, (Math.log10(this.plotBuffer[thisSpec][i]) - Math.log10(this.YaxisLimitMin)))*this.countHeight );
							else
								histLine.graphics.mt( this.leftMargin + (i-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin - Math.max(0, (Math.log10(this.plotBuffer[thisSpec][i]) - Math.log10(this.YaxisLimitMin)))*this.countHeight );
							//top of bar
							histLine.graphics.lt( this.leftMargin + (i+1-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin - Math.max(0, (Math.log10(this.plotBuffer[thisSpec][i]) - Math.log10(this.YaxisLimitMin)))*this.countHeight );
						} else {
							//drop to the x axis
							if( i != Math.floor(this.XaxisLimitMin) )
								histLine.graphics.lt( this.leftMargin + (i-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin );
							else
								histLine.graphics.mt( this.leftMargin + (i-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin );
							//crawl along x axis until log-able data is found:
							histLine.graphics.lt( this.leftMargin + (i+1-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin );
						}
					}

				} else continue;
			}
			//finish the canvas path:
			//if(this.plotBuffer[thisSpec].length == this.XaxisLimitMax) 
			//	histLine.graphics.lt(this.canvas.width - this.rightMargin, this.canvas.height - this.bottomMargin );
			this.containerMain.addChild(histLine);
			j++;
		} // End of for loop
		this.stage.update();

		//callback
		this.drawCallback();

		// Pause for some time and then recall this function to refresh the data display
		if(this.RefreshTime>0 && RefreshNow==1) this.refreshHandler = setTimeout(function(){plotData(1, 'true')},this.RefreshTime*1000); 	
	};

	//handle drag-to-zoom on the plot
	this.DragWindow = function(){
		var buffer;

		//don't even try if there's only one bin selected:
		if(this.XMouseLimitxMin != this.XMouseLimitxMax){
			//don't confuse the click limits with the click and drag limits:
			this.clickBounds[0] = 'abort';

			//Make sure the max is actually the max:
			if(this.XMouseLimitxMax < this.XMouseLimitxMin){
				buffer = this.XMouseLimitxMax;
				this.XMouseLimitxMax = this.XMouseLimitxMin;
				this.XMouseLimitxMin = buffer;
			}

			//keep things in range
			if(this.XMouseLimitxMin < 0) this.XMouseLimitxMin = 0;
			if(this.XMouseLimitxMax > this.XaxisLimitAbsMax) this.XMouseLimitxMax = this.XaxisLimitAbsMax;

			//stick into the appropriate globals
			this.XaxisLimitMin = parseInt(this.XMouseLimitxMin);
			this.XaxisLimitMax = parseInt(this.XMouseLimitxMax);
	
			//drawXaxis();
			this.YaxisLimitMax=5;

			this.plotData();
			this.clickBounds = [];
		} else
			this.ClickWindow(this.XMouseLimitxMax)
	};

	//handle clicks on the plot
	this.ClickWindow = function(bin){
		var redline;

		//decide what to do with the clicked limits - zoom or fit?
		if(this.clickBounds.length == 0){
			this.clickBounds[0] = bin;
			redline = new createjs.Shape();
			redline.graphics.ss(this.axisLineWidth).s('#FF0000');
			redline.graphics.mt(this.leftMargin + this.binWidth*(bin-this.XaxisLimitMin), this.canvas.height - this.bottomMargin);
			redline.graphics.lt(this.leftMargin + this.binWidth*(bin-this.XaxisLimitMin), this.topMargin);
			this.containerPersistentOverlay.addChild(redline);
		} else if(this.clickBounds[0] == 'abort' && !this.fitModeEngage){
			this.clickBounds = [];
		} else if(this.clickBounds.length == 2 ){
			this.clickBounds = [];
			this.clickBounds[0] = bin;
		} else if(this.clickBounds.length == 1){
			this.clickBounds[1] = bin;
			//fit mode
			if(this.fitModeEngage){
				this.FitLimitLower = Math.min(this.clickBounds[0], this.clickBounds[1]);
				this.FitLimitUpper = Math.max(this.clickBounds[0], this.clickBounds[1]);
				this.fitData(this.fitTarget);
			} else {  //zoom mode
				//use the mouse drag function to achieve the same effect for clicking:
				this.XMouseLimitxMin = this.clickBounds[0];
				this.XMouseLimitxMax = this.clickBounds[1];
				this.DragWindow();
				this.clickBounds = [];
				this.containerPersistentOverlay.removeAllChildren();
				this.stage.update();
			}
		}
	};

	//scroll the plot x-window by x to the right
	this.scrollSpectra = function(step){
		var windowSize = this.XaxisLimitMax - this.XaxisLimitMin;

		this.XaxisLimitMin += step;
		this.XaxisLimitMax += step;

		if(this.XaxisLimitMin < 0){
			this.XaxisLimitMin = 0;
			this.XaxisLimitMax = windowSize;
		}

		if(this.XaxisLimitMax > this.XaxisLimitAbsMax){
			this.XaxisLimitMax = this.XaxisLimitAbsMax;
			this.XaxisLimitMin = this.XaxisLimitMax - windowSize;
		}

		this.plotData();

		//TBD: callbacks?
	};

	//recalculate x axis limits, for use when plots are deleted or hidden
	this.adjustXaxis = function(){
		this.XaxisLimitMin = (typeof this.demandXmin === 'number') ? this.demandXmin : 0;
		//use override max is present
		if(typeof this.demandXmax === 'number'){
			this.XaxisLimitAbsMax = this.demandXmax;
			this.XaxisLimitMax = this.demandXmax;
			return;
		}
		//autodetect max otherwise
		this.XaxisLimitAbsMax = 0;
		for(thisSpec in this.plotBuffer){
			//skip hidden spectra
			if(this.hideSpectrum[thisSpec]) continue;

			//Find the maximum X value from the size of the data
			this.XaxisLimitAbsMax = Math.max(this.XaxisLimitAbsMax, this.plotBuffer[thisSpec].length);
		}
		this.XaxisLimitMax = this.XaxisLimitAbsMax;		
	}

	//choose appropriate axis limits: default will fill the plot area, but can be overridden with this.demandXmin etc.
	this.chooseLimits = function(){
		var thisSpec, minYvalue, maxYvalue;

		this.YaxisLimitMax=5;
		this.XaxisLength = this.XaxisLimitMax - this.XaxisLimitMin;
		
		minYvalue = 1000000;
		this.XaxisLimitAbsMax = 0;
		maxYvalue=this.YaxisLimitMax;
		// Loop through to get the data and set the Y axis limits
		for(thisSpec in this.plotBuffer){
			//skip hidden spectra
			if(this.hideSpectrum[thisSpec]) continue;

			//Find the maximum X value from the size of the data
			this.XaxisLimitAbsMax = Math.max(this.XaxisLimitAbsMax, this.plotBuffer[thisSpec].length);

			// Find minimum and maximum Y value in the part of the spectrum to be displayed
			if(Math.min.apply(Math, this.plotBuffer[thisSpec].slice(Math.floor(this.XaxisLimitMin),Math.floor(this.XaxisLimitMax)))<minYvalue){
				minYvalue=Math.min.apply(Math, this.plotBuffer[thisSpec].slice(Math.floor(this.XaxisLimitMin),Math.floor(this.XaxisLimitMax)));
			}
			if(Math.max.apply(Math, this.plotBuffer[thisSpec].slice(Math.floor(this.XaxisLimitMin),Math.floor(this.XaxisLimitMax)))>maxYvalue){
				maxYvalue=Math.max.apply(Math, this.plotBuffer[thisSpec].slice(Math.floor(this.XaxisLimitMin),Math.floor(this.XaxisLimitMax)));
			}

			// Find the sum of everything in the current x range
			data = this.plotBuffer[thisSpec].slice(  Math.floor(this.XaxisLimitMin),Math.floor(this.XaxisLimitMax)   );
			totalEntries = 0;
			for(j=0; j<data.length; j++ ){
				totalEntries += data[j];
			}
			//report number of entries:
			this.entries[thisSpec] = totalEntries;

		}// End of for loop

		//keep track of min and max y in a convenient place
		this.minY = minYvalue;
		this.maxY = maxYvalue;

		//use demand overrides if present:
		if(typeof this.demandXmin === 'number') this.XaxisLimitMin = this.demandXmin;

		if(typeof this.demandXmax === 'number'){
			this.XaxisLimitMax = this.demandXmax;
			if(this.demandXmax > this.XaxisLimitAbsMax)
				this.XaxisLimitAbsMax = this.demandXmax;
		}

		if(typeof this.demandYmin === 'number') this.YaxisLimitMin = this.demandYmin;
		else this.YaxisLimitMin = (this.AxisType == 0) ? 0 : 0.1;
		if(typeof this.demandYmax === 'number') maxYvalue = this.demandYmax;

		// Adjust the Y axis limit and compression and redraw the axis
		if(maxYvalue>5){
			if(this.AxisType==0) this.YaxisLimitMax=Math.floor(maxYvalue*1);
			if(this.AxisType==1) this.YaxisLimitMax=maxYvalue*10;
		} else {
			if(this.AxisType==0) this.YaxisLimitMax=5;
			if(this.AxisType==1) this.YaxisLimitMax=50;
		}

		if(this.AxisType==0)
			this.YaxisLength = this.YaxisLimitMax-this.YaxisLimitMin;

		if(this.AxisType==1)
			//this.YaxisLength=Math.log10(this.YaxisLimitMax-this.YaxisLimitMin);
			this.YaxisLength = Math.log10(this.YaxisLimitMax) - Math.log10(this.YaxisLimitMin);

		//callback when limits are chosen - user fudges
		this.chooseLimitsCallback();

	};

	//zoom out to the full x-range
	this.unzoom = function(){
		var thisSpec;

		this.adjustXaxis();
		this.clearFits();

		this.plotData();
	};

	//set the axis to 'linear' or 'log', and repaint
	this.setAxisType = function(type){
		if(type=='log'){
			this.YaxisLimitMin = 0.1;
			this.AxisType = 1;
		}
		else{
			this.YaxisLimitMin = 0;
			this.AxisType = 0;
		}
		this.plotData();
	};

	//set up for fit mode, replaces old requestfitlimits
	this.setupFitMode = function(){
		this.fitModeEngage = 1;
		this.FitLimitLower=-1;
		this.FitLimitUpper=-1;		
	};

	//abandon fit mode without fitting
	this.leaveFitMode = function(){
		this.fitModeEngage = 0;
		this.FitLimitLower=-1;
		this.FitLimitUpper=-1;	
	}

	//stick a gaussian on top of the spectrum fitKey between the fit limits
	this.fitData = function(fitKey){
		var cent, fitdata, i, max, width, x, y, height;
		var fitLine, fitter;

		//suspend the refresh
		window.clearTimeout(this.refreshHandler);

		if(this.FitLimitLower<0) this.FitLimitLower=0;
		if(this.FitLimitUpper>this.XaxisLimitAbsMax) this.FitLimitUpper = this.XaxisLimitAbsMax;

 		//old method just sticks a hat on the peak; use this as initial guess
		max=1;

		fitdata=this.plotBuffer[fitKey];

		fitdata=fitdata.slice(this.FitLimitLower, this.FitLimitUpper+1);

		// Find maximum Y value in the fit data
		if(Math.max.apply(Math, fitdata)>max){
			max=Math.max.apply(Math, fitdata);
		}

		// Find the bin with the maximum Y value
		cent=0;
		while(fitdata[cent]<max){
			cent++;
		}

		// Find the width of the peak
		x=cent;
		while(fitdata[x]>(max/2.0)) x--; 
		width=x;
		x=cent;
		while(fitdata[x]>(max/2.0)) x++; 
		width=x-width;
		if(width<1) width=1;
		width/=2.35;

		cent=cent+this.FitLimitLower+0.5;

		//use the new prototype fitting package to do a maximum likelihood gaussian fit:
		if(this.MLfit){
			fitter = new histofit();
			for(i=this.FitLimitLower; i<=this.FitLimitUpper; i++)
				fitter.x[i-this.FitLimitLower] = i+0.5;
			fitter.y=fitdata;
			fitter.fxn = function(x, par){return par[0]*Math.exp(-1*(((x-par[1])*(x-par[1]))/(2*par[2]*par[2])))};
			fitter.guess = [max, cent, width];
			fitter.fitit();
			max = fitter.param[0];
			cent = fitter.param[1];
			width = fitter.param[2];		
		}

		//set up canvas for drawing fit line
		fitLine = new createjs.Shape();
		fitLine.graphics.ss(3).s('#FF0000');
		fitLine.graphics.mt( this.leftMargin + (this.FitLimitLower-this.XaxisLimitMin)*this.binWidth, this.canvas.height - this.bottomMargin - max*Math.exp(-1*(((this.FitLimitLower-cent)*(this.FitLimitLower-cent))/(2*width*width)))*this.countHeight);
		
		for(i=0;i<fitdata.length;i+=0.2){
			//draw fit line on canvas:
			x=i+this.FitLimitLower;
			y = max*Math.exp(-1*(((x-cent)*(x-cent))/(2*width*width)));
			if(i!=0){
				if(this.AxisType == 0){
					fitLine.graphics.lt( this.leftMargin + (this.FitLimitLower-this.XaxisLimitMin)*this.binWidth + i*this.binWidth, this.canvas.height - this.bottomMargin - y*this.countHeight);
				} else if(this.AxisType == 1){
					if(y<=0) height = 0;
					else height = Math.log10(y) - Math.log10(this.YaxisLimitMin);
					if(height<0) height = 0;
					fitLine.graphics.lt( this.leftMargin + (this.FitLimitLower-this.XaxisLimitMin)*this.binWidth + i*this.binWidth, this.canvas.height - this.bottomMargin - height*this.countHeight);
				}
			}
		}

		this.containerFit.addChild(fitLine);
		this.stage.update();

		this.fitted=1;
		this.fitModeEngage = 0;

		this.fitCallback(cent, width);
	};

	//dump the fit results
	this.clearFits = function(callback){
		this.containerFit.removeAllChildren();
		this.stage.update();

		if(callback)
			callback();
	}

	//suppress or unsuppress a spectrum from being shown
	this.toggleSpectrum = function(spectrumName, hide){
		this.hideSpectrum[spectrumName] = hide;

		this.adjustXaxis();

		this.plotData();
	};

	//add a data series to the list to be plotted with key name and content [data]
	this.addData = function(name, data){
		var nSeries, i;

		//refuse to display more than 10 data series, it's ugly.
		nSeries = Object.keys(this.plotBuffer).length;
		if(nSeries > this.dataColor.length){
			alert('gammaSpectrum only allows at most' + this.dataColor.length + 'series to be plotted simultaneously.');
			return;
		}

		//choose the first available color and assign it to this data series
		if(this.colorAssignment.indexOf(name) == -1){
			i=0;
			while(this.colorAssignment[i]) i++;
			this.colorAssignment[i] = name;
		}

		//append the data to the data buffer
		this.plotBuffer[name] = data;
	};

	//remove a data series from the buffer
	this.removeData = function(name){
		//free the color
		this.colorAssignment[this.colorAssignment.indexOf(name)] = null;

		//delete the data
		delete this.plotBuffer[name];
	};

	//////////////////////////////////////////////////////
	//initial setup///////////////////////////////////////
	//////////////////////////////////////////////////////
	this.drawFrame();
	//plot mouseover behavior - report mouse coordinates in bin-space, and manage the cursor style
	this.canvas.addEventListener('mousemove', function(event){
		var coords, x, y, xBin, yBin;
		var crosshairs, highlight;

		coords = this.canvas.relMouseCoords(event);
		x = coords.x;
		y = coords.y;

        if(x > this.leftMargin && x < this.canvas.width - this.rightMargin && y > this.topMargin){
	        xBin = Math.floor((x-this.leftMargin)/this.binWidth) + this.XaxisLimitMin;
    	    
    	    if(this.AxisType == 1){
    	    	yBin = (this.canvas.height-this.bottomMargin - y) / this.countHeight;
    	    	yBin = Math.floor(Math.pow(10,yBin)/10);
    	    } else {
    	    	yBin = Math.floor((this.canvas.height-this.bottomMargin - y) / this.countHeight);
    	    }

    	    this.cursorX = xBin.toFixed(0);
    	    this.cursorY = yBin.toFixed(0);
        }
        this.mouseMoveCallback(xBin, yBin);

        //change cursor to indicate draggable region:
        if(this.fitModeEngage){
        	if( y < (this.canvas.height - this.bottomMargin) )
	        	document.body.style.cursor = 's-resize';
	        else 
	        	document.body.style.cursor = 'n-resize';
	    }
        else if(y>this.canvas.height-this.bottomMargin) 
        	document.body.style.cursor = 'pointer';
        else
        	document.body.style.cursor = 'default';

        //draw crosshairs
        this.containerOverlay.removeAllChildren();
        if(x > this.leftMargin && x < this.canvas.width - this.rightMargin && y > this.topMargin && y<this.canvas.height-this.bottomMargin){
        	if(this.clickBounds.length!=1){  //normal crosshairs
				crosshairs = new createjs.Shape();
				crosshairs.graphics.ss(this.axisLineWidth).s(this.axisColor);
				crosshairs.graphics.mt(this.leftMargin, y);
				crosshairs.graphics.lt(this.canvas.width-this.rightMargin, y);
				this.containerOverlay.addChild(crosshairs);

				crosshairs = new createjs.Shape();
				crosshairs.graphics.ss(this.axisLineWidth).s(this.axisColor);
				crosshairs.graphics.mt(x, this.canvas.height-this.bottomMargin);
				crosshairs.graphics.lt(x, this.topMargin);
				this.containerOverlay.addChild(crosshairs);
			} else { //red vertical line to mark second bound of click-and-zoom
				crosshairs = new createjs.Shape();
				crosshairs.graphics.ss(this.axisLineWidth).s('#FF0000');
				crosshairs.graphics.mt(x, this.canvas.height-this.bottomMargin);
				crosshairs.graphics.lt(x, this.topMargin);
				this.containerOverlay.addChild(crosshairs);				
			}
		}
		//highlight region on drag
		if(this.highlightStart != -1){
			highlight = new createjs.Shape();
			highlight.alpha = 0.3;
			highlight.graphics.beginFill(this.highlightColor).r(this.highlightStart, this.topMargin, Math.max(x, this.leftMargin) - this.highlightStart, this.canvas.height-this.topMargin-this.bottomMargin)
			this.containerOverlay.addChild(highlight);
		}
		this.stage.update();

	}.bind(this), false);

	this.canvas.onmouseout = function(event){
		document.body.style.cursor = 'default';
		this.containerOverlay.removeAllChildren();
		this.stage.update();
	}.bind(this);

	this.canvas.onmousedown = function(event){
		if(event.button == 0){
			this.highlightStart = this.canvas.relMouseCoords(event).x;
			this.XMouseLimitxMin = parseInt((this.canvas.relMouseCoords(event).x-this.leftMargin)/this.binWidth + this.XaxisLimitMin);
		}
	}.bind(this);

	this.canvas.onmouseup = function(event){
			if(event.button == 0){
				this.highlightStart = -1;
				this.XMouseLimitxMax = parseInt((this.canvas.relMouseCoords(event).x-this.leftMargin)/this.binWidth + this.XaxisLimitMin); 
				this.DragWindow();
			}
	}.bind(this);

	this.canvas.ondblclick = function(event){
		this.unzoom();
	}.bind(this);

	//right clicking does obnoxious focus things, messes with canvas onclicks.
	this.canvas.oncontextmenu = function(){
		return false;
	};

}

//stick a coordinate tracker on the canvas prototype:
function relMouseCoords(event){
    var totalOffsetX = 0,
    totalOffsetY = 0,
    canvasX = 0,
    canvasY = 0,
    currentElement = this,
    test = [],
    elts = [];

	if (event.offsetX !== undefined && event.offsetY !== undefined) { return {x:event.offsetX, y:event.offsetY}; }
	//if (event.layerX !== undefined && event.layerY !== undefined) { return {x:event.layerX, y:event.layerY}; }

    do{
        totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
        totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
        //test[test.length] = currentElement.offsetLeft - currentElement.scrollLeft
        //elts[elts.length] = currentElement
    }
    while(currentElement = currentElement.offsetParent)

    canvasX = event.pageX - totalOffsetX;
    canvasY = event.pageY - totalOffsetY;

    //hack to deal with FF scroll, better solution TBD:
    if(event.offsetX == undefined){
    	canvasX -= document.body.scrollLeft;
    	canvasY -= document.body.scrollTop;
    }

    return {x:canvasX, y:canvasY}
}
HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;

//tell the Math library about log base 10:
Math.log10 = function(n) {
	return (Math.log(n)) / (Math.log(10));
};function establishHistoryView(){
	
	//wrap
	injectDOM('div', 'historyWrap', 'SubsystemSidebar', {'style':'padding:1em; border-top: 1px solid #777777; display:inline-block;'});
	//image tag to hold history plot
	injectDOM('img', 'historyPlot', 'historyWrap', {'src':'http://grsmid00.triumf.ca:8081/HS/Epics/Shack%20Temp.gif?width=Small'});

	//form & text box to request plots
	injectDOM('form', 'historyForm', 'historyWrap', {});
	injectDOM('select', 'historyURL', 'historyForm', {'class':'historyDD'});
	injectDOM('option', 'history0', 'historyURL', {'value':'http://grsmid00.triumf.ca:8081/HS/Epics/Shack%20Temp.gif?width=Small', 'innerHTML':'Temp'});
	injectDOM('option', 'history1', 'historyURL', {'value':'http://grsmid00.triumf.ca:8081/HS/Epics/Ge.gif?width=Small', 'innerHTML':'Ge'});


	document.getElementById('historyURL').onchange = function(){
		document.getElementById('historyPlot').src = this.value;
	};	

}function loadJSONP(gatekeeper, callback) {
    var i;

    if(document.getElementById('spinner')){
        drawSpinner('spinner', 'Waiting for JSONP');
    }

    //actually this creates a window where the JSONP store is empty; if a rePaint is requested then, bad things happen!
    //dump buffers AFTER the new data is downloaded :)
    //window.JSONPstore = {'scalar':{}, 'thresholds':{}, 'HV':{}}; //dump the old store so old junk doesn't persist.

    for(i=0; i<window.parameters.JSONPrepos.length; i++){

        var script = document.createElement('script');

        //either make some fake data to replace the JSONP service offline in devMode, or use the real thing online:
        if(window.parameters.devMode){
            script.setAttribute('src', ' ');
            if(callback != 'main'){
                parseResponse(fakeScalars());
                parseThreshold(fakeThresholds());
            }
        } else
            script.setAttribute('src', window.parameters.JSONPrepos[i]);    //fetch the ith repo

        script.setAttribute('id', 'tempScript'+i);

        script.onload = function(){
            for(var i=0; i<window.parameters.JSONPrepos.length; i++){
                if (window.parameters.JSONPrepos[i] == this.src) window.JSONPstatus[i] = 'Online';
            }
            //post to GK:
            var gatekeeperReport = new  CustomEvent("gatekeeperReport", {
                                            detail: {
                                                status: 'loaded',
                                                cb: callback        
                                            }
                                        });
            gatekeeper.listener.dispatchEvent(gatekeeperReport);
        }

        script.onerror = function(){
            for(var i=0; i<window.parameters.JSONPrepos.length; i++){
                if (window.parameters.JSONPrepos[i] == this.src) window.JSONPstatus[i] = 'Not Responding';
            }
            //post to GK:
            var gatekeeperReport = new  CustomEvent("gatekeeperReport", {
                                            detail: {
                                                status: 'failed',        
                                                cb: callback
                                            }
                                        });
            gatekeeper.listener.dispatchEvent(gatekeeperReport);
        }

        document.head.appendChild(script);
    }
}

//an object to block the page update until all the JSONP requests have reported back. 
function gatekeeper(){
    this.listener = document.getElementById('topWrapper')

    //how many JSONP assets have checked in?
    this.copyBack = 0;

    this.listener.addEventListener("gatekeeperReport", function(e){
        window.Gatekeeper.copyBack++;

        if(window.Gatekeeper.copyBack == window.parameters.JSONPrepos.length){
            window.Gatekeeper.copyBack = 0;

            if(e.detail.cb == 'main') main.apply(null); //apply construction turns this into anon to avoid funky main collisions
            else masterLoop(e.detail.cb);
        }
    });
}

function masterLoop(callMyself, noFetch){
    var i,j, historySelect;

	if(!document.webkitHidden && !document.mozHidden){
        //one big ODB grab:
        if(!noFetch) ODBgrab();

        //update all assets
        //status bar
        window.statusBar.update();
        //HV
    	if(window.parameters.topDeployment['HV']) window.waffle.update();
        //DAQ
        if(window.parameters.topDeployment['DAQ']) window.DAQ.update();
        //Subsystems
        if(window.parameters.topDeployment['Subsystems']){
            for(i=0; i<window.Subdetectors.length; i++){
                window.Subdetectors[i].update();
            }
        }
        //Clock
        if(window.parameters.topDeployment['Clock']) window.clockPointer.update();
        //Filter
        if(window.parameters.topDeployment['Filter']) window.filterPointer.update();
        //VME
        if(window.parameters.topDeployment['VME']) window.VMEpointer.update();
        //Cycle
        if(window.parameters.topDeployment['Cycle']) window.cyclePointer.update();
        //Dashboard
        window.dashboard.update();       

        //history
        document.getElementById('historyPlot').src = selected('historyURL');

        //let the alarm service do it's thing now that the update is complete:
        window.AlarmServices.publishAlarms();

    }
    
    //remove all temporary scripts from the head so they don't accrue:
    for(i=0; i<window.parameters.JSONPrepos.length; i++){
        var element = document.getElementById('tempScript'+i);
        if(element)
            element.parentNode.removeChild(element);
    }

    //next iteration:
    window.loop = setTimeout(function(){loadJSONP(window.Gatekeeper, 1)}, 3000);
}

//determine how many crates are declared in the ODB.  Equipment name must be 'HV-xx', where xx == 0-99
function detectCrates(){
    var i, paths = [], data = [],
        maxCrates = 100;

    for(i=0; i<maxCrates; i++){
      paths[i] = '/Equipment/HV-'+i;
    }
    data = ODBMGet(paths);

    for(i=0; i<maxCrates; i++){
      if(data[i] != '<DB_NO_KEY>'){
        window.parameters.HVequipmentNames[window.parameters.HVequipmentNames.length] = 'HV-'+i
      }
    }

}

//determine what size cards are in what slot:
function detectCards(){
    var i, j, crateCode, nSlots;
    
    //32-bit integer encodes what size cards are in what slot; each slot is encoded in 2 bits, and slot 0 is the two highest (ie 31 and 30) bits.
    //00 == empty slot, 01 == 12chan card, 10 == 24chan card, 11 == 48chan card.  Crate size is indicated by the lowest two bits;
    //10 == 6 slot crate, 11 == 12 slot crate, anything else == 16 slot crate.
    for(j=0; j<window.parameters.HVequipmentNames.length; j++){
        crateCode = parseInt(ODBGet('/Equipment/'+window.parameters.HVequipmentNames[j]+'/Settings/Devices/sy2527/DD/crateMap'), 10);
        if( (crateCode & 3) == 2) nSlots = 6;
        else if( (crateCode & 3) == 3) nSlots = 12;
        else nSlots = 16;

        window.parameters.moduleSizes[j] = [];
        for(i=0; i<nSlots; i++){
            if( ((crateCode>>(30-2*i)) & 3) == 0 ) window.parameters.moduleSizes[j][window.parameters.moduleSizes[j].length] = 0;
            else if( ((crateCode>>(30-2*i)) & 3) == 1 ) window.parameters.moduleSizes[j][window.parameters.moduleSizes[j].length] = 1;
            else if( ((crateCode>>(30-2*i)) & 3) == 2 ) window.parameters.moduleSizes[j][window.parameters.moduleSizes[j].length] = 2;
            else if( ((crateCode>>(30-2*i)) & 3) == 3 ) window.parameters.moduleSizes[j][window.parameters.moduleSizes[j].length] = 4;
        }
    }

}

//force an immediate update, and set the master loop going again from there:
function forceUpdate(){
    clearTimeout(window.loop);
    startLoop(1);
}

//like forceUpdate, but doesn't fetch data - just draws with current parameters
function rePaint(){
    clearTimeout(window.loop);
    masterLoop(1, true);
}

//handle everybody's interval-based fetch from the ODB in one network request: (+1 more for the message service, weird...)
function ODBgrab(){
    var paths = [], i, j, k,
    SIDEBAR, DAQ, HV, CLOCK,
    data;

    //Message service:
    window.localODB.messages = ODBGetMsg(5);

    //sidebar
    SIDEBAR = 0;
    paths[SIDEBAR] = '/Experiment/Name';
    paths[SIDEBAR+1] = '/Runinfo/Run number';
    paths[SIDEBAR+2] = '/Runinfo/State';
    paths[SIDEBAR+3] = '/Runinfo/Start time';
    paths[SIDEBAR+4] = '/Runinfo/Stop time';
    paths[SIDEBAR+5] = '/Runinfo/Start time binary';
    paths[SIDEBAR+6] = '/Experiment/Run Parameters/Comment';
    //DAQ
    DAQ = SIDEBAR+7;
    paths[DAQ] = '/Equipment/Trigger/Statistics/Events per sec.';
    paths[DAQ+1] = '/Equipment/Trigger/Statistics/kBytes per sec.';
    paths[DAQ+2] = '/Equipment/Event Builder/Statistics/Events per sec.';
    paths[DAQ+3] = '/Equipment/Event Builder/Statistics/kBytes per sec.';
    //HV
    HV = DAQ+4
    for(k=0; k<window.parameters.moduleSizes.length; k++){  //recall length of module sizes = number of HV crates declared
        for(i=0; i<window.parameters.ODBkeys.length; i++){
            paths[HV + k*window.parameters.ODBkeys.length + i] = '/Equipment/'+window.parameters.HVequipmentNames[k]+'/'+window.parameters.ODBkeys[i]+'[*]';
        }       
    }
    //Clock
    CLOCK = HV + window.parameters.moduleSizes.length*window.parameters.ODBkeys.length;
    for(i=0; i<window.parameters.nClocks; i++){
        paths[CLOCK + i] = '/Equipment/GRIF-Clk'+i+'/Variables/Output[*]';
    }

    //data = ODBMGet(paths);
    data = JSON.parse(ODBMCopy(paths, undefined, 'json'));

    //sidebar
    window.localODB.expTitle = data[SIDEBAR]['Name'];
    window.localODB.runInfo = data[SIDEBAR+1]['Run number'];
    window.localODB.runstate = data[SIDEBAR+2]['State'];
    window.localODB.startInfo = data[SIDEBAR+3]['Start time'];
    window.localODB.elapsed = data[SIDEBAR+4]['Stop time'];
    window.localODB.binaryStart = data[SIDEBAR+5]['Start time binary'];
    window.localODB.comment = data[SIDEBAR+6]['Comment'];
    //DAQ
    window.localODB.TrigEPS = data[DAQ]['Events per sec.'];
    window.localODB.TrigDPS = data[DAQ+1]['kBytes per sec.'];
    window.localODB.EBEPS = data[DAQ+2]['Events per sec.'];
    window.localODB.EBDPS = data[DAQ+3]['kBytes per sec.'];  
    //HV
    for(k=0; k<window.parameters.moduleSizes.length; k++){  //recall length of module sizes = number of HV crates declared
        window.localODB['HV'+k] = [];
        window.localODB['HV'+k].reqVoltage      = data[HV + k*window.parameters.ODBkeys.length + 0]['Demand'];
        window.localODB['HV'+k].measVoltage     = data[HV + k*window.parameters.ODBkeys.length + 1]['Measured'];
        window.localODB['HV'+k].measCurrent     = data[HV + k*window.parameters.ODBkeys.length + 2]['Current'];
        window.localODB['HV'+k].rampUp          = data[HV + k*window.parameters.ODBkeys.length + 3]['Ramp Up Speed'];
        window.localODB['HV'+k].rampDown        = data[HV + k*window.parameters.ODBkeys.length + 4]['Ramp Down Speed'];
        window.localODB['HV'+k].measTemperature = data[HV + k*window.parameters.ODBkeys.length + 5]['Temperature'];
        window.localODB['HV'+k].repoChState     = data[HV + k*window.parameters.ODBkeys.length + 6]['ChState'];
        window.localODB['HV'+k].repoChStatus    = data[HV + k*window.parameters.ODBkeys.length + 7]['ChStatus'];
        window.localODB['HV'+k].voltageLimit    = data[HV + k*window.parameters.ODBkeys.length + 8]['Voltage Limit'];
        window.localODB['HV'+k].currentLimit    = data[HV + k*window.parameters.ODBkeys.length + 9]['Current Limit'];
        window.localODB['HV'+k].chName          = data[HV + k*window.parameters.ODBkeys.length + 10]['Names'];      
    }    
    //Clock
    for(i=0; i<window.parameters.nClocks; i++){
        window.localODB['clock'+i] = data[CLOCK+i]['Output'];
    }

    //Pull the measured voltages and channel names out and pack them along
    //with the JSONP stuff for the subdetector views:
    window.JSONPstore.HV = {};
    for(k=0; k<window.parameters.moduleSizes.length; k++){   
        for(i=0; i<window.localODB['HV'+k].chName.length; i++){
            window.JSONPstore.HV[window.localODB['HV'+k].chName[i].toUpperCase()] = parseFloat(window.localODB['HV'+k].measVoltage[i]);
        }
    }
}

//handle pulling the initial config parameters out of the ODB and replacing the default values in the JSONP-loaded parameter store:
function fetchODB(){
    ODB = JSON.parse(ODBCopy('/DashboardConfig'));
    scrubMeta(ODB);

    //every leaf has a metadata leaf parallel to it, screws up for/in traversal.  Scrub: 
    function scrubMeta(object){
        var key;

        //scrub metadata:
        for(key in object){
            if(key.indexOf('/key') != -1)
                delete object[key];
            else{
                //recurse?
                if(typeof object[key] == 'object' && !Array.isArray(object[key]))
                    scrubMeta(object[key]);
            }
        }
    };
}







//collapsible menu/////////////////////////////////////////////////////////////////////////////////////////////////

//create a vertical collapsible menu that occupies a target div.
function deployMenu(targetDivID, headings, titles){
	var i;

	//listener tool for Buchner's dom insertion listener:
	window.parameters.insertListener = function(event){
		var prefix, tab;
		if (event.animationName == "nodeInserted") {
			prefix = event.target.id.slice(0, event.target.id.search('Content'));
			//tab = document.getElementById(prefix+'Tab');
			resizeMenu(prefix);
		}
	}

	//inject the appropriate html into the target div:
	for(i=0; i<headings.length; i++){
		injectDOM('div', headings[i]+'Tab', targetDivID, {'class':'collapsableMenu', 'style':'max-height:50px; text-align:left; margin-top:2%;'});
		injectDOM('h3', headings[i]+'arrow', headings[i]+'Tab', {
			'class' : 'dropDownArrow',
			'style' : 'display:inline; float:left;',
			'innerHTML' : String.fromCharCode(0x25B6),
			'onclick' : function(){toggleMenu(targetDivID, headings, this.id)}
		});
		injectDOM('h3', headings[i]+'title', headings[i]+'Tab', {'style':'display:inline-block; font:20px Orbitron; padding-left:1em', 'innerHTML':titles[i]});
		injectDOM('div', headings[i]+'Content', headings[i]+'Tab', {'class':'menuContent'});

		//make sure the expanded divs maintain an appropriate height even if their contents change:
		document.addEventListener("animationstart", window.parameters.insertListener, false); // standard + firefox
		document.addEventListener("webkitAnimationStart", window.parameters.insertListener, false); // Chrome + Safari

		/*
		document.getElementById(headings[i]+'Tab').addEventListener('transitionend', function(){
				if( this.style.opacity==0 )
		            this.style.display='none';    
	    });
		*/
	}

}

//menu toggler for clock view - wrapperDivID wraps the menu, headings is the same array containing menu item IDs as in menu(), and thisOne is the item ID being interacted with.
function toggleMenu(wrapperDivID, headings, thisID){

    var totalHeight = parseInt(document.getElementById(wrapperDivID).offsetHeight),  //total height of menu bar
        fullHeight = totalHeight*0.98 - 100,
        assocDiv, string, i,
        thisOne = thisID.slice(0, thisID.length-5) + 'Tab';  //reconstruct the tab ID from the arrow ID

    if(document.getElementById(thisOne).style.maxHeight == '50px'){ //expand menu:
        //change the title arrows as appropriate, and resize menus
        for(i=0; i<headings.length; i++){
        	//force others to collapse so only one open at a time?
        	if(thisOne != headings[i]+'Tab'){
	        	//document.getElementById(headings[i]+'arrow').innerHTML = String.fromCharCode(0x25B6);
	        	//document.getElementById(headings[i]+'Tab').style.height = '50px';
	        } else{
	        	document.getElementById(headings[i]+'arrow').innerHTML = String.fromCharCode(0x25BC);
	        	//document.getElementById(headings[i]+'Tab').style.height = fullHeight+'px';
	        	//document.getElementById(headings[i]+'Tab').setAttribute('style', 'height: -webkit-max-content');
	        	document.getElementById(headings[i]+'Tab').style.maxHeight = (document.getElementById(headings[i]+'Content').offsetHeight+50)+'px';
	        }
        }
    } else {
	    document.getElementById(thisOne.slice(0,thisOne.length-3)+'arrow').innerHTML = String.fromCharCode(0x25B6);
	    document.getElementById(thisOne).style.maxHeight = '50px';
    }
}

//resize expanded menu when its Content div changes
function resizeMenu(id){
	if(document.getElementById(id+'Tab').style.maxHeight != '50px')
		document.getElementById(id+'Tab').style.maxHeight = (document.getElementById(id+'Content').offsetHeight+50)+'px';
}

//dismiss a tab
function dismissTab(id){
	document.getElementById(id).style.opacity = 0;
}

function recallTab(id){
	//document.getElementById(id).style.display = 'block';
	document.getElementById(id).style.opacity = 1;	
}

//toggle switch//////////////////////////////////////////////////////////////////////////

//build a toggle switch out of divs:
function toggleSwitch(parentID, id, title, enabled, disabled, onActivate, onDeactivate, initialState){

	//wrapper div:
	injectDOM('div', 'toggleWrap'+id, parentID, {'class':'toggleWrap', 'style':( (title=='') ? 'text-align:center;' : '' )});
	//label:
	if(title != '')
		injectDOM('div', 'toggleLabel'+id, 'toggleWrap'+id, {'class':'toggleLabel', 'innerHTML':title});
	//toggle groove:
	injectDOM('div', 'toggleGroove'+id, 'toggleWrap'+id, {'class':'toggleGroove', 'style':( (title=='') ? '' : 'float:left;' )});
	//toggle switch:
	injectDOM('div', 'toggleSwitch'+id, 'toggleGroove'+id, {'class':'toggleSwitch', 'style':((initialState) ? 'left:1em;' : 'left:0em;')});
	document.getElementById('toggleSwitch'+id).onmousedown = function(event){
		document.getElementById('toggleWrap'+id).ready = 1;
	};
	document.getElementById('toggleSwitch'+id).onmouseup = function(event){
		flipToggle(event, id, enabled, disabled, onActivate, onDeactivate);
	};
	document.getElementById('toggleSwitch'+id).onmouseout = function(event){
		flipToggle(event, id, enabled, disabled, onActivate, onDeactivate)
	};
	//state description
	if(title=='')
		injectDOM('br', 'break', 'toggleWrap'+id, {});
	injectDOM('div', 'toggleDescription'+id, 'toggleWrap'+id, {
		'class' : 'toggleDescription',
		'style' : ( (title=='') ? 'width:100%' : '' ),
		'innerHTML' : ((initialState) ? enabled : disabled)
	})


}

function flipToggle(event, id, enabled, disabled, onActivate, onDeactivate){
	var switchID = 'toggleSwitch'+id,
	//grooveID = 'toggleGroove' + id,
	descriptionID = 'toggleDescription' + id;
	if(document.getElementById('toggleWrap'+id).ready != 1) return

	if(document.getElementById(switchID).style.left == '0em'){
		document.getElementById(switchID).style.left = '1em';
		document.getElementById(descriptionID).innerHTML = enabled;
		onActivate();
	} else{
		document.getElementById(switchID).style.left = '0em';
		document.getElementById(descriptionID).innerHTML = disabled;
		onDeactivate();
	}

	document.getElementById('toggleWrap'+id).ready =0;	
}


//option scroll//////////////////////////////////////////
function createOptionScroll(wrapperID, id, options, maxWidth, callback){
	var i, stringWidths = [], optionWidth;

	injectDOM('div', id, wrapperID, {'class':'scrollWrapper', 'style':'width:'+maxWidth+'px'});
	injectDOM('div', id+'LeftArrow', id, {'class':'scrollArrow', 'style':'padding-right:0.5em;', 'innerHTML':String.fromCharCode(0x25C0)});
	injectDOM('div', id+'Selected', id, {'class':'scrollSelected', 'innerHTML':options[0]});
	injectDOM('div', id+'RightArrow', id, {'class':'scrollArrow', 'style':'padding-left:0.5em;', 'innerHTML':String.fromCharCode(0x25B6)});

	//start off on option 0:
	document.getElementById(id).chosen = 0;
	document.getElementById(id).options = options;

	//fix width of option cell:
	for(i=0; i<options.length; i++){
		stringWidths[i] = options[i].width('14px Raleway');
	}
	optionWidth = Math.min(Math.max.apply(null, stringWidths), maxWidth);
	document.getElementById(id+'Selected').style.width = optionWidth+'px';


	//make the scroll arrows scroll through options:
	document.getElementById(id+'LeftArrow').onclick = function(){
		var id = this.id.slice(0, this.id.indexOf('LeftArrow')),
			scroll = document.getElementById(id);

		if(scroll.chosen == 0){
			scroll.chosen = scroll.options.length-1;
		} else {
			scroll.chosen--;
		}
		document.getElementById(id+'Selected').innerHTML = scroll.options[scroll.chosen];

		if(callback)
			callback();

	}

	document.getElementById(id+'RightArrow').onclick = function(){
		var id = this.id.slice(0, this.id.indexOf('RightArrow')),
			scroll = document.getElementById(id);

		if(scroll.chosen == scroll.options.length-1){
			scroll.chosen = 0;
		} else {
			scroll.chosen++;
		}
		document.getElementById(id+'Selected').innerHTML = scroll.options[scroll.chosen];

		if(callback)
			callback();
	}	

}





/* MIDAS type definitions */
var TID_BYTE = 1;
var TID_SBYTE = 2;
var TID_CHAR = 3;
var TID_WORD = 4;
var TID_SHORT = 5;
var TID_DWORD = 6;
var TID_INT = 7;
var TID_BOOL = 8;
var TID_FLOAT = 9;
var TID_DOUBLE = 10;
var TID_BITFIELD = 11;
var TID_STRING = 12;
var TID_ARRAY = 13;
var TID_STRUCT = 14;
var TID_KEY = 15;
var TID_LINK = 16;

document.onmousemove = getMouseXY;

function getMouseXY(e)
{
   try {
      var x = e.pageX;
      var y = e.pageY;
      var p = 'abs: ' + x + '/' + y;
      i = document.getElementById('refimg');
      if (i == null)
         return false;
      document.body.style.cursor = 'crosshair';
      x -= i.offsetLeft;
      y -= i.offsetTop;
      while (i = i.offsetParent) {
         x -= i.offsetLeft;
         y -= i.offsetTop;
      }
      p += '   rel: ' + x + '/' + y;
      window.status = p;
      return true;
      }
   catch (e) {
      return false;
   }
}

function XMLHttpRequestGeneric()
{
   var request;
   try {
      request = new XMLHttpRequest(); // Firefox, Opera 8.0+, Safari
   }
   catch (e) {
      try {
         request = new ActiveXObject('Msxml2.XMLHTTP'); // Internet Explorer
      }
      catch (e) {
         try {
            request = new ActiveXObject('Microsoft.XMLHTTP');
         }
         catch (e) {
           alert('Your browser does not support AJAX!');
           return undefined;
         }
      }
   }

   return request;
}

var ODBUrlBase = "";

function ODBSetURL(url)
{
    ODBUrlBase = url;
}

function ODBSet(path, value, pwdname)
{
   var value, request, url;

   if (pwdname != undefined)
      pwd = prompt('Please enter password', '');
   else
      pwd = '';

   var request = XMLHttpRequestGeneric();

   url = ODBUrlBase + '?cmd=jset&odb=' + path + '&value=' + encodeURIComponent(value);

   if (pwdname != undefined)
      url += '&pnam=' + pwdname;

   request.open('GET', url, false);

   if (pwdname != undefined)
      request.setRequestHeader('Cookie', 'cpwd='+pwd);

   request.send(null);

   if (request.status != 200 || request.responseText != 'OK') 
      alert('ODBSet error:\nPath: '+path+'\nHTTP Status: '+request.status+'\nMessage: '+request.responseText+'\n'+document.location) ;
}

function ODBGet(path, format, defval, len, type)
{
   var request = XMLHttpRequestGeneric();

   var url = ODBUrlBase + '?cmd=jget&odb=' + path;
   if (format != undefined && format != '')
      url += '&format=' + format;
   request.open('GET', url, false);
   request.send(null);

   if (path.match(/[*]/)) {
      if (request.responseText == null)
         return null;
      if (request.responseText == '<DB_NO_KEY>') {
         url = '?cmd=jset&odb=' + path + '&value=' + defval + '&len=' + len + '&type=' + type;

         request.open('GET', url, false);
         request.send(null);
         return defval;
      } else {
         var array = request.responseText.split('\n');
         return array;
      }
   } else {
      if ((request.responseText == '<DB_NO_KEY>' ||
           request.responseText == '<DB_OUT_OF_RANGE>') && defval != undefined) {
         url = '?cmd=jset&odb=' + path + '&value=' + defval + '&len=' + len + '&type=' + type;

         request.open('GET', url, false);
         request.send(null);
         return defval;
      }
      return request.responseText.split('\n')[0];
   }
}

function ODBMGet(paths, callback, formats)
{
   var request = XMLHttpRequestGeneric();

   var url = ODBUrlBase + '?cmd=jget';
   for (var i=0 ; i<paths.length ; i++) {
      url += '&odb'+i+'='+paths[i];
      if (formats != undefined && formats != '')
         url += '&format'+i+'=' + formats[i];
   }

   if (callback != undefined) {
      request.onreadystatechange = function() 
         {
         if (request.readyState == 4) {
            if (request.status == 200) {
               var array = request.responseText.split('$#----#$\n');
               for (var i=0 ; i<array.length ; i++)
                  if (paths[i].match(/[*]/)) {
                     array[i] = array[i].split('\n');
                     array[i].length--;
                  } else
                     array[i] = array[i].split('\n')[0];
               callback(array);
            }
         }
      }
      request.open('GET', url, true);
   } else
      request.open('GET', url, false);
   request.send(null);

   if (callback == undefined) {
      var array = request.responseText.split('$#----#$\n');
      for (var i=0 ; i<array.length ; i++) {
         if (paths[i].match(/[*]/)) {
            array[i] = array[i].split('\n');
            array[i].length--;
         } else
            array[i] = array[i].split('\n')[0];
      }
      return array;
   }
}

function ODBGetRecord(path)
{
   var request = XMLHttpRequestGeneric();

   var url = ODBUrlBase + '?cmd=jget&odb=' + path + '&name=1';
   request.open('GET', url, false);
   request.send(null);
   return request.responseText;
}

function ODBExtractRecord(record, key)
{
   var array = record.split('\n');
   for (var i=0 ; i<array.length ; i++) {
      var ind = array[i].indexOf(':');
      if (ind > 0) {
         var k = array[i].substr(0, ind);
         if (k == key)
            return array[i].substr(ind+1, array[i].length);
      }
      var ind = array[i].indexOf('[');
      if (ind > 0) {
         var k = array[i].substr(0, ind);
         if (k == key) {
            var a = new Array();
            for (var j=0 ; ; j++,i++) {
               if (array[i].substr(0, ind) != key)
                  break;
               var k = array[i].indexOf(':');
               a[j] = array[i].substr(k+1, array[i].length);
            }
            return a;
         }
      }
   }
   return null;
}

function ODBKey(path)
{
   var request = XMLHttpRequestGeneric();

   var url = ODBUrlBase + '?cmd=jkey&odb=' + path;
   request.open('GET', url, false);
   request.send(null);
   if (request.responseText == null)
      return null;
   var res = request.responseText.split('\n');
   this.name = res[0];
   this.type = res[1];
   this.num_values = res[2];
   this.item_size = res[3];
   this.last_written = res[4];
}

function ODBCopy(path, format)
{
   var request = XMLHttpRequestGeneric();

   var url = ODBUrlBase + '?cmd=jcopy&odb=' + path;
   if (format != undefined && format != '')
      url += '&format=' + format;
   request.open('GET', url, false);
   request.send(null);
   return request.responseText;
}

function ODBCall(url, callback)
{
   var request = XMLHttpRequestGeneric();
      
   if (callback != undefined) {
      request.onreadystatechange = function() 
         {
            if (request.readyState == 4) {
               if (request.status == 200) {
                  callback(request.responseText);
               }
            }
         }
      request.open('GET', url, true);
      request.send(null);
      return;
   }
   
   request.open('GET', url, false);
   request.send(null);
   return request.responseText;
}

function ODBMCopy(paths, callback, encoding)
{
   var url = ODBUrlBase + '?cmd=jcopy';
   for (var i=0 ; i<paths.length ; i++) {
      url += '&odb'+i+'='+encodeURIComponent(paths[i]);
   }

   if (encoding != undefined && encoding != '')
      url += '&encoding=' + encodeURIComponent(encoding);

   return ODBCall(url, callback);
}

function ODBMCreate(paths, types, arraylengths, stringlengths, callback)
{
   var url = ODBUrlBase + '?cmd=jcreate';
   for (var i=0 ; i<paths.length ; i++) {
      url += '&odb'+i+'='+encodeURIComponent(paths[i]);
      url += '&type'+i+'='+encodeURIComponent(types[i]);
      if (arraylengths != undefined) {
         url += '&arraylen'+i+'='+encodeURIComponent(arraylengths[i]);
      }
      if (stringlengths != undefined) {
         url += '&strlen'+i+'='+encodeURIComponent(stringlengths[i]);
      }
   }
   return ODBCall(url, callback);
}

function ODBMResize(paths, arraylengths, stringlengths, callback)
{
   var url = ODBUrlBase + '?cmd=jresize';
   for (var i=0 ; i<paths.length ; i++) {
      url += '&odb'+i+'='+encodeURIComponent(paths[i]);
      url += '&arraylen'+i+'='+encodeURIComponent(arraylengths[i]);
      url += '&strlen'+i+'='+encodeURIComponent(stringlengths[i]);
   }
   return ODBCall(url, callback);
}

function ODBMRename(paths, names, callback)
{
   var url = ODBUrlBase + '?cmd=jrename';
   for (var i=0 ; i<paths.length ; i++) {
      url += '&odb'+i+'='+encodeURIComponent(paths[i]);
      url += '&name'+i+'='+encodeURIComponent(names[i]);
   }
   return ODBCall(url, callback);
}

function ODBMLink(paths, links, callback)
{
   var url = ODBUrlBase + '?cmd=jlink';
   for (var i=0 ; i<paths.length ; i++) {
      url += '&dest'+i+'='+encodeURIComponent(paths[i]);
      url += '&odb'+i+'='+encodeURIComponent(links[i]);
   }
   return ODBCall(url, callback);
}

function ODBMReorder(paths, indices, callback)
{
   var url = ODBUrlBase + '?cmd=jreorder';
   for (var i=0 ; i<paths.length ; i++) {
      url += '&odb'+i+'='+encodeURIComponent(paths[i]);
      url += '&index'+i+'='+encodeURIComponent(indices[i]);
   }
   return ODBCall(url, callback);
}

function ODBMKey(paths, callback)
{
   var url = ODBUrlBase + '?cmd=jkey&encoding=json';
   for (var i=0 ; i<paths.length ; i++) {
      url += '&odb'+i+'='+encodeURIComponent(paths[i]);
   }
   return ODBCall(url, callback);
}

function ODBMDelete(paths, callback)
{
   var url = ODBUrlBase + '?cmd=jdelete';
   for (var i=0 ; i<paths.length ; i++) {
      url += '&odb'+i+'='+encodeURIComponent(paths[i]);
   }
   return ODBCall(url, callback);
}

function ODBRpc_rev0(name, rpc, args)
{
   var request = XMLHttpRequestGeneric();

   var url = ODBUrlBase +  '?cmd=jrpc_rev0&name=' + name + '&rpc=' + rpc;
   for (var i = 2; i < arguments.length; i++) {
     url += '&arg'+(i-2)+'='+arguments[i];
   };
   request.open('GET', url, false);
   request.send(null);
   if (request.responseText == null)
      return null;
   this.reply = request.responseText.split('\n');
}

function ODBRpc_rev1(name, rpc, max_reply_length, args)
{
   var request = XMLHttpRequestGeneric();

   var url = ODBUrlBase + '?cmd=jrpc_rev1&name=' + name + '&rpc=' + rpc + '&max_reply_length=' + max_reply_length;
   for (var i = 3; i < arguments.length; i++) {
     url += '&arg'+(i-3)+'='+arguments[i];
   };
   request.open('GET', url, false);
   request.send(null);
   if (request.responseText == null)
      return null;
   return request.responseText;
}

function ODBGetMsg(n)
{
   var request = XMLHttpRequestGeneric();

   var url = ODBUrlBase + '?cmd=jmsg&n=' + n;
   request.open('GET', url, false);
   request.send(null);

   if (n > 1) {
      var array = request.responseText.split('\n');
      return array;
   } else
      return request.responseText;
}

function ODBGenerateMsg(m)
{
   var request = XMLHttpRequestGeneric();

   var url = ODBUrlBase + '?cmd=jgenmsg&msg=' + m;
   request.open('GET', url, false);
   request.send(null);
   return request.responseText;
}

function ODBGetAlarms()
{
   var request = XMLHttpRequestGeneric();
   request.open('GET', ODBUrlBase + '?cmd=jalm', false);
   request.send(null);
   var a = request.responseText.split('\n');
   a.length = a.length-1;
   return a;
}

function ODBEdit(path)
{
   var value = ODBGet(encodeURIComponent(path));
   var new_value = prompt('Please enter new value', value);
   if (new_value != undefined) {
      ODBSet(encodeURIComponent(path), new_value);
      window.location.reload();
   }
}

function ODBFinishInlineEdit(p, path)
{
   var value;
 
   if (p.ODBsent == true)
      return;
   
   if (p.childNodes.length == 2)
      value = p.childNodes[1].value;
   else
      value = p.childNodes[0].value;

   ODBSet(encodeURIComponent(path), value);
   p.ODBsent = true;
   
   var link = document.createElement('a');
   if (value == "")
      value = "(empty)";
   link.innerHTML = value;
   link.href = path+"?cmd=Set";
   link.onclick = function(){ODBInlineEdit(p,path);return false;};
   link.onfocus = function(){ODBInlineEdit(p,path);};
   
   if (p.childNodes.length == 2)
      setTimeout(function(){p.appendChild(link);p.removeChild(p.childNodes[1])}, 10);
   else
      setTimeout(function(){p.appendChild(link);p.removeChild(p.childNodes[0])}, 10);
}

function ODBInlineEditKeydown(event, p, path)
{
   var keyCode = ('which' in event) ? event.which : event.keyCode;
   
   if (keyCode == 27) {
      /* cancel editing */
      p.ODBsent = true;

      var value = ODBGet(encodeURIComponent(path));
      var link = document.createElement('a');
      if (value == "")
         value = "(empty)";
      link.innerHTML = value;
      link.href = path+"?cmd=Set";
      link.onclick = function(){ODBInlineEdit(p,path);return false;};
      link.onfocus = function(){ODBInlineEdit(p,path);};
      
      if (p.childNodes.length == 2)
         setTimeout(function(){p.appendChild(link);p.removeChild(p.childNodes[1])}, 10);
      else
         setTimeout(function(){p.appendChild(link);p.removeChild(p.childNodes[0])}, 10);
   
      return false;
   }

   if (keyCode == 13) {
      ODBFinishInlineEdit(p, path);
      return false;
   }

   return true;
}

function ODBInlineEdit(p, odb_path)
{
   var cur_val = ODBGet(encodeURIComponent(odb_path));
   var size = cur_val.length+10;
   var index;
   
   p.ODBsent = false;
   if (odb_path.indexOf('[') > 0) {
      index = odb_path.substr(odb_path.indexOf('['));
   
      p.innerHTML = index+"&nbsp;<input type=\"text\" size=\""+size+"\" value=\""+cur_val+"\" onKeydown=\"return ODBInlineEditKeydown(event, this.parentNode,\'"+odb_path+"\');\" onBlur=\"ODBFinishInlineEdit(this.parentNode,\'"+odb_path+"\');\" >";
      setTimeout(function(){p.childNodes[1].focus();p.childNodes[1].select();}, 10); // needed for Firefox
   } else {
      p.innerHTML = "<input type=\"text\" size=\""+size+"\" value=\""+cur_val+"\" onKeydown=\"return ODBInlineEditKeydown(event, this.parentNode,\'"+odb_path+"\');\" onBlur=\"ODBFinishInlineEdit(this.parentNode,\'"+odb_path+"\');\" >";

      setTimeout(function(){p.childNodes[0].focus();p.childNodes[0].select();}, 10); // needed for Firefox
   }
}

function mhttpd_create_page_handle_create(mouseEvent)
{
   var form = document.getElementsByTagName('form')[0];
   var path = form.elements['odb'].value;
   var type = form.elements['type'].value;
   var name = form.elements['value'].value;
   var arraylength = form.elements['index'].value;
   var stringlength = form.elements['strlen'].value;

   if (path == "/") path = "";

   if (name.length < 1) {
      alert("Name is too short");
      return false;
   }

   if (arraylength < 1) {
      alert("Bad array length: " + arraylength);
      return false;
   }

   if (stringlength < 1) {
      alert("Bad string length " + stringlength);
      return false;
   }

   var result = JSON.parse(ODBMCreate([ path + "/" + name ], [ type ], [ arraylength ], [ stringlength ]));

   if (result[0] == 311) {
      alert("ODB entry with this name already exists.");
   } else if (result[0] != 1) {
      alert("ODBMCreate() error " + result + ", and that's all we know.");
   } else {
      location.search = ""; // reloads the document
   }
   //window.reload();
   return false;
}

function mhttpd_create_page_handle_cancel(mouseEvent)
{
   location.search = ""; // reloads the document
   return false;
}

function mhttpd_delete_page_handle_delete(mouseEvent)
{
   var form = document.getElementsByTagName('form')[0];
   var path = form.elements['odb'].value;

   if (path == "/") path = "";

   var names = [];
   for (var i=0; ; i++) {
      var n = "name" + i;
      var v = form.elements[n];
      if (v == undefined) break;
      if (v == undefined) break;
      if (v.checked)
         names.push(path + "/" + v.value);
   }

   if (names.length < 1) {
      alert("Please select at least one ODB entry to delete.");
      return false;
   }

   //alert(names);

   var result = JSON.parse(ODBMDelete(names));

   location.search = ""; // reloads the document

   //window.reload();
   return false;
}

function mhttpd_delete_page_handle_cancel(mouseEvent)
{
   location.search = ""; // reloads the document
   return false;
}
function loadParameters(){

				window.parameters = {
				//global
				"devMode" : 0,
				"topDeployment" : {"HV":1, "Subsystems":1, "DAQ":1, "Clock":1, "Filter":1, "VME":1, "Cycle":1},
				"wrapper" : "topWrapper",
				"tooltipPrecision" : 0,
				"colorScale"  : ["ROOT Rainbow", "Greyscale", "Sunset", "Red Scale", "Mayfair"],
				"detectorLogMode" : {'SubsystemsButton' : 0, 'DAQbutton' : 0, 'DashboardButton' : 0},  //log state a function of ID of button used to summon current view state 
				"warningFill" : 0, //an img to fill detector channels absent from the JSONP post
				"JSONPrepos" : ["http://midtig06.triumf.ca:8091/mother/parameters?jsonp=parseThreshold", "http://midtig06.triumf.ca:8091/mother/scalar?jsonp=parseResponse"],

				//HV monitor
				"ODBkeys" : ["Variables/Demand", "Variables/Measured", "Variables/Current", "Settings/Ramp Up Speed", "Settings/Ramp Down Speed", "Variables/Temperature", "Settings/ChState", "Variables/ChStatus", "Settings/Voltage Limit", "Settings/Current Limit", "Settings/Names"],
				"rows" : 12,
				"columns": [],
				"scaleMaxima" : [1,1,1,1],
				"statusPrecision" : 0,
				"barChartPrecision" : 0,
				"alarmPrecision" : 0,
				"voltUnit" : "V",
				"rampUnit" : "V/s",
				"currentUnit" : "uA",
				"temperatureUnit" : "C",
				"HVequipmentNames" : [],
				"moduleSizes" : [],

				//Subdetector monitors
				"subdetectorUnit" : ["V", "ADC units", "Hz"],
				"monitorValues" : ["HV", "Thresholds", "Rate", "TAC-Thresholds", "TAC-Rate"],
				"subdetectorColors" : ["ROOT Rainbow", "ROOT Rainbow", "Sunset"],

				"BAMBINO" : {
								"minima" : {
												"BAMBINO" : [0,0,0]
										   },
								"maxima" : {
												"BAMBINO" : [1,1,1]
										   }
							},
				"BAMBINOmode" : "S3",
				"BAMBINOlayers" : 2,
				"BAMBINOdeployment" : [1,0],  //upstream, downstream

				"DANTE" : {
							"minima" : {
											"LaBrPMT" : [0,0,0],
											"LaBrTAC" : [0,0,0],
											"BGO" : [0,0,0]
									   },
							"maxima" : {
											"LaBrPMT" : [1,1,1],
											"LaBrTAC" : [1,1,1],
											"BGO" : [1,1,1]
									   }
						  },

				"DESCANT" : {
								"minima" : {
												"DESCANT" : [0,0,0]
										   },
								"maxima" : {
												"DESCANT" : [1,1,1]
										   },
							},

				"HPGe" : {
							"minima" : {
											"HPGe" : [0,0,0],
											"BGO" : [0,0,0]
									   },
							"maxima" : {
											"HPGe" : [1,1,1],
											"BGO" : [100,100,100]
							           },
						 },
				"HPGemode" : "GRIFFIN",
				"BGOenable" : 1,
				"cloversAbsent" : [],

				"PACES" : {
							"minima" : {
											"PACES" : [0,0,0]
									   },
							"maxima" : {
											"PACES" : [1,1,1]
									   }
						  },


				"SCEPTAR" : {
								"minima" : {
												"SCEPTAR" : [0,0,0],
												"ZDS" : [0,0,0]
										   },
								"maxima" : {
												"SCEPTAR" : [1,1,1],
												"ZDS" : [1,1,1]
										   }
							},
				"SCEPTARconfig" : [1,0,1],

				"SHARC" : {
							"minima" : {
											"SHARC" : [0,0,0]
								       },
							"maxima" : {
											"SHARC" : [1,1,1]
							           },
						  },  
				"SHARCpads" : 0,

				"SPICE" : {
							"minima" : {
											"SPICE" : [0,0,0]
									   },
							"maxima" : {
											"SPICE" : [1,1,1]
									   }
						  },
				"SPICEaux" : '',
				"SPICEauxLayers" : 2,

				"TIPwall" : {
							"minima" : {
											"TIPwall" : [0,0,0],
									   },
							"maxima" : {
											"TIPwall" : [1,1,1],
									   }
						},

				"TIPball" : {
							"minima" : {
											"TIPball" : [0,0,0],
									   },
							"maxima" : {
											"TIPball" : [1,1,1],
									   }
						},

				"DSSD" : {
								"minima" : {
												"DSSD" : [0,0,0]
										   },
								"maxima" : {
												"DSSD" : [1,1,1]
										   },
						},

				"ZDS" : {
								"minima" : {
												"ZDS" : [0,0,0]
										   },
								"maxima" : {
												"ZDS" : [1,1,1]
										   },
						},

				//DAQ
				"validDetectors" : ["TIG", "TIS", "GRG", "GRS", "HPG", "HPS", "BAE", "BAZ", "SHQ", "SHB", "MAD", "MAM", "CSD", "CSM", "SPI", "SPE", "DSC", "SEP", "SET", "PAC", "DAL", "DAB", "DAS", "TPC", "TPW", "TPP", "TPG", "TPE", "ZDS", "ZDP", "ZDM", "ZDD", "TBR", "YBP", "YBB", "TRF", "RFL", "RFS"],

				//clocks
				"nClocks" : 0,
				"clockVariableNames" : ['Clock Enable', 'Configuration', 'Sync Source', 'Clock Source', 'Ref. Clock', 'LEMO Clock', 'LEMO Sync', 'eSATA Clock', 'eSATA Sync', 'SyncTmeS', 'SyncTmeE', 'Ch. 0 Hi Cycles', 'Ch. 0 Lo Cycles', 'Ch. 0 Bypass', 'Ch. 0 Phase', 'Ch. 1 Hi Cycles', 'Ch. 1 Lo Cycles', 'Ch. 1 Bypass', 'Ch. 1 Phase', 'Ch. 2 Hi Cycles', 'Ch. 2 Lo Cycles', 'Ch. 2 Bypass', 'Ch. 2 Phase', 'Ch. 3 Hi Cycles', 'Ch. 3 Lo Cycles', 'Ch. 3 Bypass', 'Ch. 3 Phase', 'Ch. 4 Hi Cycles', 'Ch. 4 Lo Cycles', 'Ch. 4 Bypass', 'Ch. 4 Phase', 'Ch. 5 Hi Cycles', 'Ch. 5 Lo Cycles', 'Ch. 5 Bypass', 'Ch. 5 Phase', 'Ch. 6 Hi Cycles', 'Ch. 6 Lo Cycles', 'Ch. 6 Bypass', 'Ch. 6 Phase', 'Ch. 7 Hi Cycles', 'Ch. 7 Lo Cycles', 'Ch. 7 Bypass', 'Ch. 7 Phase', 'Power', 'Status', 'Mode', 'Alarm', 'Unit Power', 'Tuning Voltage', 'Laser Current', 'Clock Heater Power', 'Temperature', 'Serial No.', 'Firmware Version']

				}

				window.parameters.warningFill = document.getElementById('warningFill');

			}

/*Parameter Dictionary//////////////////////////////////////
//Global
devMode							1 = generate fake data for testing, 0 = go looking for the JSON posts in JSONPrepos
topDeployment					indicates which subsections will be deployed - TODO: revalidate & debug, probably broken.
wrapper  						ID for div that wraps most of the page content
tooltipPrecision				precision for most generic tooltip table
colorScale						Names of defined color scales 
detectorLogMode					default linear (=0) or log (=1) state for various widgets
warningFill						an image for filling absent channels
JSONPrepos						array containing URLs of all JSONP data to be pulled in at each update: [thresholds, scalars]

//HV monitor
ODBkeys 						[	"Demand Voltage Key", 
									"Measured Voltage Key", 
									"Measured Current Key", 
									"Voltage Ramp Up Key", 
									"Voltage Ramp Down Key", 
									"Temperature Key", 
									"ChState Key", 
									"ChStatus Key", 
									"Voltage Limit Key", 
									"Current Limit Key",
									"Name Key"
								]
rows							number of rows in the HV monitor, not counting the primary row
columns							number of columns in HV monitor.
scaleMaxima						Saturation point for [HV, current, temperature, rate] alarm color scale; ie scaleMaxima[0] = 7 -> full alarm color if Vmeas-Vdemand > 7 
statusPrecision					number of decimal places to keep in the status sidebar
barChartPrecision				number of decimal places to keep in the barchart scale
alarmPrecision					number of decimal places to keep in the alarm reporting sidebar
voltUnit						unit to be used for voltage reporting
rampUnit						""
currentUnit						""
temperatureUnit					""
HVequipmentNames				Array of names of HV slow control front ends, autogenerated, n FE must be named as HV-0, HV-1... HV-n
moduleSizes	                    Array containing a size code for each slot in the HV crate: 0=empty, 1=12 ch card, 4=48 ch card.

//Subdetector monitors
subdetectorUnit                 units for the scale in each of the subdetector views [HV, thresholds, rates]
monitorValues					monitoring options on the subdetector pages
subdetectorColors				default color scales for the different subdetector views

//DAQ
validDetectors					Prefixes of detectors recognized in this project

//Clocks
nClocks							Autodetected number of clocks, slow control frontend name GRIF-Clk<n>
clockVariableNames				list of variable names used when constructing the clock right sidebar






///////////////old//////////////////////////////
//Global
devMode							Flag that toggles between actually fetching ODB values and generating dummy values
statusURL:						String containing the url of the MIDAS status page
topDeployment:                  switches to turn top level assets on/off
deployment						switches to turn subsystems on/off
wrapper							ID of div that wraps all both sidebars + main display region
subdetectorUnit                 units for the scale in each of the subdetector views [HV, thresholds, rates]
monitorValues					monitoring options on the subdetector pages

//HV monitor

rows:							number of rows in the HV monitor, not counting the primary row
columns:						number of columns in HV monitor.
rowTitles:						Array of strings descrbing the row titles
alarmThresholds:				Maximum values before an alarm is tripped [abs(demand-measured voltage), current, temperature, rate]
scaleMaxima:					Saturation point for color scale
prefix:							Array of strings which will be prepended to corresponding lines in the HV tooltip
postfix:						As prefix
minVoltage:						minimum voltage represented in sliders and fillmeters
maxVoltage:						""
minCurrent:						""
maxCurrent:						""
minTemperature:					""
maxTemperature:					""
minRampSpeed:					""
maxRampSpeed:					""
statusPrecision:				number of decimal places to keep in the status sidebar
barChartPrecision:				number of decimal places to keep in the barchart scale
alarmPrecision:					number of decimal places to keep in the alarm reporting sidebar
voltUnit:						unit to be used for voltage reporting
rampUnit:						""
currentUnit:					""
temperatureUnit:				""
moduleSizes:                    Array containing a size code for each slot in the HV crate: 0=empty, 1=12 ch card, 4=48 ch card.

//SHARC
SMrows:							number of rows of strip diplays
SMcolumns:						number of cols of strip displays
SM_ODBkeys:						["/Location/Of/Device/Varibles", "/Location/Of/Device/Settings", "HV Key"]
SMnChannels:					number of channels per display
SMminima:						array containing scale minima
SMmaxima:						""
nRadialHoriz					number of radial bins in the disks corresponding to the horizontal strip display 
nAzimuthalHoriz					number of azimuthal bins "" 
nRadialVert						number of radial bins in disks associated with the vertical strip display 
nAzimuthalVert					number of azimuthal bins ""

//HPGe
HPGemode						'GRIFFIN' or 'TIGRESS'
BGOenable						are the suppressors present?
HPGeminima						array of scale minima: [HPGe HV, HPGe Thresholds, HPGe Rate...]
HPGemaxima						""

DESACNTminima					array of scale minima: [HV, Thresholds, Rate...]
DESCANTmaxima					""

PACESminima						array of scale minima: [HV, Thresholds, Rate...]
PACESmaxima						""

DANTEminima						array of scale minima: [HV, Thresholds, Rate...]
DANTEmaxima						""

SPICEminima						array of scale minima: [HV, Thresholds, Rate...]
SPICEmaxima						""

SCEPTARminima					array of scale minima: [HV, Thresholds, Rate...]
SCEPTARmaxima					""
SCEPTARconfig                   subsystems on: [upstream sceptar, downstream sceptar, downstream ZDS]

TIPminima						array of scale minima: [HV, Thresholds, Rate...]
TIPmaxima						""

//DAQ
DAQminima:						array containing minima of DAQ rate reporting scale: [master, collector groups, collector links, collectors, digitizer summary links, digitizer summaries, digitizer groups, digitizer links, digitizers]
DAQmaxima:						""


//JSONP
JSONPrepos						array containing URLs of all JSONP data to be pulled in at each update: [thresholds, scalars, dummy]

*/


function Slider(wrapperID, titleID, inputBoxID, sliderContainerID, sliderBackgroundID, sliderKnobID, sliderCanvID, sliderTextID, min, max, decimal, unit, length){

    //slider limits:
    this.min = min;
    this.max = max;

    //value unit:
    this.unit = unit;

    //number of decimal places to keep:
    this.dec = decimal;

    //length of slider; if user enters 0, use default size:
    this.length = length;
    if(this.length == 0) this.length = 220;
    //left bound of slider rail:
    this.leftRail = 20;
    //right bound of slider rail:
    this.rightRail = this.leftRail + this.length;
    //leftmost limit of knob's left edge:
    this.leftKnob = this.leftRail - 10;
    //rightmost limit of knob's left edge:
    this.rightKnob = this.rightRail - 10;

    //previous physical value:
    this.oldValue = 0;
    //current value:
    this.newValue = 0;
    //value of field on click:
    this.valueOnFocus = 0;

    //animation parameters:
    this.duration = 0.4; //seconds
    this.FPS = 30;
    this.nFrames = this.duration*this.FPS;

    //IDs:
    this.wrapperID = wrapperID;
    this.titleID = titleID;
    this.inputBoxID = inputBoxID;
    this.sliderContainerID = sliderContainerID;
    this.sliderBackgroundID = sliderBackgroundID;
    this.sliderKnobID = sliderKnobID;
    this.sliderCanvID = sliderCanvID;
    this.sliderTextID = sliderTextID;

    //DOM manipulation/////////////////////////////////////////////
    //slider background canvas:
    injectDOM('canvas', this.sliderBackgroundID, this.sliderContainerID, {'class':'sliderBKG', 'width':'0', 'height':'24'});
    //slider knob div
    injectDOM('div', this.sliderKnobID, this.sliderContainerID, {'class':'sliderKnob'});
    //knob style canvas
    injectDOM('canvas', this.sliderCanvID, this.sliderKnobID, {'class':'knobStyle', 'width':'24', 'height':'16'});
    //position feedback paragraph
    injectDOM('p', this.sliderTextID, this.sliderKnobID, {'class':'sliderText', 'innerHTML':'0%'});

    //finished DOM injections//////////////////////////////////////

    //pointers by ID:
    this.wrapper = document.getElementById(wrapperID);
    this.inputBox = document.getElementById(inputBoxID);
    this.sliderContainer = document.getElementById(sliderContainerID);
    this.sliderBackground = document.getElementById(sliderBackgroundID);
    this.sliderKnob = document.getElementById(sliderKnobID);
    this.sliderCanv = document.getElementById(sliderCanvID);
    this.sliderText = document.getElementById(sliderTextID);

    $(this.sliderContainer).css('left', $(this.inputBox).width() +  0.1*$(this.wrapper).width()*1.5 );

    //configure slider div and canvas css:
    this.sliderContainer.width = 1.2*length;
    this.sliderBackground.width = 1.2*length;

    //draw the slider canvases:
    this.sliderContext = this.sliderBackground.getContext('2d');
    this.knobContext = this.sliderCanv.getContext('2d');

    //knob rail:
    this.sliderContext.strokeStyle = 'rgba(255,255,255,0.7)'
    this.sliderContext.lineWidth = 1;
    this.sliderContext.beginPath();
    this.sliderContext.moveTo(this.leftRail, 8);
    this.sliderContext.lineTo(this.rightRail, 8);
    this.sliderContext.stroke();

    //knob surface:
    this.knobContext.fillStyle = 'rgba(255,255,255,1)';
    this.knobContext.lineWidth = 1;
    this.knobContext.beginPath();
    this.knobContext.moveTo(0,4);
    this.knobContext.lineTo(0,12);         
    this.knobContext.arcTo(0,16, 4,16, 4);
    this.knobContext.lineTo(16,16);
    this.knobContext.arcTo(20,16,20,12,4);
    this.knobContext.lineTo(20,4);
    this.knobContext.arcTo(20,0,16,0,4);
    this.knobContext.lineTo(4,0);
    this.knobContext.arcTo(0,0,0,4,4);
    this.knobContext.fill();
    this.knobContext.stroke();

    //establish slider response:
    this.active = 0;
    this.sliderWasAt = 0;
    this.cursorWasAt = 0;
    this.dragX = 0;
    this.sliderTo = 0;
    this.scale = 0;
    this.sliderString;  

    //turn off slider focus glow:
    $(this.sliderKnob).css('outline', '0px none transparent');

    var that = this;

    this.sliderCanv.onmousedown = function(event){
        that.sliderWasAt = parseFloat($(that.sliderKnob).css('left'));
        that.sliderKnob.tabIndex = '1';
        that.sliderKnob.focus();
        that.active = 1;
        that.cursorWasAt = event.pageX;
    }

    this.sliderContainer.onmouseup = function(event){
        that.active = 0;
        that.sliderWasAt = that.sliderWasAt + that.dragX;
    }

    this.sliderContainer.onmouseout = function(event){
        that.active = 0;
        that.sliderWasAt = that.sliderWasAt + that.dragX;
    }

    this.sliderContainer.onmousemove = function(event){
        if(that.active){

            that.dragX = event.pageX - that.cursorWasAt;
            that.sliderTo = that.sliderWasAt + that.dragX;
            //keep slider in range:
            if(that.sliderTo < that.leftKnob) that.sliderTo = that.leftKnob;
            if(that.sliderTo > that.rightKnob) that.sliderTo = that.rightKnob;

            that.scale = (that.sliderTo-that.leftKnob) / that.length;

            //establish new position:
            that.oldValue = that.newValue;
            that.newValue = (that.scale*(that.max-that.min) + that.min);

            //estabish slider label content
            that.sliderString =  that.newValue.toFixed(that.dec)+' '+that.unit;

            //center label under knob, but don't let it fall off the end of the slider.
            var stringWidth = that.knobContext.measureText(that.sliderString).width*1.2
            $('#'+sliderTextID).css('left',(-1*stringWidth/2 -10) );
            if(stringWidth/2+that.sliderTo+0+10> that.rightRail){
                $('#'+sliderTextID).css('left', that.rightKnob - stringWidth - that.sliderTo - 10);
            }
            if(that.sliderTo - stringWidth/2 -0-10 < that.leftRail){
                $('#'+sliderTextID).css('left', that.leftKnob + 0+10 - that.sliderTo );
            }

            that.sliderText.innerHTML = '<br>'+that.sliderString;

            $(that.sliderKnob).css('left', that.sliderTo);

            that.inputBox.value = (that.scale*(that.max-that.min)+that.min).toFixed(that.dec);

            highlight('submitParameters');
        }
    }

    this.sliderKnob.onkeydown = function(event){
        if(event.keyCode == 39) {
            that.step(Math.pow(10, -1*that.dec));
            highlight('submitParameters');
        }
        else if(event.keyCode == 37) {
            that.step(-1*Math.pow(10, -1*that.dec));
            highlight('submitParameters');
        }
    }

    this.inputBox.onblur = function(event){
         
        //note: need to skip animation here (ie can't just use update) since when clicking 'submit'
        //an intermediate value might be grabbed and sent to HW as the knob scrolls and drags the text
        //with it.  TODO: scroll knob without changing text box.
        
        //keep things in bounds:
        var newSliderVal = that.inputBox.value;
        if(newSliderVal > that.max) newSliderVal = that.max;
        if(newSliderVal < that.min) newSliderVal = that.min;
        
        //keep the animation parameters updated:
        that.oldValue = that.newValue;
        that.newValue = newSliderVal;
  
        //find the fraction of the way along the rail the knob should jump to:
        var sliderPosition = (newSliderVal-that.min)/(that.max-that.min);
        
        that.jump(parseFloat(sliderPosition));
        
    }

    //move the slider discontinuously to a new <position>, expressed as a fraction of the way between scale min and scale max:
    this.jump = function(position){
        this.sliderTo = position*this.length;
        $(this.sliderKnob).css('left', this.sliderTo+this.leftKnob);   
        this.scale = (this.sliderTo) / this.length;

        //estabish slider label content
        this.sliderString = (position*(this.max-this.min)+this.min).toFixed(this.dec)+' '+this.unit;

        //center label under knob, but don't let it fall off the end of the slider.
        var stringWidth = this.knobContext.measureText(this.sliderString).width*1.2;
        $('#'+this.sliderTextID).css('left',(-1*stringWidth/2 - 10) );
        if(stringWidth/2+this.sliderTo+this.leftKnob+0 +10 > this.rightKnob){
            $('#'+this.sliderTextID).css('left', -1*stringWidth - this.sliderTo -this.leftKnob-0 -10 + this.rightKnob );
        }
        if(this.sliderTo+this.leftKnob - stringWidth/2 -0 -10 < this.leftKnob){
            $('#'+this.sliderTextID).css('left', this.leftKnob+0+10-this.sliderTo-this.leftKnob );
        }

        this.sliderText.innerHTML = '<br>'+this.sliderString;

        this.inputBox.value = (this.scale*(this.max-this.min)+this.min).toFixed(this.dec);        
    };

    //top function for handling slider updates from everything other than the slider knob:
    this.update = function(inputValue){

        //keep value inbounds:
        var newValue = inputValue;

        if(newValue > this.max) newValue = this.max;
        if(newValue < this.min) newValue = this.min;

        //set up member variables for animation:
        this.oldValue = parseFloat(this.newValue);
        this.newValue = parseFloat(newValue);

        //animate:
        animate(this, 0);
    };

    //draw function used by animate():
    this.draw = function(frame){
        //this frame is this fraction of the way between scale min and scale max:
        var position = ((this.newValue - this.oldValue)*frame/this.nFrames + this.oldValue - this.min)/(this.max-this.min);

        this.jump(position);

    };

    //like update, but handles an un-animated single step from a cursor stroke:
    this.step = function(stepSize){
        //keep value inbounds:
        var newValue = this.newValue + stepSize; 
        if(newValue > this.max) newValue = this.max;
        if(newValue < this.min) newValue = this.min;

        //set up member variables for animation:
        this.oldValue = this.newValue;
        this.newValue = newValue;

        //use draw at the last frame to skip the animation:
        this.draw(this.nFrames);
    };

}//top-level function to handle fetching a subsystem spectrum
function getSubsystemSpectrum(channel){
    var spectrumOptions = document.getElementById('subsystemSpectrumType'),
        spectrumType = spectrumOptions.options[spectrumOptions.selectedIndex].value,
        spectrumName = channel;

    //if nothing provided, just redo whatever's in there now; there should only ever be one.
    if(!channel)
        spectrumName = Object.keys(window.spectrumViewers.subsystem.plotBuffer)[0].slice(1,11);

    //don't flip out if nothing's been plotted or requested yet:
    if(!spectrumName)
        return;

    //make the last character case insensitive
    spectrumName = spectrumName.slice(0,9) + spectrumName.slice(9,10).toLowerCase();

    addSpectrum(spectrumType + spectrumName, window.spectrumViewers.subsystem);
};

//deploy a new histo to the viewer: fetch it, draw it.
function addSpectrum(name, viewer){

    //get the spectrum
    fetchSpectrum(name, function(name, viewer){
        var key;

        //one at a time in the embedded viewer
        for(key in viewer.plotBuffer)
            viewer.removeData(key);

        //append to spectrum viewer's data store:
        viewer.addData(name, spectrumBuffer[name]);

        //redraw the spectra
        viewer.plotData();
        viewer.unzoom();

        //dump the script so they don't accrue
        deleteDOM('fetchdata');

    }.bind(null, name, viewer));
    
};

//fetch one spectrum from the server
function fetchSpectrum(name, callback){
    var script;

    //get data from server:
    script = document.createElement('script');
    script.setAttribute('src', 'http://annikal.triumf.ca:9093/?cmd=callspechandler&spectrum1='+name);
    if(callback) script.onload = callback
    script.id = 'fetchdata';

    document.head.appendChild(script);
};

//handle the server callback, currently hardcoded as callSpectrumHandler
function callSpectrumHandler(data){

    var key, response;
    
    for(key in data){
        if(data[key]){
            spectrumBuffer[key] = [];
            for(i=0; i<data[key].length; i++)
                spectrumBuffer[key][i] = data[key][i];
        }
    }  
};

//refresh spectra that are currently available for plotting
function refreshSpectra(viewer){
    var i, key, URL = 'http://annikal.triumf.ca:9093/?cmd=callspechandler';

    i=0;
    for(key in spectrumBuffer){
        URL += '&spectrum'+i+'='+key;
        i++;
    }

    //get data from server:
    if(i!=0){
        script = document.createElement('script');
        script.setAttribute('src', URL);
        script.onload = function(){
            var key;
            //push relevant data to the viewer's buffer
            for(key in viewer.plotBuffer){
                viewer.addData(key, spectrumBuffer[key]);
            }
            //dump the script so they don't stack up:
            deleteDOM('fetchdata');

            viewer.plotData();
        };
        script.id = 'fetchdata'
        document.head.appendChild(script);
    } else
        viewer.plotData();
};

//inject subsystem spectrum viewer assets
function establishSubsystemSpectrumViewerUI(){
    injectDOM('form', 'subsystemSpectrumControl', 'SubsystemSidebar', {'style':'display:none'});

    injectDOM('div', 'subsystemSpectrumTypeWrapper', 'SubsystemSidebar', {});
    injectDOM('label', 'subsystemSpectrumTypeLabel', 'subsystemSpectrumTypeWrapper', {'innerHTML':'Plot: ', 'for':'subsystemSpectrumType'})
    injectDOM('select', 'subsystemSpectrumType', 'subsystemSpectrumTypeWrapper', {'class':'subsystemSpectrumTypeDD'});
    injectDOM('option', 'subsystemEnergyPlot', 'subsystemSpectrumType', {'value':'E', 'innerHTML':'Energy'});
    //injectDOM('option', 'subsystemCFDPlot', 'subsystemSpectrumType', {'value':'C', 'innerHTML':'CFD Time'});
    injectDOM('option', 'subsystemWaveformPlot', 'subsystemSpectrumType', {'value':'W', 'innerHTML':'Waveform'});
    document.getElementById('subsystemSpectrumType').onchange = function(event){getSubsystemSpectrum();};
    document.getElementById('SubsystemSidebar').insertBefore(document.getElementById('subsystemSpectrumTypeWrapper'), document.getElementById('subsystemSpectrumViewer'));

    injectDOM('button', 'unzoomSubsystemSpectrum', 'SubsystemSidebar', {'onclick':window.spectrumViewers.subsystem.canvas.ondblclick, 'innerHTML':'Unzoom', 'class':'navLink', 'style':'float:left; margin-bottom:0.5em;'});
    injectDOM('label', 'subsystemSpectrumLinear', 'SubsystemSidebar', {'innerHTML':'Linear', 'style':'padding:0.5em; float:left; margin-left:1em; margin-right:-1em; margin-bottom:0.5em;'});
    toggleSwitch('SubsystemSidebar', 'toggleSubsystemSpectrumScale', '', '', '', window.spectrumViewers.subsystem.setAxisType.bind(window.spectrumViewers.subsystem, 'log'), window.spectrumViewers.subsystem.setAxisType.bind(window.spectrumViewers.subsystem, 'linear'), 0);
    injectDOM('label', 'subsystemSpectrumLog', 'SubsystemSidebar', {'innerHTML':'Log', 'style':'padding:0.5em; float:left; margin-right:1em; margin-left:-1em; margin-bottom:0.5em;'});
    injectDOM('div', 'subsystemRefreshWrap', 'SubsystemSidebar', {'style':'float:left; white-space:nowrap; margin-bottom:0.5em;'})
    injectDOM('label', 'subsystemSpectrumRefreshLabel', 'subsystemRefreshWrap', {'innerHTML':'Refresh Every: ', 'style':'clear:left; margin-left:2px;'});
    injectDOM('input', 'subsystemSpectrumRefresh', 'subsystemRefreshWrap', {
                                                                        'type':'number', 
                                                                        'min':0, 
                                                                        'value':'10', 
                                                                        'form':document.getElementById('subsystemSpectrumControl')
                                                                      });
    document.getElementById('subsystemSpectrumRefresh').onchange = function(){
    clearInterval(window.subsystemsSpectrumRefresh);
    window.subsystemsSpectrumRefresh = setInterval(refreshSpectra.bind(null, window.spectrumViewers.subsystem), parseInt(this.value,10)*1000 );              
    };
    injectDOM('label', 'subsystemSpectrumRefreshUnit', 'subsystemRefreshWrap', {'innerHTML':' s'});
    //refresh the spectrum every n seconds:
    window.subsystemsSpectrumRefresh = setInterval(refreshSpectra.bind(null, window.spectrumViewers.subsystem), 10000);

    injectDOM('button', 'subsystemSpectrumRefreshNow', 'subsystemRefreshWrap', {
                                                                            'innerHTML':'Refresh Now', 
                                                                            'class':'navLink', 
                                                                            'style':'float:left; margin-left:1em',
                                                                            'onclick': refreshSpectra.bind(null, window.spectrumViewers.subsystem)
                                                                          });
    injectDOM('button', 'fullSpectrumViewer', 'SubsystemSidebar', {
                                                                            'innerHTML':'Launch Full Spectrum Viewer', 
                                                                            'class':'navLink', 
                                                                            'style':'float:left; margin-bottom:0.5em;',
                                                                            'onclick': function(){
                                                                                //if(Object.keys(window.spectrumViewers.subsystem.plotBuffer)[0]) 
                                                                                    window.open('http://trshare.triumf.ca/~wjmills/spectrumViewer/?spectrum='+Object.keys(window.spectrumViewers.subsystem.plotBuffer)[0], '_blank')
                                                                            }
                                                                          });  
}

function thumbnail(canvasID, left, right, color, disabled){
	var canvas = document.getElementById(canvasID);
	var context = canvas.getContext('2d');

	var width = canvas.width;
	var height = canvas.height;

	window.width = width;
	window.height = height;

	context.clearRect(0,0,width,height);
	context.lineWidth = 1;

	var title = '';

	context.strokeStyle = color;
	context.fillStyle = color;

	//GRIFFIN options
	if(left == 'US SCEPTAR' && right == 'DS SCEPTAR'){
		sceptar(context, width/3, height*0.4, height*0.2, disabled);
		sceptar(context, 2*width/3, height*0.4, height*0.2, disabled);
		title = 'USSC + DSSC';
	} else if(left == 'US SCEPTAR' && right == 'ZDS'){
		sceptar(context, width/3, height*0.4, height*0.2, disabled);
		zds(context, 2/3*width, 0.4*height, 0.18*height, disabled);
		title = 'USSC + ZDS';
	} else if(left == 'PACES' && right == 'DS SCEPTAR'){
		paces(context, width/3, height*0.4, height*0.15, height*0.05);
		sceptar(context, 2*width/3, height*0.4, height*0.2, disabled);
		title = 'PACES + SCEPTAR';
	} else if(left == 'PACES' && right == 'ZDS'){
		paces(context, width/3, height*0.4, height*0.15, height*0.05, disabled);
		zds(context, 2/3*width, 0.4*height, 0.18*height, disabled);
		title = 'PACES + ZDS';
	} else if(left == 'SPICE' && right == 'ZDS'){
		spice(context, width/3, height*0.4, height*0.2, disabled);
		zds(context, 2/3*width, 0.4*height, 0.18*height, disabled);
		title = 'SPICE + ZDS';
	} else if(left == 'SPICE' && right == 'DS SCEPTAR'){
		spice(context, width/3, height*0.4, height*0.2);
		sceptar(context, 2*width/3, height*0.4, height*0.2, disabled);
		title = 'SPICE + DSSC';
	} else if(left == 'GRIFFIN' && right == 'none'){
		griffin(context, width*0.5 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		title = 'GRIFFIN Standalone';	
	} else if(left == 'GRIFFIN' && right == 'DESCANT'){
		griffin(context, width*0.28 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		descant(context, width*0.68, height*0.4, height*0.1 )
		title = 'GRIFFIN + DESCANT'
	} else if(left == 'GRIFFIN' && right == 'DANTE'){
		griffin(context, width*0.3 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		dante(context, width*0.7, height*0.4, height*0.2, color);
		title = 'GRIFFIN + DANTE';
	} else if(left == 'GRIFFIN' && right == 'SPICE'){
		griffin(context, width*0.28 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		spice(context, width*0.68, height*0.4, height*0.2, disabled);
		title = 'GRIFFIN + SPICE';
	}

	//TIGRESS options
	if(left == 'BAMBINO' && right == 'solo'){
		title = 'BAMBINO';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);	
	} else if(right == 'BAMBINO' && left == 'none'){
		title = 'DS BAMBINO';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);		
	} else if(left == 'BAMBINO' && right == 'BAMBINO'){
		title = 'US + DS BAMBINO';
		bambino(context, width*0.28, width*0.38, height/3, height*0.6, height*0.12);
		bambino(context, width*0.62, width*0.72, height/3, height*0.6, height*0.12);
	} else if(left == 'SHARC' && right == 'none'){
		title = 'SHARC';
		sharc(context, width/2, height*0.45, width*0.3, height*0.7, disabled);	
	} else if(left == 'SHARC' && right == 'services'){
		title = 'SHARC Services';
		sharc(context, width/2, height*0.45, width*0.3, height*0.7, disabled);	
	} else if(left == 'SPICE' && right == 'none'){
		spice(context, width*0.5, height*0.45, height*0.2, disabled);
		title = 'SPICE';
	} else if(left == 'SPICE' && right == 'services'){
		spice(context, width*0.5, height*0.45, height*0.2, disabled);
		title = 'SPICE Services';
	} else if(left == 'TIPwall' && right == 'none'){
		tipWall(context, width/2, height*0.45, height/2);
		title = 'TIP Wall';
	} else if(left == 'TIPball' && right == 'none'){
		tipBall(context, width/2, height/2, height*0.25);
		title = 'TIP Ball';
	} else if(left == 'TIGRESS' && right == 'none'){
		tigress(context, width/2, height*0.45, Math.round(height*0.25));
		title = 'TIGRESS';
	} else if(left == 'TIGRESS' && right == 'SHARC'){
		tigress(context, width*0.32, height*0.45, Math.round(height*0.25));
		sharc(context, width*0.7, height*0.45, width*0.3, height*0.7);
		title = 'TIGRESS + SHARC';
	} else if(left == 'TIGRESS' && right == 'DESCANT'){
		tigress(context, width*0.28, height*0.45, Math.round(height*0.25));
		descant(context, width*0.68,height*0.4, height*0.1 );
		title = 'TIGRESS + DESCANT';
	} else if(left == 'TIGRESS' && right == 'all'){
		tigress(context, width*0.2, height*0.45, Math.round(height*0.25));
		sharc(context, width*0.5, height*0.45, width*0.3, height*0.7);
		descant(context, width*0.8,height*0.4, height*0.1 );
		context.font = '14px Raleway';
		title = 'TIGRESS + SHARC + DESCANT';
	} else if(left == 'TIGRESS' && right == 'SPICE'){
		tigress(context, width*0.28, height*0.45, Math.round(height*0.25));
		spice(context, width*0.68, height*0.45, height*0.2, disabled);
		title = 'TIGRESS + SPICE';
	} else if(left == 'beamdump' && right == 'none'){
		beamdump(context, width/2, height*0.45, height*0.4)
		title = 'Beamdump Scintilator';
	}

	//standalone options
	if(left == 'HPGe' && right == 'none'){
		tigress(context, width/2, height*0.45, Math.round(height*0.25));
		title = 'HPGe';		
	} else if(left == 'DESCANT' && right=='none'){
		descant(context, width*0.5,height*0.4, height*0.1 );
		title = 'DESCANT';		
	} else if(left == 'PACES' && right=='none'){
		paces(context, width/2, height*0.4, height*0.15, height*0.05);
		title = 'PACES';
	} else if(left == 'DANTE' && right=='none'){
		dante(context, width*0.5, height*0.4, height*0.2, color);
		title = 'DANTE';
	} else if( (left == 'US SCEPTAR' || left == 'SCEPTAR') && right=='none'){
		sceptar(context, width/2, height*0.4, height*0.2, disabled);
		title = 'SCEPTAR';
	} else if(left == 'SPICE' && right=='none'){
		spice(context, width*0.5, height*0.45, height*0.2, disabled);
		title = 'SPICE';
	} else if(left == 'ZDS' && right=='none'){
		zds(context, 0.5*width, 0.4*height, 0.18*height);
		title = 'ZDS';
	} else if(left == 'BAMBINO' && right=='none'){
		title = 'BAMBINO';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);		
	} else if(left == 'TRIUMF' && right == 'none'){
		triumf(context, width*0.5 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		title = 'Top Level Config';	
	} else if(left == 'HV' && right == 'none'){
		hv(context, width, height, color);
		title = 'High Voltage';
	}

	if(right != 'all') context.font = '16px Raleway';
	context.fillText(title, width/2 - context.measureText(title).width/2, 0.9*height);
}

//individual thumbnails////////////////////////////////////////////////////////////////////////////////

//draw a SCEPTAR wireframe on context centered at x0, y0.  size is the center to outer vertext distance. 
function sceptar(context, x0, y0, size, disabled){
	var i, side;
	side = size*Math.sqrt(2-2*Math.cos(72/180*Math.PI));
	smallSize = 0.5*size;
	smallSide = smallSize*Math.sqrt(2-2*Math.cos(72/180*Math.PI));
	context.save();
	context.translate(x0, y0);
	context.beginPath();
	context.rotate(54/180*Math.PI);
	for(i=0; i<5; i++){
		context.moveTo(0,0);
		context.lineTo(size, 0);
		context.lineTo(size - side*Math.cos(54/180*Math.PI), side*Math.sin(54/180*Math.PI) );
		context.stroke();
		context.moveTo(smallSize, 0);
		context.lineTo(smallSize - smallSide*Math.cos(54/180*Math.PI), smallSide*Math.sin(54/180*Math.PI) );
		context.stroke();
		context.rotate(72/180*Math.PI);
	}
	context.closePath();
	context.restore();

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

function zds(context, x0, y0, radius, disabled){
	context.beginPath();
	context.arc(x0, y0, radius, 0, 2*Math.PI);
	context.closePath();
	context.stroke();

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

//draw a PACES wireframe on context centered at x0, y0.  size is the array center to detector center distance, rad is the detector radius.
function paces(context, x0, y0, size, rad, disabled){
	var i;

	context.save();
	context.translate(x0, y0);
	context.rotate(54/180*Math.PI);
	for(i=0; i<5; i++){
		context.beginPath();
		context.arc(size, 0, rad, 0, 2*Math.PI);
		context.closePath();
		context.stroke();
		context.rotate(72/180*Math.PI);
	}
	context.restore();

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

function spice(context, x0, y0, rad, disabled){
	var i, innerRad, radStep;

	innerRad = 0.15*rad;
	radStep = (rad - innerRad)/3

	for(i=0; i<4; i++){
		context.beginPath();
		context.arc(x0, y0, innerRad+i*radStep, 0, 2*Math.PI);
		context.closePath();
		context.stroke();
	}

	for(i=0; i<8; i++){
		context.beginPath();
		context.moveTo(x0 + innerRad*Math.cos(Math.PI/4*i), y0 + innerRad*Math.sin(Math.PI/4*i));
		context.lineTo(x0 + rad*Math.cos(Math.PI/4*i), y0 + rad*Math.sin(Math.PI/4*i));
		context.closePath();
		context.stroke();
	}

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

function descant(context, x0, y0, cellSize){
	var i, rad;

	//center to center distance of adjacent honeycomb cells:
	rad = 2*cellSize*Math.cos(30/180*Math.PI);

	regPoly(context, x0,y0, 6, cellSize);

	context.save();
	context.translate(x0, y0);
	for(i=0; i<6; i++){
		regPoly(context, 0, rad, 6, cellSize);
		context.rotate(60/180*Math.PI);
	}
	context.restore();
}

function dante(context, x0, y0, radius, color){
	var i;

	context.save();
	context.translate(x0,y0);
	context.rotate(Math.PI/8);
	context.beginPath();
	context.arc(0,0,radius, 0, 2*Math.PI);
	context.closePath();
	context.stroke();
	for(i=0; i<4; i++){
		context.beginPath();
		context.fillStyle = color;
		context.arc(radius, 0, radius*0.35, 0, 2*Math.PI);
		context.closePath();
		context.fill();
		context.beginPath();
		context.fillStyle = '#333333';
		context.arc(radius, 0, radius*0.3, 0, 2*Math.PI);
		context.closePath();
		context.fill();
		context.beginPath();
		context.fillStyle = color;
		context.arc(radius, 0, radius*0.2, 0, 2*Math.PI);
		context.closePath();
		context.fill();
		context.rotate(Math.PI/2);
	}
	context.restore();
}
function bambino(context, x0upper, x0lower, y0upper, y0lower, rad){
	var i, innerRad, radStep;

	innerRad = 0.15*rad;
	radStep = (rad - innerRad)/5

	for(i=0; i<6; i++){
		context.beginPath();
		context.arc(x0upper, y0upper, innerRad+i*radStep, 0, 2*Math.PI);
		context.closePath();
		context.stroke();

		if(i==0 || i==5){
			context.beginPath();
			context.arc(x0lower, y0lower, innerRad+i*radStep, 0, 2*Math.PI);
			context.closePath();
		}
		context.stroke();
	}

	for(i=0; i<12; i++){
		context.beginPath();
		context.moveTo(x0lower + innerRad*Math.cos(Math.PI/6*i), y0lower + innerRad*Math.sin(Math.PI/6*i));
		context.lineTo(x0lower + rad*Math.cos(Math.PI/6*i), y0lower + rad*Math.sin(Math.PI/6*i));
		context.closePath();
		context.stroke();		
	}
}

function sharc(context, x0, y0, width, height, disabled){
	context.save();
	context.translate(x0,y0);
	ellipse(context, 0, -0.35*height, 0.2*width, 0, Math.PI*2);
	ellipse(context, 0, 0.35*height, 0.2*width, 0, Math.PI*2);
	ellipse(context, 0, -0.35*height, 0.4/3*width, 0, Math.PI*2);
	ellipse(context, 0, 0.35*height, 0.4/3*width, 0, Math.PI*2);
	ellipse(context, 0, -0.35*height, 0.2/3*width, 0, Math.PI*2);
	ellipse(context, 0, 0.35*height, 0.2/3*width, 0, Math.PI*2);
	context.strokeRect(-width*0.2, -height*0.2, width*0.4, height*0.4);
	context.stroke();
	context.beginPath();
	context.moveTo(-width*0.2, 0);
	context.lineTo(width*0.2, 0);
	context.stroke();
	context.beginPath();
	context.moveTo(-width*0.4/6, -height*0.2);
	context.lineTo(-width*0.4/6, height*0.2);
	context.stroke();
	context.beginPath();
	context.moveTo(width*0.4/6, -height*0.2);
	context.lineTo(width*0.4/6, height*0.2);
	context.stroke();
	context.restore();

	if(disabled)
		strikeOut(context, window.width, window.height, x0, y0)
}

function tipWall(context, x0, y0, width){
		var i, cellSize, CsIx0, CsIy0;

		cellSize = width / 5;
		CsIx0 = x0-width/2;
		CsIy0 = y0-width/2;

    	for(i=0; i<25; i++){
            context.strokeRect(CsIx0 + cellSize*(i%5), CsIy0 + cellSize*Math.floor(i/5), cellSize, cellSize);
    	}
    	context.strokeRect(CsIx0, CsIy0, width, width)
}

function tipBall(context, x0, y0, rad){

	context.save();

	context.beginPath();
	context.arc(x0,y0,rad,0,Math.PI*2);
	context.clip();

	context.beginPath();
	context.lineWidth = 2;
	context.arc(x0,y0,rad-1,0,Math.PI*2);
	context.stroke();

	context.lineWidth=1;
	context.beginPath();
	context.arc(x0+20,y0,rad+10,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0-20,y0,rad+10,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0+20,rad+10,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0-20,rad+10,0,Math.PI*2);
	context.stroke();

	context.beginPath();
	context.arc(x0+40,y0,rad+20,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0-40,y0,rad+20,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0+40,rad+20,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0-40,rad+20,0,Math.PI*2);
	context.stroke();

	context.beginPath();
	context.moveTo(x0-rad, y0);
	context.lineTo(x0+rad,y0);
	context.stroke;
	context.moveTo(x0, y0-rad);
	context.lineTo(x0, y0+rad);
	context.stroke();

	context.restore();

}

function griffin(context, x0, y0, color){
	if(color == '#999999')context.globalAlpha = 0.4;
	context.drawImage(imageObj, x0, y0, imageObj.width/imageObj.height*context.canvas.height*0.6, context.canvas.height*0.6);
	context.globalAlpha = 1;
}

function triumf(context, x0, y0, color){
	if(color == '#999999')context.globalAlpha = 0.4;
	context.drawImage(imageObj, x0, y0, imageObj.width/imageObj.height*context.canvas.height*0.6, context.canvas.height*0.6);
	context.globalAlpha = 1;
}

function tigress(context, x0, y0, size){
	var hpge = Math.round(size*0.3);
	var bgo = Math.round(size*0.75);

	context.save();
	context.translate(x0, y0);
	context.strokeRect(-size, -size, 2*size, 2*size);
	context.strokeRect(-bgo, -bgo, 2*bgo, 2*bgo);
	context.strokeRect(-hpge, -hpge, 2*hpge, 2*hpge );

	context.moveTo(-hpge, 0);
	context.lineTo(hpge, 0);
	context.moveTo(0, -hpge);
	context.lineTo(0, hpge);

	context.moveTo(0, -size);
	context.lineTo(0, -(size-hpge) - 2 );
	context.moveTo(0, size);
	context.lineTo(0, size-hpge + 2 );
	context.moveTo(-size, 0);
	context.lineTo(-(size-hpge) - 2, 0);
	context.moveTo(size, 0);
	context.lineTo(size-hpge + 2, 0);

	context.stroke();
	context.restore();
}

function beamdump(context, x0, y0, width){
	var i;

	context.save();
	context.translate(x0, y0);

	context.moveTo(width/2, -width/2);
	context.lineTo(width/2, width/2);
	context.moveTo(width*0.45, -width/2 );
	context.lineTo(width*0.45, width/2);

	for(i=0; i<10; i++){
		context.moveTo(width*0.45, width/2 - i*width/10);
		context.lineTo(width*0.5, width/2 - (i+1)*width/10)
	}

	context.fillRect(-width/2, -2, width*0.95, 4);

	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.4, 12);
	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.3, 20);
	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.4, -15);
	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.1, -10)

	context.stroke();
	context.restore();

}

function hv(context, width, height, color){
	context.fillStyle = color;
	context.beginPath()
	context.moveTo(0.6*width, 0.2*height);
	context.lineTo(0.4*width, 0.475*height);
	context.lineTo(0.5*width, 0.475*height);
	context.lineTo(0.4*width, 0.7*height);
	context.lineTo(0.6*width, 0.425*height);
	context.lineTo(0.5*width, 0.425*height);
	context.closePath();
	context.fill()
}

//draws a regular polygon of n sides on context, centered at x0, y0 and with a center-vertext distance of size
function regPoly(context, x0, y0, n, size){
	var i;
	var stepAngle = 2*Math.PI/n;
	var jointAngle = (Math.PI-stepAngle)/2;
	var side = size*Math.sqrt(2-2*Math.cos(stepAngle));

	context.save();
	context.translate(x0, y0);
	context.beginPath();
	for(i=0; i<n; i++){
		context.moveTo(size, 0);
		context.lineTo(size - side*Math.cos(jointAngle), 0-side*Math.sin(jointAngle));
		context.stroke();
		context.rotate(stepAngle);
	}
	context.restore();
}

function strikeOut(context, width, height, x0, y0){

	context.save();
	context.beginPath()
	context.lineWidth = 5;
	context.strokeStyle = '#FF0000';
	context.moveTo(x0-width/4, y0-height/4);
	context.lineTo(x0+width/4, y0+height/4);
	context.stroke();
	context.moveTo(x0+width/4, y0-height/4);
	context.lineTo(x0-width/4, y0+height/4);
	context.stroke();
	context.restore();

}

function glowy(canvasID){
	var canvas = document.getElementById(canvasID);
	var context = canvas.getContext('2d');

	context.shadowOffsetX = 0;
	context.shadowOffsetY = 0;
	context.shadowBlur = 2;
	context.shadowColor = '#FFFFFF';
	thumbnail('Gcha5canv', 'SPICE', 'DSSC');
	context.fill();

}

//cycle badges/////////////////////////////////////////////////////
function clearScalars(context, height, width){
	context.fillStyle = '#999999';
	digitalDigit([1,1,1,1,1,1,0], context, height, 0.2*width, 0.05*height);
	digitalDigit([1,1,1,1,1,1,0], context, height, 0.65*width, 0.05*height);
}

function moveTape(context, width, height, x0, y0){
	var i,
		tapeTop = 0.1*height;
		tapeHeight = 0.6*height;
		holeSide = tapeHeight/10;
		holeSpacing = holeSide/2;

	context.fillStyle = '#999999';
	context.fillRect(0, tapeTop, width, tapeHeight);
	context.fillStyle = '#333333';
	for(i=0; i<20; i++){
		context.fillRect(i*(holeSpacing+holeSide), tapeTop+holeSpacing, holeSide, holeSide );
		context.fillRect(i*(holeSpacing+holeSide), tapeTop+tapeHeight - holeSpacing - holeSide, holeSide, holeSide );
	}
	roundBox(context, -0.1*width, tapeTop+2*holeSpacing+holeSide, 0.33*width, tapeHeight - 2*(2*holeSpacing+holeSide), 5);
	context.fill();
	roundBox(context, 0.25*width, tapeTop+2*holeSpacing+holeSide, 0.5*width, tapeHeight - 2*(2*holeSpacing+holeSide), 5);
	context.fill();
	roundBox(context, 0.77*width, tapeTop+2*holeSpacing+holeSide, 0.5*width, tapeHeight - 2*(2*holeSpacing+holeSide), 5);
	context.fill();

}

function beamOn(context, width, height, x0, y0){
	beamdump(context, x0, y0, width);
}

function triggersOn(context, width, height, x0, y0){
	//fingernail
	context.moveTo(width*0.5, height*0.3);
	context.quadraticCurveTo(width*0.52, height*0.32, width*0.6, height*0.35);
	context.quadraticCurveTo(width*0.52, height*0.37, width*0.5, height*0.3)

	//finger top
	context.moveTo(width*0.5, height*0.3);
	context.quadraticCurveTo(width*0.5*0.9, height*0.3*0.9, -2*width, -width);
	context.stroke();

	//finger bottom
	context.moveTo(width*0.6, height*0.35);
	context.quadraticCurveTo(width*0.55, height*0.6, -2*width, -width);
	context.stroke();

	//switch
	context.moveTo(0, height*0.7);
	context.lineTo(width, height*0.7);
	context.moveTo(0.3*width, height*0.7);
	context.lineTo(0.3*width, height*0.5);
	context.quadraticCurveTo(0.5*width, height*0.55, 0.7*width, height*0.5);
	context.lineTo(0.7*width, 0.7*height);

	//arrow
	context.moveTo(0.5*width, 0.6*height);
	context.lineTo(0.9*width, 0.6*height);
	context.lineTo(0.85*width, 0.55*height);
	context.moveTo(0.9*width, 0.6*height);
	context.lineTo(0.85*width, 0.65*height);


	context.stroke();
}

function syncClocks(context, width, height, x0, y0){
	var i;

	context.beginPath();
	context.arc(x0,y0, height*0.3, 0, Math.PI*2);
	context.stroke();
	context.closePath();

	context.save();
	context.translate(x0, y0);
	for(i=0; i<12; i++){
		context.moveTo(0, -height*0.3);
		context.lineTo(0, -height*0.3 +height*0.06);
		context.stroke();
		context.closePath();
		context.rotate(Math.PI/6);
	}

	context.moveTo(0, 0);
	context.lineTo(height*0.3*Math.cos(1.2*Math.PI), height*0.3*Math.sin(1.2*Math.PI));
	context.stroke();
	context.closePath();

	context.moveTo(0, 0);
	context.lineTo(height*0.15*Math.cos(4.3*Math.PI), height*0.15*Math.sin(4.3*Math.PI));
	context.stroke();
	context.closePath();	

	context.restore();
}

function wildcard(context, width, height, x0, y0){
	context.font = '100px Raleway';
	context.fillText('*', width/2-15, height);
	context.font = '16px Raleway';
}function Tooltip(ttCanvasID, ttDivID, wrapperID, prefix, postfix){

    this.obj;                                       //the object that this tooltip is associated with
    this.canvasID = ttCanvasID;                     //target canvas
    this.ttDivID = ttDivID;                         //tooltip div
    this.wrapperID = wrapperID;                     //ID of div which wraps the tooltip's canvas
    this.prefix = prefix;                           //prefixes to tooltip content lines
    this.postfix = postfix;                         //postfixes to tooltip content lines

    //inject the necessary DOM elements for this tooltip:
    //wrapper div
    injectDOM('div', this.ttDivID, 'body', {'class':'tooltip'});

    this.canvas = document.getElementById(this.canvasID);
    this.context = this.canvas.getContext('2d'); 
    this.ttDiv = document.getElementById(this.ttDivID);
    this.ttParent = document.getElementById(this.wrapperID);

    //old tt bin, for updates when the mouse is just sitting in the same place:
    this.oldCellIndex = -1;
    this.allowUpdate = 0;

    var that = this;

    //suppresses some flaky positioning when TT changes size:
    this.canvas.onmouseover = function(event){
        that.ttDiv.style.display = 'none';
        that.allowUpdate = 0;
    }

    this.canvas.onmousemove = function(event){

        //force the tooltip off - patches persistency problem when moving down off the waffle.  TODO: understand persistency problem.
        that.ttDiv.style.display = 'none';

        //get mouse coords:
        var x = event.pageX - that.canvas.offsetLeft - that.ttParent.offsetLeft;   
        var y = event.pageY - that.canvas.offsetTop - that.ttParent.offsetTop;

        //turn mouse coords into the index pointing to where the relevant info is stored in obj's info arrays:
        var cellIndex = that.obj.findCell(x, y);

        //assume we're not pointing at anything until we confirm that we are:
        that.obj.pointingNow = null;

        //only continue if the cursor is actually on a valid channel; x and y>0 suppresses an antialiasing bug:
        if(cellIndex != -1 && x>1 && y>1 && x<that.obj.canvasWidth-1 && y<that.obj.canvasHeight-1){

            document.body.style.cursor = 'pointer';

            //establish text:
            that.obj.defineText(cellIndex);

            //set the display on so offsetHeight and Width work:
            that.ttDiv.style.display = 'block';
            that.ttDiv.style.opacity = 0;

            //decide how to position the TT:
            if(window.state.staticTT){
                that.ttDiv.style.top = window.innerHeight/2 - that.ttDiv.offsetHeight/2;
                that.ttDiv.style.left = window.innerWidth/2 - that.ttDiv.offsetWidth/2;
                that.ttDiv.style.right = 'auto';
            } else {
                //make the tool tip follow the mouse, but keep it on the screen:
                that.ttDiv.style.top = Math.min(event.pageY - 10, window.innerHeight + window.pageYOffset - that.ttDiv.offsetHeight);
                if(event.pageX < that.canvas.offsetWidth || window.renderWidth>15000){
                    that.ttDiv.style.right = 'auto'
                    that.ttDiv.style.left = event.pageX  + 10;
                }else{
                    that.ttDiv.style.left = 'auto';
                    that.ttDiv.style.right = window.innerWidth - event.pageX + 10;
                }
            }
            //turn the TT on:
            that.ttDiv.style.opacity = 1;

            //keep track of tooltip position
            that.oldCellIndex = cellIndex;
            that.allowUpdate = 1;

            //return to default TT positioning:
            window.state.staticTT = 0;

        } else {
            document.body.style.cursor = 'auto';
            that.allowUpdate = 0;
        }
    }

    //turn the tool tip off if it's outside the canvas:
    this.canvas.onmouseout = function(event){
        that.ttDiv.style.display = 'none';
        that.allowUpdate = 0;
    }

    //updater for if the tooltip is stationary during a master loop transition:
    this.update = function(){
        if(this.allowUpdate){
            //establish text:
            this.obj.defineText(this.oldCellIndex);
        }
    };

}//generic function to execute the animation of some object <thing>, which has memeber function .draw which draws
//the thing only as a function of what frame the animation is on, and member data .duration, .FPS and .nFrames.
function animate(thing, frame){

    //clearTimeout(window.animateLoop);

    thing.draw(frame);
    if(frame < thing.nFrames){
        frame++;
        window.animateLoop = setTimeout(function(){animate(thing, frame)},thing.duration/thing.FPS*1000);
    }
}

//copy of animate, but for use on detail level view:  todo: combine with animate
function animateDetail(thing, frame){

    thing.drawDetail(thing.detailContext, frame);
    if(frame < thing.nFrames){
        frame++;
        window.transAnimateLoop = setTimeout(function(){animateDetail(thing, frame)},thing.duration/thing.FPS*1000);
    }
}

//styling functions to highlight / unhighlight submit button
function unhighlight(buttonID){
    clearTimeout(window.commitBlink);
    $('#'+buttonID).css('background-color', '#FFFFFF');
}

function highlight(buttonID){

    //$('#'+buttonID).css('background-color', '#FFFF00');
    clearTimeout(window.commitBlink);
    function blinkHighlight(color){
        $('#'+buttonID).css('background-color', color);

        if(color == '#FFFFFF') window.commitBlink = setTimeout(function(){blinkHighlight('#FFFF00')},1000);
        if(color == '#FFFF00') window.commitBlink = setTimeout(function(){blinkHighlight('#FFFFFF')},1000);
    }

    blinkHighlight('#FFFF00')


}

//insert something in the DOM
function insertDOM(element, id, classTag, style, wrapperID, onclick, content, name, type, value){
    var newElement = document.createElement(element);
    newElement.setAttribute('id', id);
    newElement.setAttribute('class', classTag);
    newElement.setAttribute('style', style);
    newElement.setAttribute('name', name);
    newElement.setAttribute('type', type);
    newElement.setAttribute('value', value);
    if(wrapperID == 'body')
        document.body.appendChild(newElement)
    else
        document.getElementById(wrapperID).appendChild(newElement);
    document.getElementById(id).innerHTML = content;
    document.getElementById(id).onclick = onclick;
}

//more flexible DOM injector; <properties> is an object containing property.value pairs for all properties to be set: 
function injectDOM(element, id, wrapperID, properties){
    var key, elt,
        newElement = document.createElement(element);
    //explicit ID
    newElement.setAttribute('id', id);
    //append to document:
    if(wrapperID == 'body')
        document.body.appendChild(newElement)
    else
        document.getElementById(wrapperID).appendChild(newElement);
    elt = document.getElementById(id);

    //some things need to be set specially:
    if(properties['innerHTML'] || properties['innerHTML'] === 0){
        elt.innerHTML = properties['innerHTML'];
        delete properties['innerHTML'];
    }
    if(properties['onclick']){
        elt.onclick = properties['onclick'];
        delete properties['onclick'];
    }
    //send in the clowns:
    for(key in properties){
        elt.setAttribute(key, properties[key]);
    }

}

//devName = device Name, scales = [ [scale title, parameter service minima, parameter service maxima, unit, ODBminpath, ODBmaxpath], ...]
function parameterDialogue(devName, scales, currentColorScale, noLog){
    var i, j, ODBpath;

    //insert div and title
    injectDOM('div', 'tempDiv', window.parameters.wrapper, {'class' : 'tempDialog'});
    var dialogue = document.getElementById('tempDiv');
    injectDOM('h2', 'dialogHeader', 'tempDiv', {
        'style' : 'position:relative; font:24px Orbitron; top:10px; margin-bottom:6%',
        'innerHTML' : 'Adjust '+devName+' Scale'
    });

    //fix dimensions
    var width = 0.35*window.innerWidth;
    $('#dialogHeader').width(width)

    //center dialogue
    $('#tempDiv').css('left', ($('#'+window.parameters.wrapper).width()/2 - width/2))

    //insert form fields
    injectDOM('form', 'dialogueValues', 'tempDiv', {});
    for(i=0; i<scales.length; i++){
        injectDOM('p', 'title'+i, 'dialogueValues', {'style':'font-size:16px; margin-top:3%;', 'innerHTML':scales[i][0]+'<br>'});
        injectDOM('p', 'minlabel'+i, 'dialogueValues', {'style':'display:inline', 'innerHTML':'Minimum: '});
        injectDOM('input', 'minfield'+i, 'dialogueValues', {
            'style' : 'display:inline;',
            'name' : 'textbox',
            'type' : 'number',
            'value' : scales[i][1],
            'size' : 6
        });
        injectDOM('p', 'minunit'+i, 'dialogueValues', {'style':'display:inline; margin-right:3%', 'innerHTML':scales[i][3]});
        injectDOM('p', 'maxlabel'+i, 'dialogueValues', {'style':'display:inline;', 'innerHTML':'Maximum: '});
        injectDOM('input', 'maxfield'+i, 'dialogueValues', {
            'style' : 'display:inline;',
            'name' : 'textbox',
            'type' : 'number',
            'value' : scales[i][2],
            'size' : 6
        });
        injectDOM('p', 'maxunit'+i, 'dialogueValues', {'style':'display:inline;', 'innerHTML':scales[i][3] + '<br>'});
        //don't allow min > max:
        document.getElementById('minfield'+i).onchange = function(){document.getElementById('maxfield'+this.id[8]).min = document.getElementById(this.id).valueAsNumber;};

    }

    //insert color scale picker:
    if(currentColorScale){
        injectDOM('p', 'colorPickerLabel', 'dialogueValues', {'style':'display:inline;', 'innerHTML':'<br><br>Palette: '})
        var colorScales = window.parameters.colorScale;
        injectDOM('select', 'colorOptions', 'dialogueValues', {});
        var colorDD = document.getElementById('colorOptions');
        var option = [];
        for(i=0; i<colorScales.length; i++){
            option[i] = document.createElement('option');
            option[i].text = colorScales[i];
            option[i].value = colorScales[i];
            colorDD.add(option[i], null);
        }
        colorDD.value = currentColorScale;
        injectDOM('br', 'break', 'dialogueValues', {});
    }

    //insert scale linear / log choice:
    if(!noLog){
        injectDOM('p', 'scalePickerLabel', 'dialogueValues', {'style':'display:inline; margin-right:2%', 'innerHTML':'<br><br>Scale: '});
        injectDOM('p', 'linearRadioLabel', 'dialogueValues', {'style':'display:inline', 'innerHTML':'Linear'});
        injectDOM('input', 'linearRadio', 'dialogueValues', {
            'style' : 'display:inline; margin-right:2%;',
            'name' : 'scaleSwitch',
            'type' : 'radio',
            'value' : 'linear'
        });
        injectDOM('p', 'logRadioLabel', 'dialogueValues', {'style':'display:inline', 'innerHTML':'Log'});
        injectDOM('input', 'logRadio', 'dialogueValues', {
            'style' : 'display:inline;',
            'name' : 'scaleSwitch',
            'type' : 'radio',
            'value' : 'log'
        });
        injectDOM('br', 'break', 'dialogueValues', {});

        if (window.parameters.detectorLogMode[window.viewState] == 1) document.getElementById('logRadio').checked = true;
        else document.getElementById('linearRadio').checked = true;
    }

    //insert submit & dismiss button
    injectDOM('input', 'updateParameters', 'dialogueValues', {
        'class' : 'bigButton',
        'style' : 'width:20%; margin-right:2%; margin-top:6%',
        'type' : 'button',
        'value' : 'Commit'
    });
    injectDOM('input', 'dismiss', 'dialogueValues', {
        'class' : 'bigButton',
        'style' : 'width:20%; margin-top:6%; margin-bottom:6%;',
        'type' : 'button',
        'value' : 'Dismiss'
    });

    document.getElementById('updateParameters').onclick = function(event){
        var i;
        if(document.getElementById('dialogueValues').checkValidity()){
            
            for(i=0; i<scales.length; i++){
                //commit
                scales[i][1] = parseFloat(document.getElementById('minfield'+i).value);
                scales[i][2] = parseFloat(document.getElementById('maxfield'+i).value);
                ODBSet(scales[i][4], scales[i][1]);
                ODBSet(scales[i][5], scales[i][2]);
            }
            fetchODB(); //pushes back to the parameter store

            if(currentColorScale){
                if(window.onDisplay.slice(0,3) == 'DAQ'){
                    window.DAQpointer.DAQcolor = window.parameters.colorScale.indexOf(colorDD.value);
                } else {
                    window.parameters.subdetectorColors[window.state.subdetectorView] = colorDD.value;
                }
            }

            if(!noLog){
                if(document.getElementById('logRadio').checked) window.parameters.detectorLogMode[window.viewState] = 1;
                else if(document.getElementById('linearRadio').checked) window.parameters.detectorLogMode[window.viewState] = 0;
            }

            //remove dialogue
            document.getElementById('tempDiv').style.opacity = 0;
            setTimeout(function(){
                var element = document.getElementById('tempDiv');
                element.parentNode.removeChild(element);            
            }, 500);

            rePaint();

        } else{
            alert("Something doesn't make sense.  Check fields for mistakes, highlighted in red.");
        }
    }

    document.getElementById('dismiss').onclick = function(event){
        document.getElementById('tempDiv').style.opacity = 0;
        setTimeout(function(){
            var element = document.getElementById('tempDiv');
            element.parentNode.removeChild(element);            
        }, 500);
    }

    //fade the div in:
    dialogue.style.opacity = 1
}

//help build the ODB path string for the above parameter dialogue:
function scaleType(){
    if (window.state.subdetectorView == 0) return 'HVscale';
    else if (window.state.subdetectorView == 1 || window.state.subdetectorView == 3) return 'thresholdScale';
    else if (window.state.subdetectorView == 2 || window.state.subdetectorView == 4) return 'rateScale';    
}

//Crockford's prototype magics:
function DCobject(o) {
    function F() {}
    F.prototype = o;
    return new F();
}


//return the biggest font size that fits a string into a given length in a given context:
function fitFont(context, string, length){
    var i, size = 1;
    context.font = size+'px Raleway';
    
    while(context.measureText(string).width < length){
        size++;
        context.font = size+'px Raleway';
    }
    
    return size-1;
}

//get the <tag> elements inside a given <parent> (for stripping the head out of the imported status page, since those objects currently have no id's :/ )
function getTag(tag, parentID){
    parent = document.getElementById(parentID);
    var descendants = parent.getElementsByTagName(tag);
    if ( descendants.length )
        return descendants;
    return null;
}

//generate a fake JSONP scalar post to use for offline development:
function fakeScalars(){
    
    var JSONP = {'scalar' : {} },
        key, subKey;


    for(key in ODB){
        if(ODB[key].deploy || ODB[key].USdeploy || ODB[key].DSdeploy){     
            for(subKey in window[key+'pointer'].dataBus[key]){
                JSONP.scalar[subKey] = {"TRIGREQ" : 1000*Math.random(), "dataRate" : 1000*Math.random()};
            }
        }
    }

    return JSONP;
    
}
//like fake scalars, but now thresholds:
function fakeThresholds(){

    var JSONP = {'parameters' : {'thresholds' : {} } },
        key, subKey;

    for(key in ODB){
        if(ODB[key].deploy || ODB[key].USdeploy || ODB[key].DSdeploy){
            for(subKey in window[key+'pointer'].dataBus[key] ){
                JSONP.parameters.thresholds[subKey] = 1000*Math.random();
            }
        }
    }

    return JSONP;

}

//take a standard object from datastructures and a frame, and determine the appropriate fill color:
function frameColor(obj, frame, nFrames){
    var oldKey, newKey;

    //pick the right keys
    if(window.state.subdetectorView == 0){
        if(obj.HV == 0xDEADBEEF) return 0xDEADBEEF;
        oldKey = 'oldHVcolor';
        newKey = 'HVcolor';
    } else if(window.state.subdetectorView == 1){
        if(obj.threshold == 0xDEADBEEF) return 0xDEADBEEF;
        oldKey = 'oldThresholdColor';
        newKey = 'thresholdColor';
    } else if(window.state.subdetectorView == 2){
        if(obj.rate == 0xDEADBEEF) return 0xDEADBEEF;
        oldKey = 'oldRateColor';
        newKey = 'rateColor';
    }

    return interpolateColor(parseHexColor(obj[oldKey]), parseHexColor(obj[newKey]), frame/nFrames);

}

//make a table for a tooltip using <objects> as rows and <keys> as columns, where the objects are keys of <data>, and insert it into DOM element <id>.  
//[split] indicates how many elements to put in each supercolumn:
function TTtable(id, data, objects, keys, rowTitles, tableTitle, titles, split){
    var i, j, k, n, nContentRows, cellContent;

    injectDOM('table', id+'table', id, {'class':'TTtab', 'style':'border-collapse:collapse'});
    injectDOM('colgroup', id+'colgroup', id+'table', {});
    for(i=0; i<split.length-1; i++){
        injectDOM('col', id+'colSpace'+i, id+'colgroup', {'span':keys.length+1});
        injectDOM('col', id+'col'+i, id+'colgroup', {'style':'border-left:1px solid white;', 'span':'1'});
    }


    if(tableTitle != ''){
        injectDOM('tr', id+'tableTitleRow', id+'table', {});
        injectDOM('td', id+'tableTitle', id+'tableTitleRow', {'innerHTML':tableTitle, 'colspan':(1+keys.length)*split.length});
    }

    injectDOM('tr', id+'tableHeaderRow', id+'table', {});
    for(k=0; k<split.length; k++){
        for(j=0; j<titles.length; j++){
            injectDOM('td', id+'headerCell'+j+'col'+k, id+'tableHeaderRow', {
                'style' : 'padding-left:'+( (j==0 && k!=0) ? 25:10 )+'px; padding-right:'+( (j==titles.length-1) ? 25:10 )+'px;',
                'innerHTML' : titles[j]
            });
        }
    }
    
    nContentRows = Math.max.apply(null, split);

    //build table:
    for(i=0; i<nContentRows; i++){
        //rows
        injectDOM('tr', id+'row'+i, id+'table', {});
        //cells
        for(j=0; j<titles.length*split.length; j++){
            injectDOM('td', id+'row'+i+'cell'+j, id+'row'+i, {
                'style' : 'padding:0px; padding-right:'+( (j%(titles.length+1)==0 && j!=0) ? 25:10 )+'px; padding-left:'+( (j%titles.length == 0 && j!=0) ? 25:10 )+'px'
            });
            //if(j%(keys.length+1)==keys.length && j!=titles.length*split.length-1 ){
            //    document.getElementById(id+'row'+i+'cell'+j).setAttribute('style', 'border-right:1px solid white');
            //}
        }
    }

    //fill table:
    n=0;

    for(i=0; i<split.length; i++){
        for(j=0; j<split[i]; j++){
            document.getElementById(id+'row'+j+'cell'+(titles.length*i)).innerHTML = rowTitles[n];
            for(k=0; k<keys.length; k++){

                if(typeof data[objects[n]][keys[k]] == 'string')
                    cellContent = data[objects[n]][keys[k]];
                else
                    cellContent = data[objects[n]][keys[k]].toFixed(window.parameters.tooltipPrecision);
                if(cellContent == 0xDEADBEEF) cellContent = '0xDEADBEEF'
                document.getElementById(id+'row'+j+'cell'+(1+titles.length*i+k)).innerHTML = cellContent;
            }
            n++;
        }
    }

}

//return an array with the appropriate colors chosen from <dataStore> (typically dataBus[this.name] for detectors) corresponding to the elements listed in [elements]
function colors(elements, dataStore, frame, nFrames){
    var i,
        colors=[];

    if(Array.isArray(elements)){
        for(i=0; i<elements.length; i++){
            colors[i] = viewMap(elements[i], dataStore, frame, nFrames);
        }
    } else {
        colors = viewMap(elements, dataStore, frame, nFrames);
    }

    function viewMap(elements, dataStore, frame, nFrames){
        if(window.state.subdetectorView == 0) return interpolateColor(parseHexColor(dataStore[elements].oldHVcolor), parseHexColor(dataStore[elements].HVcolor), frame/nFrames);
        else if(window.state.subdetectorView == 1 || window.state.subdetectorView == 3) return interpolateColor(parseHexColor(dataStore[elements].oldThresholdColor), parseHexColor(dataStore[elements].thresholdColor), frame/nFrames);
        else if(window.state.subdetectorView == 2 || window.state.subdetectorView == 4) return interpolateColor(parseHexColor(dataStore[elements].oldRateColor), parseHexColor(dataStore[elements].rateColor), frame/nFrames);        
    }

    return colors;
}

String.prototype.width = function(font) {
  var f = font || '12px arial',
      o = $('<div>' + this + '</div>')
            .css({'position': 'absolute', 'float': 'left', 'white-space': 'nowrap', 'visibility': 'hidden', 'font': f})
            .appendTo($('body')),
      w = o.width();

  o.remove();

  return w;
}

function arraySum(start, end) {
    var i, last, total = 0;

    (end == -1) ? last = this.length : end;

    for(i=start; i<end; i++){
        total += parseFloat(this[i]);
    }
    return total
}


function relMouseCoords(event){
    var totalOffsetX = 0,
    totalOffsetY = 0,
    canvasX = 0,
    canvasY = 0,
    currentElement = this,
    test = [],
    elts = [];

    if (event.offsetX !== undefined && event.offsetY !== undefined) { return {x:event.offsetX, y:event.offsetY}; }
    //if (event.layerX !== undefined && event.layerY !== undefined) { return {x:event.layerX, y:event.layerY}; }

    do{
        totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
        totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
        //test[test.length] = currentElement.offsetLeft - currentElement.scrollLeft
        //elts[elts.length] = currentElement
    }
    while(currentElement = currentElement.offsetParent)

    canvasX = event.pageX - totalOffsetX;
    canvasY = event.pageY - totalOffsetY;

    //hack to deal with FF scroll, better solution TBD:
    if(event.offsetX == undefined){
        canvasX -= document.body.scrollLeft;
        canvasY -= document.body.scrollTop;
    }

    return {x:canvasX, y:canvasY}
}
HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;

//generic confirmation dialog
function confirm(headline, detailText, confirmFunc){
    var i, j, ODBpath;

    //insert div and title
    injectDOM('div', 'tempDiv', 'body', {'class':'tempDialog'});
    var dialogue = document.getElementById('tempDiv');
    injectDOM('h2', 'dialogHeader', 'tempDiv', {
        'style' : 'position:relative; font:24px Orbitron; top:10px; margin:0px; margin-left:auto; margin-right:auto; padding:1em; padding-top:0;',
        'innerHTML' : headline
    })

    //warning text
    injectDOM('p', 'warning', 'tempDiv', {'style':'padding: 1em; margin:0px; font-size:120%;', 'innerHTML':detailText});

    //center dialogue
    var width = document.getElementById('tempDiv').offsetWidth;
    document.getElementById('tempDiv').style.left = document.body.offsetWidth/2 - width/2;

    //insert submit & abort button if there's a function to excecute on confirm, otherwise just an acknowledge button
    if(confirmFunc){
        injectDOM('input', 'confirmChoice', 'tempDiv', {
            'class' : 'standardButton',
            'style' : 'width:auto; height:auto; padding:0.5em; margin-left:0px',
            'type' : 'button',
            'value' : 'Confirm'
        });

        document.getElementById('confirmChoice').onclick = function(event){

            confirmFunc();

            document.getElementById('tempDiv').style.opacity = 0;
            setTimeout(function(){
                var element = document.getElementById('tempDiv');
                element.parentNode.removeChild(element);            
            }, 500);

            rePaint();
        }
    }

    injectDOM('input', 'abortChoice', 'tempDiv', {
        'class' : 'standardButton',
        'style' : 'width:auto; height:auto; padding:0.5em;',
        'type' : 'button',
        'value' : (confirmFunc == null) ? 'Dismiss' : 'Abort'
    });

    document.getElementById('abortChoice').onclick = function(event){
        document.getElementById('tempDiv').style.opacity = 0;
        setTimeout(function(){
            var element = document.getElementById('tempDiv');
            element.parentNode.removeChild(element);            
        }, 500);
    }

    //fade the div in:
    dialogue.style.opacity = 1
}

//define function to fetch from JSONP service
//for the scalar service (and anything with the same hierarchy):
function parseResponse(dataWeGotViaJsonp){
    var key, subkey;
    for(key in dataWeGotViaJsonp){
        if (dataWeGotViaJsonp.hasOwnProperty(key)) {
            window.JSONPstore[key] = {};
            for(subkey in dataWeGotViaJsonp[key]){
                if(dataWeGotViaJsonp[key].hasOwnProperty(subkey)){
                    window.JSONPstore[key][subkey.toUpperCase()] = dataWeGotViaJsonp[key][subkey];
                }
            }
        }
    }
}

//similar function for the threshold service:
function parseThreshold(data){
    var key;
    if(data['parameters']['thresholds']){
        window.JSONPstore['thresholds'] = {};
        //console.log(window.JSONPstore['thresholds'])
        for(key in data['parameters']['thresholds']){
            window.JSONPstore['thresholds'][key.toUpperCase().slice(0,10)] = data['parameters']['thresholds'][key];
        }
        //console.log(window.JSONPstore['thresholds'])
    }

    //console.log(data['parameters']['thresholds']['SPI00XN119'])
}

function deployFooter(){
    injectDOM('div', 'footer', 'body', {
        'innerHTML' : 'GRIFFIN 2013<br>GRIFFIN Collaboration Spokesperson: Adam Garnsworthy (garns@triumf.ca) - UI/UX Design & Web Development: Bill Mills (mills.wj@gmail.com)'
    });

}

//return the innerHTML of the option currently selected on select #dropID
function getDrop(dropID){
    var i, name,
        dropdown = document.getElementById(dropID),
        filterIndex = parseInt(dropdown.value, 10);

    for(i=0; i<dropdown.childNodes.length; i++){
        if(dropdown.childNodes[i].value == filterIndex){
            name = dropdown.childNodes[i].innerHTML;
        }            
    }

    return name;
}

//convert n to hex, and represent it with at least d digits (left 0s for padding) and a '0x' prefix:
function hexString(n, d){
    var result = n.toString(16);

    while(result.length < d){
        result = '0' + result;
    }
    return '0x' + result.toUpperCase();
}

//delete a dom element by ID
function deleteDOM(id){
    var element = document.getElementById(id);
    element.parentNode.removeChild(element);
};

//return the value of a selected option from a <select> element
function selected(selectID){
    var select = document.getElementById(selectID),
        value = select.options[select.selectedIndex].value;

    return value;
}
//trigger css transition on opacity to fade element out, then send it to bottom of stack on completion:
function fadeOut(elementID){
	//set element to come off top of stack once it's faded out:
	document.getElementById(elementID).addEventListener('transitionend', function(){
			if( $('#'+elementID).css('opacity')==0 )
	            $('#'+elementID).css('z-index', 0);    
    });

    //fade the element out:
    $('#'+elementID).css('opacity', 0);
}

function fadeIn(elementID){
	$('#'+elementID).css('z-index', 1);
	$('#'+elementID).css('opacity', 1);
	//window.onDisplay = canvasID;
}

//swap two canvases, for use in subdetector view transitions:
function swapFade(buttonID, object, leaveOff){
	var i;
	//parse which view is requested, and fetch the corresponding canvas ID to bring to the front:
	var inbound = object.view();

	//introduce TAC display buttons as needed (currently only for DANTE):
	if(buttonID == 'DANTElink'){
		document.getElementById('subsystemTAC-Thresholds').style.display = 'inline';
		document.getElementById('subsystemTAC-Rate').style.display = 'inline';
	} else {
		document.getElementById('subsystemTAC-Thresholds').style.display = 'none';
		document.getElementById('subsystemTAC-Rate').style.display = 'none';
		if(window.state.subdetectorView > 2)
			document.getElementById('subsystemRate').onclick();
	}

	//turn off other buttons, except for some at the end:
	for(i=0; i<document.getElementById(object.linkWrapperID).children.length - leaveOff; i++){
		if(document.getElementById(object.linkWrapperID).children[i].type == 'button')
			document.getElementById(object.linkWrapperID).children[i].setAttribute('class', 'navLink');
	}
	//highlight this button:
	if(buttonID != null) document.getElementById(buttonID).setAttribute('class','navLinkDown');

	//make sure the top level nav button navigates back to this config if user leaves & returns:
	document.getElementById(object.topNavID).setAttribute('onclick', "javascript:swapView('"+object.linkWrapperID+"', '"+inbound+"', '"+object.sidebarID+"', '"+object.topNavID+"')");

	if(inbound != window.onDisplay){
		fadeIn(inbound);
		fadeOut(window.onDisplay);
		window.onDisplay = inbound;
	}
}

//swap what values are being presented in the subsystem view:
function swapSubsystemView(buttonID, navWrapperID, viewIndex){
	var i;

	//turn off the other view options:
	for(i=document.getElementById(navWrapperID).children.length - window.subsystemScalars; i<document.getElementById(navWrapperID).children.length; i++){
		if(document.getElementById(navWrapperID).children[i].type == 'button')
			document.getElementById(navWrapperID).children[i].setAttribute('class', 'navLink');
	}
	//highlight this button:
	document.getElementById(buttonID).setAttribute('class','navLinkDown');

	//change the corresponding state variable:
	window.state.subdetectorView = viewIndex;

	//imediately update the display:
	rePaint();
}

//swap top level views
function swapView(inboundNav, inboundCanvas, inboundSidebar, buttonID){

	if(inboundNav != window.navOnDisplay){

		fadeIn(inboundCanvas, 0);
		fadeOut(window.onDisplay, 0);
		window.onDisplay = inboundCanvas;

		fadeIn(inboundNav);
		fadeOut(window.navOnDisplay);
		window.navOnDisplay = inboundNav;

		fadeIn(inboundSidebar);
		fadeOut(window.sidebarOnDisplay);
		window.sidebarOnDisplay = inboundSidebar;

		document.getElementById(window.viewState).setAttribute('class', 'navLink');
		document.getElementById(buttonID).setAttribute('class', 'navLinkDown');		
		window.viewState = buttonID;


	    //move local title around:
	   	var context = document.getElementById(inboundCanvas).getContext('2d');
    	context.font = '24px Raleway'
    	var title = document.getElementById(inboundNav+'Banner').innerHTML;
    	$('#youAreHere').css('width', context.measureText(title).width*1.1);
    	$('#youAreHere').css('left', renderWidth - 50 - context.measureText(title).width);
		document.getElementById('youAreHere').innerHTML = title;

	}
}
