//SHARC////////////////////////////////////////////////////////////
//SHARC assets: x0, y0 = center of shape
//Quad back summary - azimuthal segments, colors sorted azimuthally
quadBack = function(context, x0, y0, innerRad, outerRad, squish, colors, TT){
    
    var angularStep = (2*Math.PI)/colors.length;

    for(i=0; i<colors.length; i++){
        azimuthalSegment(context, x0, y0, innerRad, outerRad, angularStep, Math.PI-(i+1)*angularStep, squish, colors[i], TT);
    }

}

//draws a wedge shaped segment
azimuthalSegment = function(context, x0, y0, innerRad, outerRad, arc, orientation, squish, color, TT){
    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    context.save();
    context.translate(x0, y0);
    context.scale(1,squish);
    context.rotate(-orientation);
    context.beginPath();
    context.arc(0,0,innerRad, 0, -arc, true);
    context.lineTo(outerRad*Math.cos(arc), -outerRad*Math.sin(arc));
    context.arc(0,0,outerRad, -arc, 0, false);
    context.closePath();
    context.fill();
    context.stroke();
    context.restore();
}

//Quad front summary - radial segments.  Colors should be sorted first by array position (ie quadrant), then by smallest to largest radius.
quadFront = function(context, x0, y0, innerRad, outerRad, squish, colors, TT){

    var radStep = (outerRad - innerRad)/4;

    for(i=0; i<colors.length; i++){
        annularSegment(context, x0, y0, innerRad+(i%4)*radStep, innerRad + ((i%4)+1)*radStep, Math.PI/2, Math.PI/2*Math.floor(i/4), squish, colors[i], TT);
    }

}

//draws a macaroni-shaped segment that extends <arc> radians CCW from angle <orientation>
annularSegment = function(context, x0, y0, innerRad, outerRad, arc, orientation, squish, color, TT){
    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    context.save();
    context.translate(x0, y0);
    context.scale(-1,squish);
    context.rotate(-orientation);
    context.beginPath();
    context.arc(0,0,innerRad, 0, -arc, true);
    context.lineTo(outerRad*Math.cos(arc), -outerRad*Math.sin(arc));
    context.arc(0,0,outerRad, -arc, 0, false);
    context.closePath();
    context.fill();
    context.stroke();
    context.restore();

}

//stack of four horizontal parallelograms for summary view; colors stack bottom to top:
horizStack = function(context, X0, Y0, width, height, colors, pitch, TT){
    var i, y0, x0, dX, dY, stripWidth;

    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    //for the pads:
    if(colors.length==1){
        horizPara(context, X0, Y0, width, height, colors[0], pitch, TT);  
        return;
    }

    if(pitch == 'h'){
        //center of first strip:
        y0 = Y0 + 1.5*height/4,
        x0 = X0 - 1.5*height/4*Math.tan(Math.PI/6),
        dX = height/4*Math.tan(Math.PI/6),
        dY = height/4;
        for(i=0; i<4; i++){
            horizPara(context, x0+i*dX, y0-i*dY, width - 0.75*height*Math.tan(Math.PI/6), height/4, colors[i], pitch, TT );
        }
    } else {
        stripWidth = (height-width*Math.tan(Math.PI/6))/4;
        x0 = X0;
        y0 = Y0 + 1.5*stripWidth;
        dY = stripWidth;
        dX = 0;
        for(i=0; i<4; i++){
            horizPara(context, x0+i*dX, y0-i*dY, width, (height-width*Math.tan(Math.PI/6))/4+width*Math.tan(Math.PI/6), colors[i], pitch, TT );
        }
    }



}

//paralellogram with horizontal stripes - pitch = 'h' for top and bottom parallel to x or 'v' for left and right parallel to y
horizPara = function(context, x0, y0, width, height, color, pitch, TT){

    var theta = Math.PI/6,
        yLength, xLength,
        //cx, cy coords of bottom left corner
        cx = x0 - width/2,
        cy = y0 + height/2;

    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.beginPath();
    context.moveTo(cx,cy);
    if(pitch == 'h'){
        yLength = height / Math.cos(theta);
        xLength = width - height*Math.tan(theta);
        context.lineTo(cx + height*Math.tan(theta), cy - height);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+xLength, cy);
    } else{
        xLength = width / Math.cos(theta);
        yLength = height - width*Math.tan(theta);
        context.lineTo(cx, cy-yLength);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+width, cy - (height-yLength) )
    }
    context.closePath();
    context.fill();
    context.stroke();

}

//stack of four vertical parallelograms for summary view; colors stack left to right:
vertStack = function(context, X0, Y0, width, height, colors, pitch, TT){
    var i, y0, x0, dX, dY, stripWidth;

    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    //for the pads:
    if(colors.length==1){
        vertPara(context, X0, Y0, width, height, colors[0], pitch, TT);  
        return;
    }

    if(pitch == 'h'){
        //center of first strip:
        y0 = Y0,
        x0 = X0 - 1.5*(width - height*Math.tan(Math.PI/6))/4,
        dX = (width - height*Math.tan(Math.PI/6))/4,
        dY = 0;
        for(i=0; i<4; i++){
            vertPara(context, x0+i*dX, y0, (width + 3*height*Math.tan(Math.PI/6))/4, height, colors[i], pitch, TT );
        }
    } else {
        stripWidth = width/4/Math.cos(Math.PI/6);
        dY = stripWidth*Math.sin(Math.PI/6);
        dX = width/4;
        x0 = X0 - 1.5*dX;
        y0 = Y0 + 1.5*dY;
        for(i=0; i<4; i++){
            vertPara(context, x0+i*dX, y0-i*dY, width/4, (height-0.75*width*Math.tan(Math.PI/6)), colors[i], pitch, TT );
        }
    }



}

//paralellogram with vertical stripes
vertPara = function(context, x0, y0, width, height, color, pitch, TT){

    var theta = Math.PI/6,
        yLength, xLength,
        //cx, cy coords of bottom left corner
        cx = x0 - width/2,
        cy = y0 + height/2;

    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.beginPath();
    context.moveTo(cx,cy);
    if(pitch == 'h'){
        yLength = height / Math.cos(theta);
        xLength = width - height*Math.tan(theta);
        context.lineTo(cx + height*Math.tan(theta), cy - height);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+xLength, cy);
    } else{
        xLength = width / Math.cos(theta);
        yLength = height - width*Math.tan(theta);
        context.lineTo(cx, cy-yLength);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+width, cy - (height-yLength) )
    }
    context.closePath();
    context.fill();
    context.stroke();

}

radialQuadrant = function(context, x0, y0, innerRad, outerRad, arc, orientation, colors, TT){
    var i,
        segments = colors.length,
        radStep = (outerRad - innerRad) / segments;

    context.save();
    context.translate(x0,y0);
    context.rotate(orientation);

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<segments; i++){
        context.fillStyle = colors[i];
        context.beginPath();
        context.arc(0,0,innerRad + i*radStep, -arc/2, arc/2, false);
        context.arc(0,0,innerRad + (i+1)*radStep, arc/2, -arc/2, true);
        context.closePath();
        context.fill();
        context.stroke();
    }

    context.restore();

}

azimuthalQuadrant = function(context, x0, y0, innerRad, outerRad, arc, orientation, colors, TT){
    var i,
        segments = colors.length,
        angleStep = arc / segments;

    context.save();
    context.translate(x0,y0);
    context.rotate(orientation);

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<segments; i++){
        context.fillStyle = colors[i];
        context.beginPath();
        context.arc(0,0,innerRad, -arc/2 + i*angleStep, -arc/2 + (i+1)*angleStep  , false);
        context.arc(0,0,outerRad, -arc/2 + (i+1)*angleStep, -arc/2 + i*angleStep, true);
        context.closePath();
        context.fill();
        context.stroke();
    }

    context.restore();

}

boxFront = function(context, x0,y0, height, width, colors, TT){
    var i,
        nStrips = colors.length,
        stripWidth = height/nStrips;

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<nStrips; i++){
        context.fillStyle = (colors[i]==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : colors[i];
        context.fillRect(x0, y0+i*stripWidth, width, stripWidth);
        context.strokeRect(x0, y0+i*stripWidth, width, stripWidth);
    }
}

boxBack = function(context, x0,y0, height, width, colors, TT){
    var i,
        nStrips = colors.length,
        stripWidth = width/nStrips;

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<nStrips; i++){
        context.fillStyle = (colors[i]==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : colors[i];
        context.fillRect(x0+i*stripWidth, y0, stripWidth, height);
        context.strokeRect(x0+i*stripWidth, y0, stripWidth, height);
    }
}

padSummaries = function(context, x0, y0, scale, colors, TT){

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';   

    context.fillStyle = colors[0];
    context.fillRect(x0-1.5*scale, y0-scale/2, scale, scale);
    context.strokeRect(x0-1.5*scale, y0-scale/2, scale, scale);

    context.fillStyle = colors[1];
    context.fillRect(x0+0.5*scale, y0-scale/2, scale, scale);
    context.strokeRect(x0+0.5*scale, y0-scale/2, scale, scale);    

}

//draw elliptical arc:
ellipse = function(context, centerX, centerY, horizRadius, startAngle, endAngle){
    context.save();
    context.translate(centerX, centerY);
    context.scale(1, 0.3);
    context.beginPath();
    context.arc(0, 0, horizRadius, 2*Math.PI - startAngle, 2*Math.PI - endAngle);
    context.restore();
    context.closePath();
    context.stroke();
}

//draw spokes from center ellipse to outer ellipse
ellipseSpoke = function(context, centerX, centerY, horizRadiusInner, horizRadiusOuter, phase, nSpokes, spokeNumber){

    //angle between spokes
    var sectionArc = 2*Math.PI / nSpokes;
    //angle of this spoke; recall the internet counts its angles backwards :(
    var phi = 2*Math.PI - (phase + spokeNumber*sectionArc);

    context.save();
    context.translate(centerX, centerY);
    context.scale(1, 0.3);
    //context.beginPath();
    context.moveTo(horizRadiusInner*Math.cos(phi), horizRadiusInner*Math.sin(phi));
    context.lineTo(horizRadiusOuter*Math.cos(phi), horizRadiusOuter*Math.sin(phi));
    context.restore();
    context.stroke();

}

//color in a particular annular section
fillAnnularSection = function(drawOption, context, centerX, centerY, innerRadius, outerRadius, startAngle, endAngle){

    context.save();
    context.translate(centerX, centerY);
    context.scale(1, 0.3);
    context.beginPath();
    context.moveTo(innerRadius*Math.cos(2*Math.PI - startAngle), innerRadius*Math.sin(2*Math.PI - startAngle));
    context.arc(0, 0, innerRadius, 2*Math.PI - startAngle, 2*Math.PI - endAngle, true);
    context.lineTo(outerRadius*Math.cos(2*Math.PI - endAngle), outerRadius*Math.sin(2*Math.PI - endAngle));
    context.arc(0, 0, outerRadius, 2*Math.PI - endAngle, 2*Math.PI - startAngle, false);
    context.closePath();
    context.restore();
    if(drawOption == 'fill' || drawOption == 'both') context.fill();
    if(drawOption == 'stroke' || drawOption == 'both')context.stroke();

}

//DESCANT////////////////////////////////////////////////////////////////////////////////////////

hex = function(context, centerX, centerY, side, phi){

    var i;

    //center to vertex distance:
    var spoke = side / 2 / Math.sin(Math.PI/6);

    //find coords of 6 vertices relative to center:
    var x = [];
    var y = [];

    for(i=0; i<6; i++){
        x[i] = spoke*Math.cos(phi + i*Math.PI/3);
        y[i] = spoke*Math.sin(phi + i*Math.PI/3);

        //alert(x[i]+' '+y[i]);
    }

    //draw hexagon:
    context.save();
    context.translate(centerX, centerY);
    context.beginPath();
    context.moveTo(x[0], y[0]);
    for(i=1; i<7; i++){
        context.lineTo(x[i%6], y[i%6]);
    }
    context.restore();
    context.stroke();

}

whiteDetector = function(context, centerX, centerY, scale, phi, bkg){
    context.strokeStyle = '#999999';//'rgba(255,255,255,1)';
    context.save();
    context.translate(centerX, centerY);
    context.beginPath();
    context.moveTo(scale*41.5, scale*(71.9));
    context.lineTo(scale*(-41.5), scale*(71.9));
    context.lineTo(scale*(-93), 0);
    context.lineTo(scale*(-41.5), scale*(-79.6));
    context.lineTo(scale*41.5, scale*(-79.6));
    context.lineTo(scale*93, 0);
    context.closePath();
    context.restore();
    context.fill();
    if(bkg == 0)context.stroke();
}

redDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999'; //'rgba(255,0,0,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(rotation);
    context.beginPath();
    context.moveTo(scale*37.4, scale*(-87.1));
    context.lineTo(scale*(-51.6), scale*(-83.3));
    context.lineTo(scale*(-101.8), 0);
    context.lineTo(scale*(-51.6), scale*(83.3));
    context.lineTo(scale*37.4, scale*(87.1));
    context.lineTo(scale*73.1, 0);
    context.closePath();
    context.restore();
    context.fill();
    if(bkg == 0)context.stroke();
}

blueDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999';//'rgba(0,150,255,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(rotation);
    context.beginPath();
    context.moveTo(scale*52.6, scale*(-79.4));
    context.lineTo(scale*(-45.1), scale*(-79.4));
    context.lineTo(scale*(-97.6), 0);
    context.lineTo(scale*(-45.1), scale*(79.4));
    context.lineTo(scale*52.6, scale*(79.4));
    context.lineTo(scale*99.2, 0);
    context.closePath();
    context.restore();
    context.fill();
    if(bkg == 0)context.stroke();
}

greenLeftDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999';//'rgba(0,255,0,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(-1*Math.PI/2 + rotation);
    context.beginPath();
    context.moveTo(scale*41.5, scale*(-71.9));
    context.lineTo(scale*(-41.5), scale*(-71.9));
    context.lineTo(scale*(-93), 0);
    context.lineTo(scale*(-41.5), scale*(79.6));
    context.lineTo(scale*41.5, scale*(79.6));
    context.lineTo(scale*62.3, scale*47.6);
    context.closePath();
    context.restore();  
    context.fill();
    if(bkg == 0)context.stroke(); 
}

greenRightDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999';//'rgba(0,255,0,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(Math.PI/2 + rotation);
    context.beginPath();
    context.moveTo(scale*41.5, scale*(-71.9));
    context.lineTo(scale*(-41.5), scale*(-71.9));
    context.lineTo(scale*(-62.3), scale*47.6);
    context.lineTo(scale*(-41.5), scale*(79.6));
    context.lineTo(scale*41.5, scale*(79.6));
    context.lineTo(scale*93, 0);
    context.closePath();
    context.restore();   
    context.fill();
    if(bkg == 0)context.stroke();
}

//Color Scales///////////////////////////////////////////////////////////////////////////////////

//map [0,1] onto [#000000, #FF0000]
redScale = function(scale){
    var R = scale*255;
    return constructHexColor([R,0,0]);
}

//map [0,1] onto [#000000, #0000FF]
blueScale = function(scale){
    var B = scale*255;
    return constructHexColor([0,0,B]);
}

//map [0,1] onto [#000000, #00FF00]
greenScale = function(scale){
    var G = scale*255;
    return constructHexColor([0,G,0]);
}

colorScale = function(colors,scale){
    return constructHexColor([scale*(colors[3]-colors[0])+colors[0], scale*(colors[4]-colors[1])+colors[1], scale*(colors[5]-colors[2])+colors[2]]);
}

//map [0,1] onto various color scales
scalepickr = function(scale, palette){
    //map scale onto [0,360]:
    var H = scale*300 / 60;
    if(H>5) H=5;
    if(H<0) H=0;
    var R, G, B;
    var start0, start1, start2, start3, start4, start5;
    if (palette == 'Sunset'){
        start0 = [0,0,0];
        start1 = [0,0,0x52];
        start2 = [0xE6,0,0x5C];
        start3 = [255,255,0];        
        start4 = [255,0x66,0];
        start5 = [255,0,0];        
    } else if (palette == 'ROOT Rainbow'){
        start0 = [0xFF,0x00,0x00];
        start1 = [0xFF,0xFF,0x00];
        start2 = [0x00,0xFF,0x00];
        start3 = [0x00,0xFF,0xFF];
        start4 = [0x00,0x00,0xFF];
        start5 = [0x66,0x00,0xCC];
        H = -1*(H-5);
    } else if (palette == 'Greyscale'){
        start0 = [0x00,0x00,0x00];
        start1 = [0x22,0x22,0x22];
        start2 = [0x55,0x55,0x55];
        start3 = [0x88,0x88,0x88];        
        start4 = [0xBB,0xBB,0xBB];
        start5 = [0xFF,0xFF,0xFF];
    } else if (palette == 'Red Scale'){
        start0 = [0x00,0x00,0x00];
        start1 = [0x33,0x00,0x00];
        start2 = [0x66,0x00,0x00];
        start3 = [0x99,0x00,0x00];
        start4 = [0xCC,0x00,0x00];
        start5 = [0xFF,0x00,0x00];
    } else if (palette == 'Mayfair'){
        start0 = [0x1E,0x4B,0x0F];
        start1 = [0x0E,0xBE,0x57];
        start2 = [0xE4,0xAB,0x33];
        start3 = [0xEC,0x95,0xF7];
        start4 = [0x86,0x19,0x4A];
        start5 = [0xFF,0x10,0x10];
    } else if (palette == 'Test'){
        start0 = [0x5E,0x1F,0x14];
        start1 = [0x74,0x4D,0x3E];
        start2 = [0x9D,0x47,0x05];
        start3 = [0xDF,0x67,0x19];
        start4 = [0xFE,0x83,0x54];
        start5 = [0x251,0x15,0x29];
    }
    if(H>=0 && H<1){
        R = start0[0] + Math.round(H*(start1[0]-start0[0]));
        G = start0[1] + Math.round(H*(start1[1]-start0[1]));
        B = start0[2] + Math.round(H*(start1[2]-start0[2]));
    } else if(H>=1 && H<2){
        R = start1[0] + Math.round((H-1)*(start2[0]-start1[0]));
        G = start1[1] + Math.round((H-1)*(start2[1]-start1[1]));
        B = start1[2] + Math.round((H-1)*(start2[2]-start1[2]));
    } else if(H>=2 && H<3){
        R = start2[0] + Math.round((H-2)*(start3[0]-start2[0]));
        G = start2[1] + Math.round((H-2)*(start3[1]-start2[1]));
        B = start2[2] + Math.round((H-2)*(start3[2]-start2[2]));
    } else if(H>=3 && H<4){
        R = start3[0] + Math.round((H-3)*(start4[0]-start3[0]));
        G = start3[1] + Math.round((H-3)*(start4[1]-start3[1]));
        B = start3[2] + Math.round((H-3)*(start4[2]-start3[2]));
    } else if(H>=4 && H<=5){
        R = start4[0] + Math.round((H-4)*(start5[0]-start4[0]));
        G = start4[1] + Math.round((H-4)*(start5[1]-start4[1]));
        B = start4[2] + Math.round((H-4)*(start5[2]-start4[2]));  
    }

    return constructHexColor([R,G,B]);

}

//Misc///////////////////////////////////////////////////////////////////////////


function interpolateColor(oldColor, newColor, scale){
    var R, G, B;

    if(oldColor == 0xDEADBEEF || newColor == 0xDEADBEEF) return 0xDEADBEEF;

    R = Math.round((newColor[0] - oldColor[0])*scale + oldColor[0]);
    G = Math.round((newColor[1] - oldColor[1])*scale + oldColor[1]);
    B = Math.round((newColor[2] - oldColor[2])*scale + oldColor[2]);

    return 'rgba('+R+','+G+','+B+',1)';
}

function roundBox(context, leftX, topY, width, height, cornerRadius){
    
    context.moveTo(leftX, topY+cornerRadius);
    context.beginPath();
    context.arc(leftX+cornerRadius, topY+cornerRadius, cornerRadius, Math.PI, 3*Math.PI/2);
    context.lineTo(leftX+width-cornerRadius,topY);
    context.arc(leftX+width-cornerRadius, topY+cornerRadius, cornerRadius, 3*Math.PI/2, 0);
    context.lineTo(leftX+width, topY+height-cornerRadius);
    context.arc(leftX+width-cornerRadius, topY+height-cornerRadius, cornerRadius, 0, Math.PI/2);
    context.lineTo(leftX + cornerRadius, topY+height);
    context.arc(leftX+cornerRadius, topY+height-cornerRadius, cornerRadius, Math.PI/2, Math.PI);
    context.closePath();
}

function strokePolygon(context, nSides, x0, y0, spoke, phi){
    var i;
    context.save();
    context.translate(x0, y0);
    context.rotate(phi);
    context.moveTo(0, -spoke);
    for(i=0; i<nSides; i++){
        context.rotate(2*Math.PI/nSides);
        context.lineTo(0, -spoke);
    }
    context.stroke();
    context.restore();
}

//take a hex color string '#012345' and parse it into [R,G,B]
function parseHexColor(color){
    var R, G, B;

    if(color==0xDEADBEEF) return 0xDEADBEEF
        
    var number = String(color).slice(1,7)

    R = parseInt(number.slice(0,2), 16);
    G = parseInt(number.slice(2,4), 16);
    B = parseInt(number.slice(4,6), 16);

    return [R,G,B];
}

//invert the above function:
function constructHexColor(color){
    var R = Math.round(color[0]);
    var G = Math.round(color[1]);
    var B = Math.round(color[2]);

    R = R.toString(16);
    G = G.toString(16);
    B = B.toString(16);

    if(R.length == 1) R = '0'+R;
    if(G.length == 1) G = '0'+G;
    if(B.length == 1) B = '0'+B;

    return '#'+R+G+B;
}
/*
//draw a nicer sidebar background
function tabBKG(canvasID, side){

    var canvas = document.getElementById(canvasID);
    var context = canvas.getContext('2d');

    var width = $(canvas).width();
    var height = $(canvas).height();
    //console.log(canvasID + ': ' + height)
    var cornerRad = 20;
    var tailRad = 50;
    var lineWeight = 2;

    context.clearRect(0,0,width,height);

    if(side == 'left'){
        context.save()
        context.translate(width,0);
        context.scale(-1,1);   
    }

    context.fillStyle = '#4C4C4C';
    context.lineWidth = lineWeight;
    context.beginPath();
    context.moveTo(width,lineWeight);
    context.lineTo(cornerRad, lineWeight);
    context.arc(cornerRad+lineWeight, cornerRad+lineWeight, cornerRad, -Math.PI/2, -Math.PI, true);
    context.lineTo(lineWeight, height - cornerRad - tailRad);
    context.arc(cornerRad+lineWeight, height - tailRad - cornerRad, cornerRad, -Math.PI, Math.PI/2, true);
    context.lineTo(width - tailRad, height - tailRad);
    context.arc(width - tailRad, height, tailRad, -Math.PI/2, 0);
    context.closePath();
    context.fill();
    context.stroke();

    if(side== 'left'){
        context.restore();
    }

}
*/
//atom spinner:
function drawSpinner(canvasID, label){
    
    var canvas = document.getElementById(canvasID);
    var context = canvas.getContext('2d');
    var string = (label) ? label : 'LOADING';

        $('#spinner').css('left', window.innerWidth/2 - 100);
        $('#spinner').css('top', window.innerHeight/2 - 100);

    context.lineWidth = 5;
    context.strokeStyle = '#FFFFFF';
    context.fillStyle = 'rgba(0,0,0,0.7)';
    roundBox(context, 5, 5, 190, 190, 5);
    context.lineWidth = 1;
    context.fill();
    context.stroke();

    context.fillStyle = '#FFFFFF';
    context.font = '16px Arial'
    context.fillText(string, 100-context.measureText(string).width/2, 145);
    window.nProtons = 0;
    window.nNucleons = 0;

/*
    window.spinLoop = setInterval(function(){
        context = document.getElementById('spinner').getContext('2d');

        //choose proton or neutron:
        var nucleon = (Math.random() < 0.5) ? 'p' : 'n';
        window.nNucleons++;
        if(nucleon == 'p') window.nProtons++;
        //choose position on canvas
        var radius = Math.random()*15;
        var phi = Math.random()*Math.PI*2;

        //draw:
        context.strokeStyle = '#FFFFFF';
        context.fillStyle = (nucleon == 'p') ? '#FF0000' : '#0000FF';
        context.beginPath();
        context.arc(100+radius*Math.cos(phi), 100+radius*Math.sin(phi), 5, 0, Math.PI*2);
        context.closePath();
        context.fill();
        context.stroke();

        context.clearRect(20,20, 160, 55);
        context.fillStyle = 'rgba(0,0,0,0.7)'
        context.fillRect(20,20, 160, 55);
        context.fillStyle = '#FFFFFF';
        context.fillText('Z = '+window.nProtons, 70-context.measureText('Z = '+window.nProtons).width/2, 70);
        context.fillText('A = '+window.nNucleons, 130-context.measureText('N = '+window.nProtons).width/2, 70);

    }, 3);
*/    
}

function curveText(text, context, x0, y0, rad, startAngle){
    var textWidth = context.measureText(text).width,
        charRotation = startAngle,
        character, charWidth, nextChar, nextWidth, bothWidth, kern, extraRotation, charSegment;

    for (var i=0, l=text.length; i<l; i++) {
        character = nextChar || text[i];
        charWidth = nextWidth || context.measureText(character).width;

        // Rotate so the letter base makes a circle segment instead of a tangent
        extraRotation = (Math.PI/2) - Math.acos((charWidth/2) / rad);

        context.save();
        context.translate(x0, y0);
        context.rotate(charRotation);
        context.translate(0, -rad);
        context.rotate(extraRotation);
        context.fillText(character,0,0);
        context.restore();

        nextChar = text[i+1] || '';
        nextWidth = context.measureText(nextChar).width;

        bothWidth = context.measureText(character+nextChar).width;
        kern = bothWidth - charWidth - nextWidth;

        charSegment = (charWidth+kern) / textWidth; // percent of total text size this takes up
        charRotation += charSegment * (context.measureText(text).width/rad);
    }           
}

function arrow(context, x0, y0, x1, y1, headScale){
    context.beginPath();
    context.moveTo(x0,y0);
    context.lineTo(x1,y1);

    context.save();
    context.translate(x1, y1);
    context.rotate(Math.atan((x1-x0)/(y1-y0)));
    context.moveTo(-headScale, headScale);
    context.lineTo(0,0);
    context.lineTo(headScale, headScale);
    context.restore();
}

function closeX(context, x0, y0, radius){
    context.strokeStyle = '#FFFFFF';
    context.fillStyle = '#FF0000';
    context.lineWidth = 1;

    context.beginPath();
    context.arc(x0, y0, radius, 0, Math.PI*2, true);
    context.closePath();
    context.fill();
    context.stroke();

    context.beginPath();
    context.lineWidth = 1;
    context.moveTo(x0 - 0.4*radius, y0 - 0.4*radius);
    context.lineTo(x0 + 0.4*radius, y0 + 0.4*radius);
    context.stroke();
    
    context.moveTo(x0 + 0.4*radius, y0 - 0.4*radius);
    context.lineTo(x0 - 0.4*radius, y0 + 0.4*radius);
    context.stroke();
}

//draws a digit like on an old digital clock.  cells is an array describing which cells
//are lit, indexed 0-5 around the edge starting on top, and 6 for the middle bar.
function digitalDigit(cells, context, height, x0, y0){

    var cellWidth = 0.05*height,
        width = 0.5*height,
        cellHeight = 0.5*height;

    context.save();
    context.setTransform(1, -Math.tan(Math.PI/12), 0, 1, 0, 0);
    context.rotate(Math.tan(Math.PI/12));

    if(cells[0]){
        context.beginPath();
        context.moveTo(x0+cellWidth, y0);
        context.lineTo(x0+cellWidth+width, y0);
        context.lineTo(x0+width, y0+cellWidth);
        context.lineTo(x0+2*cellWidth, y0+cellWidth);
        context.closePath();
        context.fill();
    }

    if(cells[1]){
        context.beginPath();
        context.moveTo(x0+width+2*cellWidth, y0+cellWidth);
        context.lineTo(x0+width+2*cellWidth, y0+cellWidth+cellHeight);
        context.lineTo(x0+width+cellWidth, y0+cellHeight);
        context.lineTo(x0+width+cellWidth, y0+2*cellWidth);
        context.closePath();
        context.fill();
    }

    if(cells[2]){
        context.beginPath();
        context.moveTo(x0+width+2*cellWidth, y0+3*cellWidth+cellHeight);
        context.lineTo(x0+width+2*cellWidth, y0+3*cellWidth+2*cellHeight);
        context.lineTo(x0+width+cellWidth, y0+2*cellWidth+2*cellHeight);
        context.lineTo(x0+width+cellWidth, y0+4*cellWidth+cellHeight);     
        context.closePath();
        context.fill();   
    }

    if(cells[3]){
        context.beginPath();
        context.moveTo(x0+cellWidth+width, y0+4*cellWidth+2*cellHeight);
        context.lineTo(x0+cellWidth, y0+4*cellWidth+2*cellHeight);
        context.lineTo(x0+2*cellWidth, y0+3*cellWidth+2*cellHeight);
        context.lineTo(x0+width, y0+3*cellWidth+2*cellHeight);
        context.closePath();
        context.fill();
    }

    if(cells[4]){
        context.beginPath();
        context.moveTo(x0, y0+3*cellWidth+cellHeight);
        context.lineTo(x0, y0+3*cellWidth+2*cellHeight);
        context.lineTo(x0+cellWidth, y0+2*cellWidth+2*cellHeight);
        context.lineTo(x0+cellWidth, y0+4*cellWidth+cellHeight);
        context.closePath();
        context.fill();
    }

    if(cells[5]){
        context.beginPath();
        context.moveTo(x0, y0+cellWidth+cellHeight);
        context.lineTo(x0, y0+cellWidth);
        context.lineTo(x0+cellWidth, y0+2*cellWidth);
        context.lineTo(x0+cellWidth, y0+cellHeight);
        context.closePath();
        context.fill();
    }

    if(cells[6]){
        context.beginPath();
        context.moveTo(x0+cellWidth, y0+2*cellWidth+cellHeight);
        context.lineTo(x0+2*cellWidth, y0+1.5*cellWidth+cellHeight);
        context.lineTo(x0+width, y0+1.5*cellWidth+cellHeight);
        context.lineTo(x0+width+cellWidth, y0+2*cellWidth+cellHeight);
        context.lineTo(x0+width, y0+2.5*cellWidth+cellHeight);
        context.lineTo(x0+2*cellWidth, y0+2.5*cellWidth+cellHeight);
        context.closePath();
        context.fill();
    }

    context.restore();

}

//draw a flow-chart like branch
//    |         x0, y0
//    ---       
//      |       
//  ----------  x1, y1
//  |  |  |  |  combLength
//context == context to draw in
//combColors == array containing color of each comb end; length = number of comb tines (4 in ascii art above)
//combWidth == width of base of comb in px
//combLength length of tines
//branchColor == color of 3 branch segments and comb spine
//x0, y0 == coordinates of branch root
//x1, y1 == coordinates of branch / comb join
function drawBranch(context, combColors, combWidth, combLength, branchColor, x0, y0, x1, y1){

    var nTine = combColors.length,
        tineSpacing = combWidth / (nTine-1),
        branchHeight = y1-y0;
        branchWidth = x1-x0;
        i;

    //draw branch and spine of comb:
    context.strokeStyle = branchColor;
    context.beginPath();
    context.moveTo(x0, y0);
    context.lineTo(x0, y0 + branchHeight/2);
    context.lineTo(x0 + branchWidth, y0 + branchHeight/2);
    context.lineTo(x0 + branchWidth, y0 + branchHeight);
    context.moveTo(x0 + branchWidth - combWidth / 2 - parseFloat(context.lineWidth)/2, y0 + branchHeight);
    context.lineTo(x0 + branchWidth + combWidth / 2 + parseFloat(context.lineWidth)/2, y0 + branchHeight);
    context.stroke();

    //draw tines
    for(i=0; i<nTine; i++){
        context.strokeStyle = combColors[i];
        context.beginPath();
        context.moveTo(x0 + branchWidth - combWidth / 2 + i*tineSpacing, y0 + branchHeight + parseFloat(context.lineWidth)/2);
        context.lineTo(x0 + branchWidth - combWidth / 2 + i*tineSpacing, y0 + branchHeight + combLength);
        context.stroke();
    }
}
function main(){
	//introduce choose experiment modal:
	document.getElementById('chooseExperiment').active = true;

	////////////////////////////////////////////
	//paint all canvases
	////////////////////////////////////////////
	//GRIFFIN
	//Upstream Chamber
	thumbnail('GRIFusSCEPTAR', 'SCEPTAR', 'none', '#FFFFFF');
	thumbnail('GRIFusPACES', 'PACES', 'none', '#FFFFFF');
	thumbnail('GRIFusSPICE', 'SPICE', 'none', '#FFFFFF');

	//Downstream Chamber
	thumbnail('GRIFdsSCEPTAR', 'SCEPTAR', 'none', '#FFFFFF');
	thumbnail('GRIFdsZDS', 'ZDS', 'none', '#FFFFFF');
	thumbnail('GRIFdsS3', 'S3', 'none', '#FFFFFF');

	//Corona
	thumbnail('GRIFc', 'GRIFFIN', 'DANTE', '#FFFFFF');

	//Upstream Lampshade
	thumbnail('GRIFuslAlone', 'GRIFFIN', 'none', '#FFFFFF');
	thumbnail('GRIFspiceService', 'SPICE', 'services', '#FFFFFF');

	//Downstream Lampshade
	thumbnail('GRIFdslAlone', 'GRIFFIN', 'none', '#FFFFFF');
	thumbnail('GRIFdescant', 'DESCANT', 'none', '#FFFFFF');

	//there's only one choice in GRIFFIN's corona - choose it and lock it by default:
	document.getElementById('GRIFcorona').selected = 'GRIFc0';
	document.getElementById('GRIFcorona').locked = true;

	//TIGRESS
	//Chamber
	thumbnail('TIGusBAMBINO', 'BAMBINO', 'none', '#FFFFFF');
	thumbnail('TIGusSHARC', 'SHARC', 'none', '#FFFFFF'); //need elipses
	thumbnail('TIGusSPICE', 'SPICE', 'none', '#FFFFFF');
	thumbnail('TIGusTIPwall', 'TIPwall', 'none', '#FFFFFF');
	thumbnail('TIGusTIPball', 'TIPball', 'none', '#FFFFFF');

	//there's only one choice in TIGRESS' corona - choose it and lock it by default:
	document.getElementById('TIGcorona').selected = 'TIGc0';
	document.getElementById('TIGcorona').locked = true;

	//Corona
	thumbnail('TIGc', 'TIGRESS', 'none', '#FFFFFF');		

	//Upstream Lampshade
	thumbnail('TIGuslAlone', 'TIGRESS', 'none', '#FFFFFF');
	thumbnail('TIGspiceService', 'SPICE', 'services', '#FFFFFF');

	//Downstream Lampshade
	thumbnail('TIGdslAlone', 'TIGRESS', 'none', '#FFFFFF');
	thumbnail('TIGdescant', 'DESCANT', 'none', '#FFFFFF');
	thumbnail('TIGsharcService', 'SHARC', 'services', '#FFFFFF');	

	/////////////////////////////////////////////////////////////////////////////
	//callbacks - some options influence other options
	/////////////////////////////////////////////////////////////////////////////

	//////////////////////////////
	//GRIFFIN Callbacks
	//////////////////////////////

	//Upstream Chamber
	//SCEPTAR
	document.getElementById('GRIFusc0').setCallback = function(){
		//choosing !SPICE requires !SPICE services, and locks the USL:
		if(!document.getElementById('GRIFusLamp').selected){
			document.getElementById('GRIFusLamp').selected = 'GRIFusl0';
		}
		document.getElementById('GRIFusLamp').locked = true;
	};

	document.getElementById('GRIFusc0').unsetCallback = function(){
		//unchoosing !SPICE unchooses !SPICE Services and unlocks the USL
		if(document.getElementById('GRIFusLamp').selected){
			document.getElementById('GRIFusLamp').locked = false;
			document.getElementById('GRIFusLamp').selected = 'GRIFusl0';
		}
	};

	//PACES
	document.getElementById('GRIFusc1').setCallback = function(){
		//choosing !SPICE chooses and locks GRIFFIN standalone in the USL:
		if(!document.getElementById('GRIFusLamp').selected){
			document.getElementById('GRIFusLamp').selected = 'GRIFusl0';
		}
		document.getElementById('GRIFusLamp').locked = true;
	};

	document.getElementById('GRIFusc1').unsetCallback = function(){
		//unchoosing !SPICE allows either choice for USL:
		if(document.getElementById('GRIFusLamp').selected){
			document.getElementById('GRIFusLamp').locked = false;
			document.getElementById('GRIFusLamp').selected = 'GRIFusl0';
		}
	};

	//SPICE
	document.getElementById('GRIFusc2').setCallback = function(){
		//choosing SPICE requires the SPICE Services
		if(!document.getElementById('GRIFusLamp').selected){
			document.getElementById('GRIFusLamp').selected = 'GRIFusl1';
		}
	};

	document.getElementById('GRIFusc2').unsetCallback = function(){
		//unchoosing SPICE unchooses SPICE Services:
		if(document.getElementById('GRIFusLamp').selected){
			document.getElementById('GRIFusLamp').selected = 'GRIFusl1';
		}
	};

	//Upstream Lampshade
	//GRIFFIN Standalone
	document.getElementById('GRIFusl0').setCallback = function(){
		//choosing GRIFFIN Standalone in the USL removes SPICE as an option in the USC:
		document.getElementById('GRIFusc2').className = 'hidden';
	};

	document.getElementById('GRIFusl0').unsetCallback = function(){
		//unchoosing GRIFFIN Standalone in the USL re-revals SPICE as an option in the USC, if USC not already chosen:
		if(!document.getElementById('GRIFusChamber').selected)
			document.getElementById('GRIFusc2').className = '';
	};

	//SPICE Services
	document.getElementById('GRIFusl1').setCallback = function(){
		//choosing SPICE Services requires SPICE
		if(!document.getElementById('GRIFusChamber').selected){
			document.getElementById('GRIFusChamber').selected = 'GRIFusc2';
		}
	};

	document.getElementById('GRIFusl1').unsetCallback = function(){
		//unchoosing SPICE Services unchooses SPICE:
		if(document.getElementById('GRIFusChamber').selected)
			document.getElementById('GRIFusChamber').selected = 'GRIFusc2';
	};

	///////////////////////////////////////////
	//TIGRESS Callbacks
	///////////////////////////////////////////

	//Chamber
	//BAMBINO
	document.getElementById('TIGusc0').setCallback = function(){
		//!SPICE -> choose TIGRESS in USL:
		if(!document.getElementById('TIGusLamp').selected){
			document.getElementById('TIGusLamp').selected = 'TIGusl0';
		}
		document.getElementById('TIGusLamp').locked = true;
		//!SHARC -> hide SHARC services option 
		document.getElementById('TIGdsl2').className = 'hidden';
	};

	document.getElementById('TIGusc0').unsetCallback = function(){
		//unlock and unset the USL to allow SPICE option
		if(document.getElementById('TIGusLamp').selected){
			document.getElementById('TIGusLamp').locked = false;
			document.getElementById('TIGusLamp').selected = 'TIGusl0';
		}
		//if the DSL is unchosen, allow the SHARC services option...
		if(!document.getElementById('TIGdsLamp').selected){
			document.getElementById('TIGdsl2').className = '';
		//...or if the DSL is chose, unchoose it so SHARC can be a Chamber option again:
		} else{
			document.getElementById('TIGdsLamp').selected = document.getElementById('TIGdsLamp').selected;
		}
	};

	//SHARC
	document.getElementById('TIGusc1').setCallback = function(){
		//SHARC -> must choose SHARC services in DSL:
		if(!document.getElementById('TIGdsLamp').selected){
			document.getElementById('TIGdsLamp').selected = 'TIGdsl2';
		}
		//SHARC -> !SPICE -> TIGRESS in USL:
		if(!document.getElementById('TIGusLamp').selected){
			document.getElementById('TIGusLamp').selected = 'TIGusl0';
			document.getElementById('TIGusLamp').locked = true;
		}
	};

	document.getElementById('TIGusc1').unsetCallback = function(){
		//unsetting SHARC unsets DSL:
		if(document.getElementById('TIGdsLamp').selected){
			document.getElementById('TIGdsLamp').locked = false;
			document.getElementById('TIGdsLamp').selected = 'TIGdsl2';
		}
		//unsetting SHARC also unsets USL, so SPICE can be a Chamber option again:
		if(document.getElementById('TIGusLamp').selected){
			document.getElementById('TIGusLamp').locked = false;
			document.getElementById('TIGusLamp').selected = 'TIGusl0';
		}
	};

	//SPICE
	document.getElementById('TIGusc2').setCallback = function(){
		//SPICE -> SPICE services
		if(!document.getElementById('TIGusLamp').selected){
			document.getElementById('TIGusLamp').selected = 'TIGusl1';
		}
		//SPICE -> !SHARC -> no SHARC services in DSL:
		document.getElementById('TIGdsl2').className = 'hidden';
	};

	document.getElementById('TIGusc2').unsetCallback = function(){
		//unset the USL:
		if(document.getElementById('TIGusLamp').selected){
			document.getElementById('TIGusLamp').selected = 'TIGusl1';
		}
		//If no selection made in the DSL, allow SHARC services as an option.
		if(!document.getElementById('TIGdsLamp').selected)
			document.getElementById('TIGdsl2').className = '';
	};

	//TIP Wall
	document.getElementById('TIGusc3').setCallback = function(){
		//!SPICE -> TIGRESS in the USL:
		if(!document.getElementById('TIGusLamp').selected){
			document.getElementById('TIGusLamp').selected = 'TIGusl0';
		}
		document.getElementById('TIGusLamp').locked = true;
		//!SHARC -> !SHARC services in the DSL:
		document.getElementById('TIGdsl2').className = 'hidden';
		
	};

	document.getElementById('TIGusc3').unsetCallback = function(){
		//unlock and unset USL to allow SPICE as Chamber option:
		if(document.getElementById('TIGusLamp').selected){
			document.getElementById('TIGusLamp').locked = false;
			document.getElementById('TIGusLamp').selected = 'TIGusl0';
		}
		//if DSL is unchosen, allow SHARC services so SHARC can be a Chamber option:
		if(!document.getElementById('TIGdsLamp').selected){
			document.getElementById('TIGdsl2').className = '';
		//if DSL is chosen, unchoose it to allow all Chamber options.
		} else{
			document.getElementById('TIGdsLamp').selected = document.getElementById('TIGdsLamp').selected;
		}
	};

	//TIP Ball
	document.getElementById('TIGusc4').setCallback = function(){
		//!SPICE -> TIGRESS in the USL:
		if(!document.getElementById('TIGusLamp').selected){
			document.getElementById('TIGusLamp').selected = 'TIGusl0';
		}
		document.getElementById('TIGusLamp').locked = true;
		//!SHARC -> !SHARC services in the DSL:
		document.getElementById('TIGdsl2').className = 'hidden';
	};

	document.getElementById('TIGusc4').unsetCallback = function(){
		//unlock and unset USL to allow SPICE as Chamber option:
		if(document.getElementById('TIGusLamp').selected){
			document.getElementById('TIGusLamp').locked = false;
			document.getElementById('TIGusLamp').selected = 'TIGusl0';
		}
		//if DSL is unchosen, allow SHARC services so SHARC can be a Chamber option:
		if(!document.getElementById('TIGdsLamp').selected){
			document.getElementById('TIGdsl2').className = '';
		//if DSL is chosen, unchoose it to allow all Chamber options.
		} else{
			document.getElementById('TIGdsLamp').selected = document.getElementById('TIGdsLamp').selected;
		}
	};

	//Upstream Lampshade
	//TIGRESS Standalone:
	document.getElementById('TIGusl0').setCallback = function(){
		//choosing !SPICE services removes SPICE as a chamber option:
		document.getElementById('TIGusc2').className = 'hidden';
	};

	document.getElementById('TIGusl0').unsetCallback = function(){
		//unsetting TIGRESS standalone releases SPICE as a chamber option, if the chamber isn't already set:
		if(!document.getElementById('TIGusChamber').selected){
			document.getElementById('TIGusc2').className = '';
		}
	};

	//SPICE Services
	document.getElementById('TIGusl1').setCallback = function(){
		//choosing SPICE services chooses SPICE in the chamber
		if(!document.getElementById('TIGusChamber').selected){
			document.getElementById('TIGusChamber').selected = 'TIGusc2';
		}
	};

	document.getElementById('TIGusl1').unsetCallback = function(){
		//unchoosing SPICE Services unchooses SPICE:
		if(document.getElementById('TIGusChamber').selected)
			document.getElementById('TIGusChamber').selected = 'TIGusc2';
	};

	//Downstream Lampshade
	//TIGRESS
	document.getElementById('TIGdsl0').setCallback = function(){
		//Choosing !SHARC Services removes SHARC as a chamber option
		document.getElementById('TIGusc1').className = 'hidden';
	}

	document.getElementById('TIGdsl0').unsetCallback = function(){
		//if the chamber is selected to anything but SHARC, don't re-reveal SHARC services when unsetting TIGRESS in DSL:
		if(document.getElementById('TIGusChamber').selected != 'TIGusc1' && document.getElementById('TIGusChamber').selected){
			document.getElementById('TIGdsl2').className = 'hidden';
		//if the chamber isn't set yet, make sure SHARC is revealed as an option
		} else if(!document.getElementById('TIGusChamber').selected){
			document.getElementById('TIGusc1').className = '';
		}
	};

	//DESCANT
	//choosing !SHARC services removes SHARC option in chamber:
	document.getElementById('TIGdsl1').setCallback = function(){
		document.getElementById('TIGusc1').className = 'hidden';
	}

	document.getElementById('TIGdsl1').unsetCallback = function(){
		//if the chamber is selected to anything but SHARC, don't re-reveal SHARC services when unsetting TIGRESS in DSL:
		if(document.getElementById('TIGusChamber').selected != 'TIGusc1' && document.getElementById('TIGusChamber').selected){
			document.getElementById('TIGdsl2').className = 'hidden';
		//if the chamber isn't set yet, make sure SHARC is revealed as an option
		} else if(!document.getElementById('TIGusChamber').selected){
			document.getElementById('TIGusc1').className = '';
		}
	};

	//SHARC
	document.getElementById('TIGdsl2').setCallback = function(){
		//choosing SHARC Services chooses SHARC in the chamber
		if(!document.getElementById('TIGusChamber').selected){
			document.getElementById('TIGusChamber').selected = 'TIGusc1';
		}
	};

	document.getElementById('TIGdsl2').unsetCallback = function(){
		//unchoosing SHARC services unchooses SHARC in the chamber
		if(document.getElementById('TIGusChamber').selected)
			document.getElementById('TIGusChamber').selected = 'TIGusc1';
	};

}





function buildExperiment(){
	var BAMBINO, DANTE, DESCANT, PACES, usSCEPTAR, dsSCEPTAR, SHARC, SPICE, TIPball, TIPwall, ZDS;

	//abandon ship if something hasn't been set:
	if(	(document.getElementById('GRIFFINwrap') &&
		(!document.getElementById('GRIFusChamber').selected ||
		!document.getElementById('GRIFdsChamber').selected ||
		!document.getElementById('GRIFusLamp').selected ||
		!document.getElementById('GRIFdsLamp').selected)) ||
		(document.getElementById('TIGRESSwrap') &&
		(!document.getElementById('TIGusChamber').selected ||
		!document.getElementById('TIGusLamp').selected ||
		!document.getElementById('TIGdsLamp').selected))
	){
			document.getElementById('incompleteForm').className = 'activeModal';
			return;
	}

	//determine which subdetectors have been requested:
	BAMBINO = document.getElementById('TIGusChamber') && document.getElementById('TIGusChamber').selected == 'TIGusc0';
	DANTE = document.getElementById('GRIFcorona');
	DESCANT = (document.getElementById('TIGdsLamp') && document.getElementById('TIGdsLamp').selected == 'TIGdsl1') || 
		(document.getElementById('GRIFdsLamp') && document.getElementById('GRIFdsLamp').selected == 'GRIFdsl1');
	PACES = document.getElementById('GRIFusChamber') && document.getElementById('GRIFusChamber').selected == 'GRIFusc1';
	usSCEPTAR = document.getElementById('GRIFusChamber') && document.getElementById('GRIFusChamber').selected == 'GRIFusc0';
	dsSCEPTAR = document.getElementById('GRIFdsChamber') && document.getElementById('GRIFdsChamber').selected == 'GRIFdsc0';
	SHARC = document.getElementById('TIGusChamber') && document.getElementById('TIGusChamber').selected == 'TIGusc1';
	SPICE = (document.getElementById('TIGusChamber') && document.getElementById('TIGusChamber').selected == 'TIGusc2') ||
			(document.getElementById('GRIFusChamber') && document.getElementById('GRIFusChamber').selected == 'GRIFusc2')
	TIPball = document.getElementById('TIGusChamber') && document.getElementById('TIGusChamber').selected == 'TIGusc4';
	TIPwall = document.getElementById('TIGusChamber') && document.getElementById('TIGusChamber').selected == 'TIGusc3';
	ZDS = document.getElementById('GRIFdsChamber') && document.getElementById('GRIFdsChamber').selected == 'GRIFdsc1';

	//create ODB structure//////////////////////////////////////////////////////////////
	//re-declare root dashboard directory:
	ODBMDelete(['/DashboardConfig']);
	ODBMCreate(['/DashboardConfig'], [TID_KEY]);

	//top level ODB data
	address = [	'/DashboardConfig/topLevel', 
				'/DashboardConfig/topLevel/HPGeArray', 
				'/DashboardConfig/topLevel/statusURL', 
				'/DashboardConfig/topLevel/expName', 
				'/DashboardConfig/topLevel/Experiment'
			];
	type = [TID_KEY, TID_STRING, TID_STRING, TID_STRING, TID_STRING];
	ODBMCreate(address, type);
	ODBSet('/DashboardConfig/topLevel/HPGeArray', window.experiment);

	//Main dashboard registry
	address = [	'/DashboardConfig/Dashboard', 
				'/DashboardConfig/Dashboard/dashboardMin', 
				'/DashboardConfig/Dashboard/dashboardMax'
			];
	type = [TID_KEY, TID_INT, TID_INT];
	ODBMCreate(address, type);
	ODBSet('/DashboardConfig/Dashboard/dashboardMax', 1000000);

	//alarm registry
	address = [	'/DashboardConfig/CustomAlarms', 
				'/DashboardConfig/CustomAlarms/Voltage', 
				'/DashboardConfig/CustomAlarms/Current', 
				'/DashboardConfig/CustomAlarms/Temperature', 
				'/DashboardConfig/CustomAlarms/Clock'
			];
	type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT];
	ODBMCreate(address, type);

	//cycles
	address = [	'/DashboardConfig/Cycles', 
				'/DashboardConfig/Cycles/Static Source',
				'/DashboardConfig/Cycles/Static Source/Code',
				'/DashboardConfig/Cycles/Static Source/Duration',
				'/DashboardConfig/Cycles/Standard Cycle',
				'/DashboardConfig/Cycles/Standard Cycle/Code',
				'/DashboardConfig/Cycles/Standard Cycle/Duration',									
				'/DashboardConfig/Cycles/Active Name',
				'/DashboardConfig/Cycles/Active Pattern',
				'/DashboardConfig/Cycles/Active Duration'
			];
	type = [TID_KEY, TID_KEY, TID_INT, TID_INT, TID_KEY, TID_INT, TID_INT, TID_STRING, TID_INT, TID_INT];
	arrayLengths = [1, 1, 2, 2, 1, 5, 5, 1, 2, 2];
	ODBMCreate(address, type, arrayLengths);
	ODBSet('/DashboardConfig/Cycles/Static Source/Code[*]', [0x300030, 0x1F811F81]);
	ODBSet('/DashboardConfig/Cycles/Static Source/Duration[*]', [100, 0]);
	ODBSet('/DashboardConfig/Cycles/Standard Cycle/Code[*]', [0x300030, 0x400040, 0x1F801F80, 0x1F811F81, 0x1F801F80]);
	ODBSet('/DashboardConfig/Cycles/Standard Cycle/Duration[*]', [100, 500, 1000, 15000, 5000]);
	ODBSet('/DashboardConfig/Cycles/Active Name', 'Static Source'); //defaults to static source on load
	ODBSet('/DashboardConfig/Cycles/Active Pattern[*]', [0x300030, 0x1F811F81]);
	ODBSet('/DashboardConfig/Cycles/Active Duration[*]', [100, 0]);

	//filters
	ODBMCreate(['/DashboardConfig/Filters', '/DashboardConfig/Filters/HPGe Singles'], [TID_KEY, TID_KEY]);
	ODBMCreate(['/DashboardConfig/Filters/Active Name', '/DashboardConfig/Filters/group0', '/DashboardConfig/Filters/HPGe Singles/group0'], [TID_STRING, TID_STRING, TID_STRING], [1,1,1], [32, 32, 32]);
	ODBSet('/DashboardConfig/Filters/Active Name[*]', 'HPGe Singles');
	ODBSet('/DashboardConfig/Filters/group0[*]', 'GRG-S-1');
	ODBSet('/DashboardConfig/Filters/HPGe Singles/group0[*]', 'GRG-S-1');

	//HV
	address = [	'/DashboardConfig/HV', 
				'/DashboardConfig/HV/voltageTolerance', 
				'/DashboardConfig/HV/currentTolerance', 
				'/DashboardConfig/HV/tempTolerance', 
				'/DashboardConfig/HV/demandVoltage', 
				'/DashboardConfig/HV/voltRampSpeed'
			];
	type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT];
	ODBMCreate(address, type);

	//DAQ
	address = [	'/DashboardConfig/DAQ',
				'/DashboardConfig/DAQ/config',
				'/DashboardConfig/DAQ/rateMinTopView', 
				'/DashboardConfig/DAQ/rateMaxTopView', 
				'/DashboardConfig/DAQ/rateMinDetailView', 
				'/DashboardConfig/DAQ/rateMaxDetailView', 
				'/DashboardConfig/DAQ/transferMinTopView', 
				'/DashboardConfig/DAQ/transferMaxTopView', 
				'/DashboardConfig/DAQ/transferMinDetailView', 
				'/DashboardConfig/DAQ/transferMaxDetailView', 
				'/DashboardConfig/DAQ/rateMinMaster', 
				'/DashboardConfig/DAQ/rateMaxMaster', 
				'/DashboardConfig/DAQ/transferMinMaster', 
				'/DashboardConfig/DAQ/transferMaxMaster'
			];
	type = [TID_KEY, TID_STRING, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT];
	ODBMCreate(address, type);
	ODBSet('/DashboardConfig/DAQ/config', window.experiment);
	ODBSet('/DashboardConfig/DAQ/rateMaxTopView', 10000);
	ODBSet('/DashboardConfig/DAQ/rateMaxDetailView', 10000);
	ODBSet('/DashboardConfig/DAQ/transferMaxTopView', 10000);
	ODBSet('/DashboardConfig/DAQ/transferMaxDetailView', 10000);
	ODBSet('/DashboardConfig/DAQ/rateMaxMaster', 10000);
	ODBSet('/DashboardConfig/DAQ/transferMaxMaster', 10000);

	//BAMBINO
	if(BAMBINO){
		address = [	'/DashboardConfig/BAMBINO', 
					'/DashboardConfig/BAMBINO/deploy', 
					'/DashboardConfig/BAMBINO/HVscale', 
					'/DashboardConfig/BAMBINO/thresholdScale', 
					'/DashboardConfig/BAMBINO/rateScale', 
					'/DashboardConfig/BAMBINO/mode', 
					'/DashboardConfig/BAMBINO/layers', 
					'/DashboardConfig/BAMBINO/USdeploy', 
					'/DashboardConfig/BAMBINO/DSdeploy'
				];
		type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT, TID_STRING, TID_INT, TID_INT, TID_INT];
		ODBMCreate(address, type);

		ODBSet('/DashboardConfig/BAMBINO/deploy', 1);
	}

	//DANTE
	if(DANTE){
		address = [ '/DashboardConfig/DANTE',
					'/DashboardConfig/DANTE/deploy',
					'/DashboardConfig/DANTE/BGOHVscale',
					'/DashboardConfig/DANTE/BGOthresholdScale',
					'/DashboardConfig/DANTE/BGOrateScale',
					'/DashboardConfig/DANTE/LaBrPMTHVscale',
					'/DashboardConfig/DANTE/LaBrPMTthresholdScale',
					'/DashboardConfig/DANTE/LaBrPMTrateScale',
					'/DashboardConfig/DANTE/LaBrTACHVscale',
					'/DashboardConfig/DANTE/LaBrTACthresholdScale',
					'/DashboardConfig/DANTE/LaBrTACrateScale'										
				];
		type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT];
		ODBMCreate(address, type);

		ODBSet('/DashboardConfig/DANTE/deploy', 1);
	}

	//DESCANT
	if(DESCANT){
		address = [	'/DashboardConfig/DESCANT',
					'/DashboardConfig/DESCANT/deploy',
					'/DashboardConfig/DESCANT/HVscale',
					'/DashboardConfig/DESCANT/thresholdScale',
					'/DashboardConfig/DESCANT/rateScale'
				];

		type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT];
		ODBMCreate(address, type); 

		ODBSet('/DashboardConfig/DESCANT/deploy', 1);
	}

	//HPGe - no if, always in
	address = [	'/DashboardConfig/HPGe',
				'/DashboardConfig/HPGe/deploy',
				'/DashboardConfig/HPGe/BGOHVscale',
				'/DashboardConfig/HPGe/BGOthresholdScale',
				'/DashboardConfig/HPGe/BGOrateScale',
				'/DashboardConfig/HPGe/HVscale',
				'/DashboardConfig/HPGe/thresholdScale',
				'/DashboardConfig/HPGe/rateScale',
				'/DashboardConfig/HPGe/upstreamLampAbsent',
				'/DashboardConfig/HPGe/downstreamLampAbsent'
			];
	type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT];
	ODBMCreate(address, type); 

	ODBSet('/DashboardConfig/HPGe/deploy', 1);

	//PACES
	if(PACES){
		address = [	'/DashboardConfig/PACES',
					'/DashboardConfig/PACES/deploy',
					'/DashboardConfig/PACES/HVscale',
					'/DashboardConfig/PACES/thresholdScale',
					'/DashboardConfig/PACES/rateScale'
				];

		type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT];
		ODBMCreate(address, type); 		

		ODBSet('/DashboardConfig/PACES/deploy', 1);			
	}

	//SCEPTAR
	if(usSCEPTAR || dsSCEPTAR){
		address = [	'/DashboardConfig/SCEPTAR',
					'/DashboardConfig/SCEPTAR/USdeploy',
					'/DashboardConfig/SCEPTAR/DSdeploy',
					'/DashboardConfig/SCEPTAR/HVscale',
					'/DashboardConfig/SCEPTAR/thresholdScale',
					'/DashboardConfig/SCEPTAR/rateScale'
				];

		type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT, TID_INT];
		ODBMCreate(address, type);

		ODBSet('/DashboardConfig/SCEPTAR/USdeploy', (usSCEPTAR ? 1 : 0) );
		ODBSet('/DashboardConfig/SCEPTAR/DSdeploy', (dsSCEPTAR ? 1 : 0) );

	}

	//SHARC
	if(SHARC){
		address = [	'/DashboardConfig/SHARC',
					'/DashboardConfig/SHARC/deploy',
					'/DashboardConfig/SHARC/HVscale',
					'/DashboardConfig/SHARC/thresholdScale',
					'/DashboardConfig/SHARC/rateScale'
				];

		type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT];
		ODBMCreate(address, type); 

		ODBSet('/DashboardConfig/SHARC/deploy', 1);
	}						

	//SPICE
	if(SPICE){
		address = [	'/DashboardConfig/SPICE',
					'/DashboardConfig/SPICE/deploy',
					'/DashboardConfig/SPICE/HVscale',
					'/DashboardConfig/SPICE/thresholdScale',
					'/DashboardConfig/SPICE/rateScale',
					'/DashboardConfig/SPICE/SPICEauxiliary',
					'/DashboardConfig/SPICE/SPICEauxLayers'
				];

		type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT, TID_STRING, TID_INT];
		ODBMCreate(address, type); 

		ODBSet('/DashboardConfig/SPICE/deploy', 1);
	}

	//TIP ball
	if(TIPball){
		address = [	'/DashboardConfig/TIPball',
					'/DashboardConfig/TIPball/deploy',
					'/DashboardConfig/TIPball/HVscale',
					'/DashboardConfig/TIPball/thresholdScale',
					'/DashboardConfig/TIPball/rateScale'
				];

		type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT];
		ODBMCreate(address, type); 

		ODBSet('/DashboardConfig/TIPball/deploy', 1);
	}

	//TIP wall
	if(TIPwall){
		address = [	'/DashboardConfig/TIPwall',
					'/DashboardConfig/TIPwall/deploy',
					'/DashboardConfig/TIPwall/HVscale',
					'/DashboardConfig/TIPwall/thresholdScale',
					'/DashboardConfig/TIPwall/rateScale'
				];

		type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT];
		ODBMCreate(address, type); 

		ODBSet('/DashboardConfig/TIPwall/deploy', 1);
	}

	//ZDS
	if(ZDS){
		address = [	'/DashboardConfig/ZDS',
					'/DashboardConfig/ZDS/deploy',
					'/DashboardConfig/ZDS/HVscale',
					'/DashboardConfig/ZDS/thresholdScale',
					'/DashboardConfig/ZDS/rateScale'
				];

		type = [TID_KEY, TID_INT, TID_INT, TID_INT, TID_INT];
		ODBMCreate(address, type); 

		ODBSet('/DashboardConfig/ZDS/deploy', 1);
	}

	window.location = window.location.href.replace("ConfigureExperiment", "ConfigureSubdetectors");

}

//draw elliptical arc:
function ellipse(context, centerX, centerY, horizRadius, startAngle, endAngle){
    context.save();
    context.translate(centerX, centerY);
    context.scale(1, 0.3);
    context.beginPath();
    context.arc(0, 0, horizRadius, 2*Math.PI - startAngle, 2*Math.PI - endAngle);
    context.restore();
    context.closePath();
    context.stroke();
}

function chooseExperiment(exp){

	//get rid of the dom elements corresponding to the experiment we don't want
	if(exp == 'TIGRESS'){
		deleteDOM('GRIFFINwrap');
		//swap in TIGRESS branding
		document.getElementById('title').innerHTML = 'TIGRESS';
		document.getElementById('logo').src = 'triumf.gif'
	} else if(exp == 'GRIFFIN'){
		deleteDOM('TIGRESSwrap');
	}

	//fade out the experiment selection modal
	document.getElementById('chooseExperiment').active = false;
	//fade in the rest of the page
	document.getElementById('wrapper').setAttribute('style','opacity:1');
	document.getElementById('footer').setAttribute('style','opacity:1');

}

//delete a dom element by ID
function deleteDOM(id){
    var element = document.getElementById(id);
    element.parentNode.removeChild(element);
};
function thumbnail(canvasID, left, right, color, disabled){
	var canvas = document.getElementById(canvasID);
	var context = canvas.getContext('2d');

	imageObj = document.getElementById('logo')

	var width = canvas.width;
	var height = canvas.height;

	window.width = width;
	window.height = height;

	context.clearRect(0,0,width,height);
	context.lineWidth = 1;

	var title = '';

	context.strokeStyle = color;
	context.fillStyle = color;

	//GRIFFIN options
	if(left == 'US SCEPTAR' && right == 'DS SCEPTAR'){
		sceptar(context, width/3, height*0.4, height*0.2, disabled);
		sceptar(context, 2*width/3, height*0.4, height*0.2, disabled);
		title = 'USSC + DSSC';
	} else if(left == 'US SCEPTAR' && right == 'ZDS'){
		sceptar(context, width/3, height*0.4, height*0.2, disabled);
		zds(context, 2/3*width, 0.4*height, 0.18*height, disabled);
		title = 'USSC + ZDS';
	} else if(left == 'PACES' && right == 'DS SCEPTAR'){
		paces(context, width/3, height*0.4, height*0.15, height*0.05);
		sceptar(context, 2*width/3, height*0.4, height*0.2, disabled);
		title = 'PACES + SCEPTAR';
	} else if(left == 'PACES' && right == 'ZDS'){
		paces(context, width/3, height*0.4, height*0.15, height*0.05, disabled);
		zds(context, 2/3*width, 0.4*height, 0.18*height, disabled);
		title = 'PACES + ZDS';
	} else if(left == 'SPICE' && right == 'ZDS'){
		spice(context, width/3, height*0.4, height*0.2, disabled);
		zds(context, 2/3*width, 0.4*height, 0.18*height, disabled);
		title = 'SPICE + ZDS';
	} else if(left == 'SPICE' && right == 'DS SCEPTAR'){
		spice(context, width/3, height*0.4, height*0.2);
		sceptar(context, 2*width/3, height*0.4, height*0.2, disabled);
		title = 'SPICE + DSSC';
	} else if(left == 'GRIFFIN' && right == 'none'){
		griffin(context, width*0.5 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		title = 'GRIFFIN Standalone';	
	} else if(left == 'GRIFFIN' && right == 'DESCANT'){
		griffin(context, width*0.28 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		descant(context, width*0.68, height*0.4, height*0.1 )
		title = 'GRIFFIN + DESCANT'
	} else if(left == 'GRIFFIN' && right == 'DANTE'){
		griffin(context, width*0.3 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		dante(context, width*0.7, height*0.4, height*0.2, color);
		title = 'GRIFFIN + DANTE';
	} else if(left == 'GRIFFIN' && right == 'SPICE'){
		griffin(context, width*0.28 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		spice(context, width*0.68, height*0.4, height*0.2, disabled);
		title = 'GRIFFIN + SPICE';
	}

	//TIGRESS options
	if(left == 'BAMBINO' && right == 'none'){
		title = 'BAMBINO';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);	
	} else if(right == 'BAMBINO' && left == 'none'){
		title = 'DS BAMBINO';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);		
	} else if(left == 'BAMBINO' && right == 'BAMBINO'){
		title = 'US + DS BAMBINO';
		bambino(context, width*0.28, width*0.38, height/3, height*0.6, height*0.12);
		bambino(context, width*0.62, width*0.72, height/3, height*0.6, height*0.12);
	} else if(left == 'SHARC' && right == 'none'){
		title = 'SHARC';
		sharc(context, width/2, height*0.45, width*0.3, height*0.7, disabled);	
	} else if(left == 'SHARC' && right == 'services'){
		title = 'SHARC Services';
		sharc(context, width/2, height*0.45, width*0.3, height*0.7, disabled);	
	} else if(left == 'SPICE' && right == 'none'){
		spice(context, width*0.5, height*0.45, height*0.2, disabled);
		title = 'SPICE';
	} else if(left == 'SPICE' && right == 'services'){
		spice(context, width*0.5, height*0.45, height*0.2, disabled);
		title = 'SPICE Services';
	} else if(left == 'TIPwall' && right == 'none'){
		tipWall(context, width/2, height*0.45, height/2);
		title = 'TIP Wall';
	} else if(left == 'TIPball' && right == 'none'){
		tipBall(context, width/2, height/2, height*0.25);
		title = 'TIP Ball';
	} else if(left == 'TIGRESS' && right == 'none'){
		tigress(context, width/2, height*0.45, Math.round(height*0.25));
		title = 'TIGRESS';
	} else if(left == 'TIGRESS' && right == 'SHARC'){
		tigress(context, width*0.32, height*0.45, Math.round(height*0.25));
		sharc(context, width*0.7, height*0.45, width*0.3, height*0.7);
		title = 'TIGRESS + SHARC';
	} else if(left == 'TIGRESS' && right == 'DESCANT'){
		tigress(context, width*0.28, height*0.45, Math.round(height*0.25));
		descant(context, width*0.68,height*0.4, height*0.1 );
		title = 'TIGRESS + DESCANT';
	} else if(left == 'TIGRESS' && right == 'all'){
		tigress(context, width*0.2, height*0.45, Math.round(height*0.25));
		sharc(context, width*0.5, height*0.45, width*0.3, height*0.7);
		descant(context, width*0.8,height*0.4, height*0.1 );
		context.font = '14px Raleway';
		title = 'TIGRESS + SHARC + DESCANT';
	} else if(left == 'TIGRESS' && right == 'SPICE'){
		tigress(context, width*0.28, height*0.45, Math.round(height*0.25));
		spice(context, width*0.68, height*0.45, height*0.2, disabled);
		title = 'TIGRESS + SPICE';
	} else if(left == 'beamdump' && right == 'none'){
		beamdump(context, width/2, height*0.45, height*0.4)
		title = 'Beamdump Scintilator';
	}

	//standalone options
	if(left == 'HPGe' && right == 'none'){
		tigress(context, width/2, height*0.45, Math.round(height*0.25));
		title = 'HPGe';		
	} else if(left == 'DESCANT' && right=='none'){
		descant(context, width*0.5,height*0.4, height*0.1 );
		title = 'DESCANT';		
	} else if(left == 'PACES' && right=='none'){
		paces(context, width/2, height*0.4, height*0.15, height*0.05);
		title = 'PACES';
	} else if(left == 'DANTE' && right=='none'){
		dante(context, width*0.5, height*0.4, height*0.2, color);
		title = 'DANTE';
	} else if( (left == 'US SCEPTAR' || left == 'SCEPTAR') && right=='none'){
		sceptar(context, width/2, height*0.4, height*0.2, disabled);
		title = 'SCEPTAR';
	} else if(left == 'SPICE' && right=='none'){
		spice(context, width*0.5, height*0.45, height*0.2, disabled);
		title = 'SPICE';
	} else if(left == 'ZDS' && right=='none'){
		zds(context, 0.5*width, 0.4*height, 0.18*height);
		title = 'ZDS';
	} else if(left == 'BAMBINO' && right=='none'){
		title = 'BAMBINO';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);		
	} else if(left == 'S3' && right=='none'){
		title = 'S2 / S3';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);		
	} else if(left == 'TRIUMF' && right == 'none'){
		triumf(context, width*0.5 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		title = 'Top Level Config';	
	} else if(left == 'HV' && right == 'none'){
		hv(context, width, height, color);
		title = 'High Voltage';
	}

	if(right != 'all') context.font = '16px Raleway';
	context.fillText(title, width/2 - context.measureText(title).width/2, 0.9*height);
}

//individual thumbnails////////////////////////////////////////////////////////////////////////////////

//draw a SCEPTAR wireframe on context centered at x0, y0.  size is the center to outer vertext distance. 
function sceptar(context, x0, y0, size, disabled){
	var i, side;
	side = size*Math.sqrt(2-2*Math.cos(72/180*Math.PI));
	smallSize = 0.5*size;
	smallSide = smallSize*Math.sqrt(2-2*Math.cos(72/180*Math.PI));
	context.save();
	context.translate(x0, y0);
	context.beginPath();
	context.rotate(54/180*Math.PI);
	for(i=0; i<5; i++){
		context.moveTo(0,0);
		context.lineTo(size, 0);
		context.lineTo(size - side*Math.cos(54/180*Math.PI), side*Math.sin(54/180*Math.PI) );
		context.stroke();
		context.moveTo(smallSize, 0);
		context.lineTo(smallSize - smallSide*Math.cos(54/180*Math.PI), smallSide*Math.sin(54/180*Math.PI) );
		context.stroke();
		context.rotate(72/180*Math.PI);
	}
	context.closePath();
	context.restore();

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

function zds(context, x0, y0, radius, disabled){
	context.beginPath();
	context.arc(x0, y0, radius, 0, 2*Math.PI);
	context.closePath();
	context.stroke();

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

//draw a PACES wireframe on context centered at x0, y0.  size is the array center to detector center distance, rad is the detector radius.
function paces(context, x0, y0, size, rad, disabled){
	var i;

	context.save();
	context.translate(x0, y0);
	context.rotate(54/180*Math.PI);
	for(i=0; i<5; i++){
		context.beginPath();
		context.arc(size, 0, rad, 0, 2*Math.PI);
		context.closePath();
		context.stroke();
		context.rotate(72/180*Math.PI);
	}
	context.restore();

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

function spice(context, x0, y0, rad, disabled){
	var i, innerRad, radStep;

	innerRad = 0.15*rad;
	radStep = (rad - innerRad)/3

	for(i=0; i<4; i++){
		context.beginPath();
		context.arc(x0, y0, innerRad+i*radStep, 0, 2*Math.PI);
		context.closePath();
		context.stroke();
	}

	for(i=0; i<8; i++){
		context.beginPath();
		context.moveTo(x0 + innerRad*Math.cos(Math.PI/4*i), y0 + innerRad*Math.sin(Math.PI/4*i));
		context.lineTo(x0 + rad*Math.cos(Math.PI/4*i), y0 + rad*Math.sin(Math.PI/4*i));
		context.closePath();
		context.stroke();
	}

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

function descant(context, x0, y0, cellSize){
	var i, rad;

	//center to center distance of adjacent honeycomb cells:
	rad = 2*cellSize*Math.cos(30/180*Math.PI);

	regPoly(context, x0,y0, 6, cellSize);

	context.save();
	context.translate(x0, y0);
	for(i=0; i<6; i++){
		regPoly(context, 0, rad, 6, cellSize);
		context.rotate(60/180*Math.PI);
	}
	context.restore();
}

function dante(context, x0, y0, radius, color){
	var i;

	context.save();
	context.translate(x0,y0);
	context.rotate(Math.PI/8);
	context.beginPath();
	context.arc(0,0,radius, 0, 2*Math.PI);
	context.closePath();
	context.stroke();
	for(i=0; i<4; i++){
		context.beginPath();
		context.fillStyle = color;
		context.arc(radius, 0, radius*0.35, 0, 2*Math.PI);
		context.closePath();
		context.fill();
		context.beginPath();
		context.fillStyle = '#333333';
		context.arc(radius, 0, radius*0.3, 0, 2*Math.PI);
		context.closePath();
		context.fill();
		context.beginPath();
		context.fillStyle = color;
		context.arc(radius, 0, radius*0.2, 0, 2*Math.PI);
		context.closePath();
		context.fill();
		context.rotate(Math.PI/2);
	}
	context.restore();
}
function bambino(context, x0upper, x0lower, y0upper, y0lower, rad){
	var i, innerRad, radStep;

	innerRad = 0.15*rad;
	radStep = (rad - innerRad)/5

	for(i=0; i<6; i++){
		context.beginPath();
		context.arc(x0upper, y0upper, innerRad+i*radStep, 0, 2*Math.PI);
		context.closePath();
		context.stroke();

		if(i==0 || i==5){
			context.beginPath();
			context.arc(x0lower, y0lower, innerRad+i*radStep, 0, 2*Math.PI);
			context.closePath();
		}
		context.stroke();
	}

	for(i=0; i<12; i++){
		context.beginPath();
		context.moveTo(x0lower + innerRad*Math.cos(Math.PI/6*i), y0lower + innerRad*Math.sin(Math.PI/6*i));
		context.lineTo(x0lower + rad*Math.cos(Math.PI/6*i), y0lower + rad*Math.sin(Math.PI/6*i));
		context.closePath();
		context.stroke();		
	}
}

function sharc(context, x0, y0, width, height, disabled){
	context.save();
	context.translate(x0,y0);
	ellipse(context, 0, -0.35*height, 0.2*width, 0, Math.PI*2);
	ellipse(context, 0, 0.35*height, 0.2*width, 0, Math.PI*2);
	ellipse(context, 0, -0.35*height, 0.4/3*width, 0, Math.PI*2);
	ellipse(context, 0, 0.35*height, 0.4/3*width, 0, Math.PI*2);
	ellipse(context, 0, -0.35*height, 0.2/3*width, 0, Math.PI*2);
	ellipse(context, 0, 0.35*height, 0.2/3*width, 0, Math.PI*2);
	context.strokeRect(-width*0.2, -height*0.2, width*0.4, height*0.4);
	context.stroke();
	context.beginPath();
	context.moveTo(-width*0.2, 0);
	context.lineTo(width*0.2, 0);
	context.stroke();
	context.beginPath();
	context.moveTo(-width*0.4/6, -height*0.2);
	context.lineTo(-width*0.4/6, height*0.2);
	context.stroke();
	context.beginPath();
	context.moveTo(width*0.4/6, -height*0.2);
	context.lineTo(width*0.4/6, height*0.2);
	context.stroke();
	context.restore();

	if(disabled)
		strikeOut(context, window.width, window.height, x0, y0)
}

function tipWall(context, x0, y0, width){
		var i, cellSize, CsIx0, CsIy0;

		cellSize = width / 5;
		CsIx0 = x0-width/2;
		CsIy0 = y0-width/2;

    	for(i=0; i<25; i++){
            context.strokeRect(CsIx0 + cellSize*(i%5), CsIy0 + cellSize*Math.floor(i/5), cellSize, cellSize);
    	}
    	context.strokeRect(CsIx0, CsIy0, width, width)
}

function tipBall(context, x0, y0, rad){

	context.save();

	context.beginPath();
	context.arc(x0,y0,rad,0,Math.PI*2);
	context.clip();

	context.beginPath();
	context.lineWidth = 2;
	context.arc(x0,y0,rad-1,0,Math.PI*2);
	context.stroke();

	context.lineWidth=1;
	context.beginPath();
	context.arc(x0+20,y0,rad+10,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0-20,y0,rad+10,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0+20,rad+10,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0-20,rad+10,0,Math.PI*2);
	context.stroke();

	context.beginPath();
	context.arc(x0+40,y0,rad+20,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0-40,y0,rad+20,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0+40,rad+20,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0-40,rad+20,0,Math.PI*2);
	context.stroke();

	context.beginPath();
	context.moveTo(x0-rad, y0);
	context.lineTo(x0+rad,y0);
	context.stroke;
	context.moveTo(x0, y0-rad);
	context.lineTo(x0, y0+rad);
	context.stroke();

	context.restore();

}

function griffin(context, x0, y0, color){
	if(color == '#999999')context.globalAlpha = 0.4;

    var imgObj = document.getElementById('logo')
    context.drawImage(imgObj, x0, y0, imgObj.width/imgObj.height*context.canvas.height*0.6, context.canvas.height*0.6);
	context.globalAlpha = 1;
}

function triumf(context, x0, y0, color){
	if(color == '#999999')context.globalAlpha = 0.4;
	context.drawImage(imageObj, x0, y0, imageObj.width/imageObj.height*context.canvas.height*0.6, context.canvas.height*0.6);
	context.globalAlpha = 1;
}

function tigress(context, x0, y0, size){
	var hpge = Math.round(size*0.3);
	var bgo = Math.round(size*0.75);

	context.save();
	context.translate(x0, y0);
	context.strokeRect(-size, -size, 2*size, 2*size);
	context.strokeRect(-bgo, -bgo, 2*bgo, 2*bgo);
	context.strokeRect(-hpge, -hpge, 2*hpge, 2*hpge );

	context.moveTo(-hpge, 0);
	context.lineTo(hpge, 0);
	context.moveTo(0, -hpge);
	context.lineTo(0, hpge);

	context.moveTo(0, -size);
	context.lineTo(0, -(size-hpge) - 2 );
	context.moveTo(0, size);
	context.lineTo(0, size-hpge + 2 );
	context.moveTo(-size, 0);
	context.lineTo(-(size-hpge) - 2, 0);
	context.moveTo(size, 0);
	context.lineTo(size-hpge + 2, 0);

	context.stroke();
	context.restore();
}

function beamdump(context, x0, y0, width){
	var i;

	context.save();
	context.translate(x0, y0);

	context.moveTo(width/2, -width/2);
	context.lineTo(width/2, width/2);
	context.moveTo(width*0.45, -width/2 );
	context.lineTo(width*0.45, width/2);

	for(i=0; i<10; i++){
		context.moveTo(width*0.45, width/2 - i*width/10);
		context.lineTo(width*0.5, width/2 - (i+1)*width/10)
	}

	context.fillRect(-width/2, -2, width*0.95, 4);

	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.4, 12);
	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.3, 20);
	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.4, -15);
	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.1, -10)

	context.stroke();
	context.restore();

}

function hv(context, width, height, color){
	context.fillStyle = color;
	context.beginPath()
	context.moveTo(0.6*width, 0.2*height);
	context.lineTo(0.4*width, 0.475*height);
	context.lineTo(0.5*width, 0.475*height);
	context.lineTo(0.4*width, 0.7*height);
	context.lineTo(0.6*width, 0.425*height);
	context.lineTo(0.5*width, 0.425*height);
	context.closePath();
	context.fill()
}

//draws a regular polygon of n sides on context, centered at x0, y0 and with a center-vertext distance of size
function regPoly(context, x0, y0, n, size){
	var i;
	var stepAngle = 2*Math.PI/n;
	var jointAngle = (Math.PI-stepAngle)/2;
	var side = size*Math.sqrt(2-2*Math.cos(stepAngle));

	context.save();
	context.translate(x0, y0);
	context.beginPath();
	for(i=0; i<n; i++){
		context.moveTo(size, 0);
		context.lineTo(size - side*Math.cos(jointAngle), 0-side*Math.sin(jointAngle));
		context.stroke();
		context.rotate(stepAngle);
	}
	context.restore();
}

function strikeOut(context, width, height, x0, y0){

	context.save();
	context.beginPath()
	context.lineWidth = 5;
	context.strokeStyle = '#FF0000';
	context.moveTo(x0-width/4, y0-height/4);
	context.lineTo(x0+width/4, y0+height/4);
	context.stroke();
	context.moveTo(x0+width/4, y0-height/4);
	context.lineTo(x0-width/4, y0+height/4);
	context.stroke();
	context.restore();

}

function glowy(canvasID){
	var canvas = document.getElementById(canvasID);
	var context = canvas.getContext('2d');

	context.shadowOffsetX = 0;
	context.shadowOffsetY = 0;
	context.shadowBlur = 2;
	context.shadowColor = '#FFFFFF';
	thumbnail('Gcha5canv', 'SPICE', 'DSSC');
	context.fill();

}

//cycle badges/////////////////////////////////////////////////////
function clearScalars(context, height, width){
	context.fillStyle = '#999999';
	digitalDigit([1,1,1,1,1,1,0], context, height, 0.2*width, 0.05*height);
	digitalDigit([1,1,1,1,1,1,0], context, height, 0.65*width, 0.05*height);
}

function moveTape(context, width, height, x0, y0){
	var i,
		tapeTop = 0.1*height;
		tapeHeight = 0.6*height;
		holeSide = tapeHeight/10;
		holeSpacing = holeSide/2;

	context.fillStyle = '#999999';
	context.fillRect(0, tapeTop, width, tapeHeight);
	context.fillStyle = '#333333';
	for(i=0; i<20; i++){
		context.fillRect(i*(holeSpacing+holeSide), tapeTop+holeSpacing, holeSide, holeSide );
		context.fillRect(i*(holeSpacing+holeSide), tapeTop+tapeHeight - holeSpacing - holeSide, holeSide, holeSide );
	}
	roundBox(context, -0.1*width, tapeTop+2*holeSpacing+holeSide, 0.33*width, tapeHeight - 2*(2*holeSpacing+holeSide), 5);
	context.fill();
	roundBox(context, 0.25*width, tapeTop+2*holeSpacing+holeSide, 0.5*width, tapeHeight - 2*(2*holeSpacing+holeSide), 5);
	context.fill();
	roundBox(context, 0.77*width, tapeTop+2*holeSpacing+holeSide, 0.5*width, tapeHeight - 2*(2*holeSpacing+holeSide), 5);
	context.fill();

}

function beamOn(context, width, height, x0, y0){
	beamdump(context, x0, y0, width);
}

function triggersOn(context, width, height, x0, y0){
	//fingernail
	context.moveTo(width*0.5, height*0.3);
	context.quadraticCurveTo(width*0.52, height*0.32, width*0.6, height*0.35);
	context.quadraticCurveTo(width*0.52, height*0.37, width*0.5, height*0.3)

	//finger top
	context.moveTo(width*0.5, height*0.3);
	context.quadraticCurveTo(width*0.5*0.9, height*0.3*0.9, -2*width, -width);
	context.stroke();

	//finger bottom
	context.moveTo(width*0.6, height*0.35);
	context.quadraticCurveTo(width*0.55, height*0.6, -2*width, -width);
	context.stroke();

	//switch
	context.moveTo(0, height*0.7);
	context.lineTo(width, height*0.7);
	context.moveTo(0.3*width, height*0.7);
	context.lineTo(0.3*width, height*0.5);
	context.quadraticCurveTo(0.5*width, height*0.55, 0.7*width, height*0.5);
	context.lineTo(0.7*width, 0.7*height);

	//arrow
	context.moveTo(0.5*width, 0.6*height);
	context.lineTo(0.9*width, 0.6*height);
	context.lineTo(0.85*width, 0.55*height);
	context.moveTo(0.9*width, 0.6*height);
	context.lineTo(0.85*width, 0.65*height);


	context.stroke();
}

function syncClocks(context, width, height, x0, y0){
	var i;

	context.beginPath();
	context.arc(x0,y0, height*0.3, 0, Math.PI*2);
	context.stroke();
	context.closePath();

	context.save();
	context.translate(x0, y0);
	for(i=0; i<12; i++){
		context.moveTo(0, -height*0.3);
		context.lineTo(0, -height*0.3 +height*0.06);
		context.stroke();
		context.closePath();
		context.rotate(Math.PI/6);
	}

	context.moveTo(0, 0);
	context.lineTo(height*0.3*Math.cos(1.2*Math.PI), height*0.3*Math.sin(1.2*Math.PI));
	context.stroke();
	context.closePath();

	context.moveTo(0, 0);
	context.lineTo(height*0.15*Math.cos(4.3*Math.PI), height*0.15*Math.sin(4.3*Math.PI));
	context.stroke();
	context.closePath();	

	context.restore();
}

function wildcard(context, width, height, x0, y0){
	context.font = '100px Raleway';
	context.fillText('*', width/2-15, height);
	context.font = '16px Raleway';
}//generic function to execute the animation of some object <thing>, which has memeber function .draw which draws
//the thing only as a function of what frame the animation is on, and member data .duration, .FPS and .nFrames.
function animate(thing, frame){

    //clearTimeout(window.animateLoop);

    thing.draw(frame);
    if(frame < thing.nFrames){
        frame++;
        window.animateLoop = setTimeout(function(){animate(thing, frame)},thing.duration/thing.FPS*1000);
    }
}

//copy of animate, but for use on detail level view:  todo: combine with animate
function animateDetail(thing, frame){

    thing.drawDetail(thing.detailContext, frame);
    if(frame < thing.nFrames){
        frame++;
        window.transAnimateLoop = setTimeout(function(){animateDetail(thing, frame)},thing.duration/thing.FPS*1000);
    }
}

//styling functions to highlight / unhighlight submit button
function unhighlight(buttonID){
    clearTimeout(window.commitBlink);
    $('#'+buttonID).css('background-color', '#FFFFFF');
}

function highlight(buttonID){

    //$('#'+buttonID).css('background-color', '#FFFF00');
    clearTimeout(window.commitBlink);
    function blinkHighlight(color){
        $('#'+buttonID).css('background-color', color);

        if(color == '#FFFFFF') window.commitBlink = setTimeout(function(){blinkHighlight('#FFFF00')},1000);
        if(color == '#FFFF00') window.commitBlink = setTimeout(function(){blinkHighlight('#FFFFFF')},1000);
    }

    blinkHighlight('#FFFF00')


}

//insert something in the DOM
function insertDOM(element, id, classTag, style, wrapperID, onclick, content, name, type, value){
    var newElement = document.createElement(element);
    newElement.setAttribute('id', id);
    newElement.setAttribute('class', classTag);
    newElement.setAttribute('style', style);
    newElement.setAttribute('name', name);
    newElement.setAttribute('type', type);
    newElement.setAttribute('value', value);
    if(wrapperID == 'body')
        document.body.appendChild(newElement)
    else
        document.getElementById(wrapperID).appendChild(newElement);
    document.getElementById(id).innerHTML = content;
    document.getElementById(id).onclick = onclick;
}

//more flexible DOM injector; <properties> is an object containing property.value pairs for all properties to be set: 
function injectDOM(element, id, wrapperID, properties){
    var key, elt,
        newElement = document.createElement(element);
    //explicit ID
    newElement.setAttribute('id', id);
    //append to document:
    if(wrapperID == 'body')
        document.body.appendChild(newElement)
    else
        document.getElementById(wrapperID).appendChild(newElement);
    elt = document.getElementById(id);

    //some things need to be set specially:
    if(properties['innerHTML'] || properties['innerHTML'] === 0){
        elt.innerHTML = properties['innerHTML'];
        delete properties['innerHTML'];
    }
    if(properties['onclick']){
        elt.onclick = properties['onclick'];
        delete properties['onclick'];
    }
    //send in the clowns:
    for(key in properties){
        elt.setAttribute(key, properties[key]);
    }

}

//devName = device Name, scales = [ [scale title, parameter service minima, parameter service maxima, unit, ODBminpath, ODBmaxpath], ...]
function parameterDialogue(devName, scales, currentColorScale, noLog){
    var i, j, ODBpath;

    //insert div and title
    injectDOM('div', 'tempDiv', window.parameters.wrapper, {'class' : 'tempDialog'});
    var dialogue = document.getElementById('tempDiv');
    injectDOM('h2', 'dialogHeader', 'tempDiv', {
        'style' : 'position:relative; font:24px Orbitron; top:10px; margin-bottom:6%',
        'innerHTML' : 'Adjust '+devName+' Scale'
    });

    //fix dimensions
    var width = 0.35*window.innerWidth;
    $('#dialogHeader').width(width)

    //center dialogue
    $('#tempDiv').css('left', ($('#'+window.parameters.wrapper).width()/2 - width/2))

    //insert form fields
    injectDOM('form', 'dialogueValues', 'tempDiv', {});
    for(i=0; i<scales.length; i++){
        injectDOM('p', 'title'+i, 'dialogueValues', {'style':'font-size:16px; margin-top:3%;', 'innerHTML':scales[i][0]+'<br>'});
        injectDOM('p', 'minlabel'+i, 'dialogueValues', {'style':'display:inline', 'innerHTML':'Minimum: '});
        injectDOM('input', 'minfield'+i, 'dialogueValues', {
            'style' : 'display:inline;',
            'name' : 'textbox',
            'type' : 'number',
            'value' : scales[i][1],
            'size' : 6
        });
        injectDOM('p', 'minunit'+i, 'dialogueValues', {'style':'display:inline; margin-right:3%', 'innerHTML':scales[i][3]});
        injectDOM('p', 'maxlabel'+i, 'dialogueValues', {'style':'display:inline;', 'innerHTML':'Maximum: '});
        injectDOM('input', 'maxfield'+i, 'dialogueValues', {
            'style' : 'display:inline;',
            'name' : 'textbox',
            'type' : 'number',
            'value' : scales[i][2],
            'size' : 6
        });
        injectDOM('p', 'maxunit'+i, 'dialogueValues', {'style':'display:inline;', 'innerHTML':scales[i][3] + '<br>'});
        //don't allow min > max:
        document.getElementById('minfield'+i).onchange = function(){document.getElementById('maxfield'+this.id[8]).min = document.getElementById(this.id).valueAsNumber;};

    }

    //insert color scale picker:
    if(currentColorScale){
        injectDOM('p', 'colorPickerLabel', 'dialogueValues', {'style':'display:inline;', 'innerHTML':'<br><br>Palette: '})
        var colorScales = window.parameters.colorScale;
        injectDOM('select', 'colorOptions', 'dialogueValues', {});
        var colorDD = document.getElementById('colorOptions');
        var option = [];
        for(i=0; i<colorScales.length; i++){
            option[i] = document.createElement('option');
            option[i].text = colorScales[i];
            option[i].value = colorScales[i];
            colorDD.add(option[i], null);
        }
        colorDD.value = currentColorScale;
        injectDOM('br', 'break', 'dialogueValues', {});
    }

    //insert scale linear / log choice:
    if(!noLog){
        injectDOM('p', 'scalePickerLabel', 'dialogueValues', {'style':'display:inline; margin-right:2%', 'innerHTML':'<br><br>Scale: '});
        injectDOM('p', 'linearRadioLabel', 'dialogueValues', {'style':'display:inline', 'innerHTML':'Linear'});
        injectDOM('input', 'linearRadio', 'dialogueValues', {
            'style' : 'display:inline; margin-right:2%;',
            'name' : 'scaleSwitch',
            'type' : 'radio',
            'value' : 'linear'
        });
        injectDOM('p', 'logRadioLabel', 'dialogueValues', {'style':'display:inline', 'innerHTML':'Log'});
        injectDOM('input', 'logRadio', 'dialogueValues', {
            'style' : 'display:inline;',
            'name' : 'scaleSwitch',
            'type' : 'radio',
            'value' : 'log'
        });
        injectDOM('br', 'break', 'dialogueValues', {});

        if (window.parameters.detectorLogMode[window.viewState] == 1) document.getElementById('logRadio').checked = true;
        else document.getElementById('linearRadio').checked = true;
    }

    //insert submit & dismiss button
    injectDOM('input', 'updateParameters', 'dialogueValues', {
        'class' : 'bigButton',
        'style' : 'width:20%; margin-right:2%; margin-top:6%',
        'type' : 'button',
        'value' : 'Commit'
    });
    injectDOM('input', 'dismiss', 'dialogueValues', {
        'class' : 'bigButton',
        'style' : 'width:20%; margin-top:6%; margin-bottom:6%;',
        'type' : 'button',
        'value' : 'Dismiss'
    });

    document.getElementById('updateParameters').onclick = function(event){
        var i;
        if(document.getElementById('dialogueValues').checkValidity()){
            
            for(i=0; i<scales.length; i++){
                //commit
                scales[i][1] = parseFloat(document.getElementById('minfield'+i).value);
                scales[i][2] = parseFloat(document.getElementById('maxfield'+i).value);
                ODBSet(scales[i][4], scales[i][1]);
                ODBSet(scales[i][5], scales[i][2]);
            }
            fetchODB(); //pushes back to the parameter store

            if(currentColorScale){
                if(window.onDisplay.slice(0,3) == 'DAQ'){
                    window.DAQpointer.DAQcolor = window.parameters.colorScale.indexOf(colorDD.value);
                } else {
                    window.parameters.subdetectorColors[window.state.subdetectorView] = colorDD.value;
                }
            }

            if(!noLog){
                if(document.getElementById('logRadio').checked) window.parameters.detectorLogMode[window.viewState] = 1;
                else if(document.getElementById('linearRadio').checked) window.parameters.detectorLogMode[window.viewState] = 0;
            }

            //remove dialogue
            document.getElementById('tempDiv').style.opacity = 0;
            setTimeout(function(){
                var element = document.getElementById('tempDiv');
                element.parentNode.removeChild(element);            
            }, 500);

            rePaint();

        } else{
            alert("Something doesn't make sense.  Check fields for mistakes, highlighted in red.");
        }
    }

    document.getElementById('dismiss').onclick = function(event){
        document.getElementById('tempDiv').style.opacity = 0;
        setTimeout(function(){
            var element = document.getElementById('tempDiv');
            element.parentNode.removeChild(element);            
        }, 500);
    }

    //fade the div in:
    dialogue.style.opacity = 1
}

//help build the ODB path string for the above parameter dialogue:
function scaleType(){
    if (window.state.subdetectorView == 0) return 'HVscale';
    else if (window.state.subdetectorView == 1 || window.state.subdetectorView == 3) return 'thresholdScale';
    else if (window.state.subdetectorView == 2 || window.state.subdetectorView == 4) return 'rateScale';    
}

//Crockford's prototype magics:
function DCobject(o) {
    function F() {}
    F.prototype = o;
    return new F();
}


//return the biggest font size that fits a string into a given length in a given context:
function fitFont(context, string, length){
    var i, size = 1;
    context.font = size+'px Raleway';
    
    while(context.measureText(string).width < length){
        size++;
        context.font = size+'px Raleway';
    }
    
    return size-1;
}

//get the <tag> elements inside a given <parent> (for stripping the head out of the imported status page, since those objects currently have no id's :/ )
function getTag(tag, parentID){
    parent = document.getElementById(parentID);
    var descendants = parent.getElementsByTagName(tag);
    if ( descendants.length )
        return descendants;
    return null;
}

//generate a fake JSONP scalar post to use for offline development:
function fakeScalars(){
    
    var JSONP = {'scalar' : {} },
        key, subKey;


    for(key in ODB){
        if(ODB[key].deploy || ODB[key].USdeploy || ODB[key].DSdeploy){     
            for(subKey in window[key+'pointer'].dataBus[key]){
                JSONP.scalar[subKey] = {"TRIGREQ" : 1000*Math.random(), "dataRate" : 1000*Math.random()};
            }
        }
    }

    return JSONP;
    
}
//like fake scalars, but now thresholds:
function fakeThresholds(){

    var JSONP = {'parameters' : {'thresholds' : {} } },
        key, subKey;

    for(key in ODB){
        if(ODB[key].deploy || ODB[key].USdeploy || ODB[key].DSdeploy){
            for(subKey in window[key+'pointer'].dataBus[key] ){
                JSONP.parameters.thresholds[subKey] = 1000*Math.random();
            }
        }
    }

    return JSONP;

}

//take a standard object from datastructures and a frame, and determine the appropriate fill color:
function frameColor(obj, frame, nFrames){
    var oldKey, newKey;

    //pick the right keys
    if(window.state.subdetectorView == 0){
        if(obj.HV == 0xDEADBEEF) return 0xDEADBEEF;
        oldKey = 'oldHVcolor';
        newKey = 'HVcolor';
    } else if(window.state.subdetectorView == 1){
        if(obj.threshold == 0xDEADBEEF) return 0xDEADBEEF;
        oldKey = 'oldThresholdColor';
        newKey = 'thresholdColor';
    } else if(window.state.subdetectorView == 2){
        if(obj.rate == 0xDEADBEEF) return 0xDEADBEEF;
        oldKey = 'oldRateColor';
        newKey = 'rateColor';
    }

    return interpolateColor(parseHexColor(obj[oldKey]), parseHexColor(obj[newKey]), frame/nFrames);

}

//make a table for a tooltip using <objects> as rows and <keys> as columns, where the objects are keys of <data>, and insert it into DOM element <id>.  
//[split] indicates how many elements to put in each supercolumn:
function TTtable(id, data, objects, keys, rowTitles, tableTitle, titles, split){
    var i, j, k, n, nContentRows, cellContent;

    injectDOM('table', id+'table', id, {'class':'TTtab', 'style':'border-collapse:collapse'});
    injectDOM('colgroup', id+'colgroup', id+'table', {});
    for(i=0; i<split.length-1; i++){
        injectDOM('col', id+'colSpace'+i, id+'colgroup', {'span':keys.length+1});
        injectDOM('col', id+'col'+i, id+'colgroup', {'style':'border-left:1px solid white;', 'span':'1'});
    }


    if(tableTitle != ''){
        injectDOM('tr', id+'tableTitleRow', id+'table', {});
        injectDOM('td', id+'tableTitle', id+'tableTitleRow', {'innerHTML':tableTitle, 'colspan':(1+keys.length)*split.length});
    }

    injectDOM('tr', id+'tableHeaderRow', id+'table', {});
    for(k=0; k<split.length; k++){
        for(j=0; j<titles.length; j++){
            injectDOM('td', id+'headerCell'+j+'col'+k, id+'tableHeaderRow', {
                'style' : 'padding-left:'+( (j==0 && k!=0) ? 25:10 )+'px; padding-right:'+( (j==titles.length-1) ? 25:10 )+'px;',
                'innerHTML' : titles[j]
            });
        }
    }
    
    nContentRows = Math.max.apply(null, split);

    //build table:
    for(i=0; i<nContentRows; i++){
        //rows
        injectDOM('tr', id+'row'+i, id+'table', {});
        //cells
        for(j=0; j<titles.length*split.length; j++){
            injectDOM('td', id+'row'+i+'cell'+j, id+'row'+i, {
                'style' : 'padding:0px; padding-right:'+( (j%(titles.length+1)==0 && j!=0) ? 25:10 )+'px; padding-left:'+( (j%titles.length == 0 && j!=0) ? 25:10 )+'px'
            });
            //if(j%(keys.length+1)==keys.length && j!=titles.length*split.length-1 ){
            //    document.getElementById(id+'row'+i+'cell'+j).setAttribute('style', 'border-right:1px solid white');
            //}
        }
    }

    //fill table:
    n=0;

    for(i=0; i<split.length; i++){
        for(j=0; j<split[i]; j++){
            document.getElementById(id+'row'+j+'cell'+(titles.length*i)).innerHTML = rowTitles[n];
            for(k=0; k<keys.length; k++){

                if(typeof data[objects[n]][keys[k]] == 'string')
                    cellContent = data[objects[n]][keys[k]];
                else
                    cellContent = data[objects[n]][keys[k]].toFixed(window.parameters.tooltipPrecision);
                if(cellContent == 0xDEADBEEF) cellContent = '0xDEADBEEF'
                document.getElementById(id+'row'+j+'cell'+(1+titles.length*i+k)).innerHTML = cellContent;
            }
            n++;
        }
    }

}

//return an array with the appropriate colors chosen from <dataStore> (typically dataBus[this.name] for detectors) corresponding to the elements listed in [elements]
function colors(elements, dataStore, frame, nFrames){
    var i,
        colors=[];

    if(Array.isArray(elements)){
        for(i=0; i<elements.length; i++){
            colors[i] = viewMap(elements[i], dataStore, frame, nFrames);
        }
    } else {
        colors = viewMap(elements, dataStore, frame, nFrames);
    }

    function viewMap(elements, dataStore, frame, nFrames){
        if(window.state.subdetectorView == 0) return interpolateColor(parseHexColor(dataStore[elements].oldHVcolor), parseHexColor(dataStore[elements].HVcolor), frame/nFrames);
        else if(window.state.subdetectorView == 1 || window.state.subdetectorView == 3) return interpolateColor(parseHexColor(dataStore[elements].oldThresholdColor), parseHexColor(dataStore[elements].thresholdColor), frame/nFrames);
        else if(window.state.subdetectorView == 2 || window.state.subdetectorView == 4) return interpolateColor(parseHexColor(dataStore[elements].oldRateColor), parseHexColor(dataStore[elements].rateColor), frame/nFrames);        
    }

    return colors;
}

String.prototype.width = function(font) {
  var f = font || '12px arial',
      o = $('<div>' + this + '</div>')
            .css({'position': 'absolute', 'float': 'left', 'white-space': 'nowrap', 'visibility': 'hidden', 'font': f})
            .appendTo($('body')),
      w = o.width();

  o.remove();

  return w;
}

function arraySum(start, end) {
    var i, last, total = 0;

    (end == -1) ? last = this.length : end;

    for(i=start; i<end; i++){
        total += parseFloat(this[i]);
    }
    return total
}


function relMouseCoords(event){
    var totalOffsetX = 0,
    totalOffsetY = 0,
    canvasX = 0,
    canvasY = 0,
    currentElement = this,
    test = [],
    elts = [];

    if (event.offsetX !== undefined && event.offsetY !== undefined) { return {x:event.offsetX, y:event.offsetY}; }
    //if (event.layerX !== undefined && event.layerY !== undefined) { return {x:event.layerX, y:event.layerY}; }

    do{
        totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
        totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
        //test[test.length] = currentElement.offsetLeft - currentElement.scrollLeft
        //elts[elts.length] = currentElement
    }
    while(currentElement = currentElement.offsetParent)

    canvasX = event.pageX - totalOffsetX;
    canvasY = event.pageY - totalOffsetY;

    //hack to deal with FF scroll, better solution TBD:
    if(event.offsetX == undefined){
        canvasX -= document.body.scrollLeft;
        canvasY -= document.body.scrollTop;
    }

    return {x:canvasX, y:canvasY}
}
HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;

//generic confirmation dialog
function confirm(headline, detailText, confirmFunc){
    var i, j, ODBpath;

    //insert div and title
    injectDOM('div', 'tempDiv', 'body', {'class':'tempDialog'});
    var dialogue = document.getElementById('tempDiv');
    injectDOM('h2', 'dialogHeader', 'tempDiv', {
        'style' : 'position:relative; font:24px Orbitron; top:10px; margin:0px; margin-left:auto; margin-right:auto; padding:1em; padding-top:0;',
        'innerHTML' : headline
    })

    //warning text
    injectDOM('p', 'warning', 'tempDiv', {'style':'padding: 1em; margin:0px; font-size:120%;', 'innerHTML':detailText});

    //center dialogue
    var width = document.getElementById('tempDiv').offsetWidth;
    document.getElementById('tempDiv').style.left = document.body.offsetWidth/2 - width/2;

    //insert submit & abort button if there's a function to excecute on confirm, otherwise just an acknowledge button
    if(confirmFunc){
        injectDOM('input', 'confirmChoice', 'tempDiv', {
            'class' : 'standardButton',
            'style' : 'width:auto; height:auto; padding:0.5em; margin-left:0px',
            'type' : 'button',
            'value' : 'Confirm'
        });

        document.getElementById('confirmChoice').onclick = function(event){

            confirmFunc();

            document.getElementById('tempDiv').style.opacity = 0;
            setTimeout(function(){
                var element = document.getElementById('tempDiv');
                element.parentNode.removeChild(element);            
            }, 500);

            rePaint();
        }
    }

    injectDOM('input', 'abortChoice', 'tempDiv', {
        'class' : 'standardButton',
        'style' : 'width:auto; height:auto; padding:0.5em;',
        'type' : 'button',
        'value' : (confirmFunc == null) ? 'Dismiss' : 'Abort'
    });

    document.getElementById('abortChoice').onclick = function(event){
        document.getElementById('tempDiv').style.opacity = 0;
        setTimeout(function(){
            var element = document.getElementById('tempDiv');
            element.parentNode.removeChild(element);            
        }, 500);
    }

    //fade the div in:
    dialogue.style.opacity = 1
}

//define function to fetch from JSONP service
//for the scalar service (and anything with the same hierarchy):
function parseResponse(dataWeGotViaJsonp){
    var key, subkey;
    for(key in dataWeGotViaJsonp){
        if (dataWeGotViaJsonp.hasOwnProperty(key)) {
            window.JSONPstore[key] = {};
            for(subkey in dataWeGotViaJsonp[key]){
                if(dataWeGotViaJsonp[key].hasOwnProperty(subkey)){
                    window.JSONPstore[key][subkey.toUpperCase()] = dataWeGotViaJsonp[key][subkey];
                }
            }
        }
    }
}

//similar function for the threshold service:
function parseThreshold(data){
    var key;
    if(data['parameters']['thresholds']){
        window.JSONPstore['thresholds'] = {};
        //console.log(window.JSONPstore['thresholds'])
        for(key in data['parameters']['thresholds']){
            window.JSONPstore['thresholds'][key.toUpperCase().slice(0,10)] = data['parameters']['thresholds'][key];
        }
        //console.log(window.JSONPstore['thresholds'])
    }

    //console.log(data['parameters']['thresholds']['SPI00XN119'])
}

function deployFooter(){
    injectDOM('div', 'footer', 'body', {
        'innerHTML' : 'GRIFFIN 2013<br>GRIFFIN Collaboration Spokesperson: Adam Garnsworthy (garns@triumf.ca) - UI/UX Design & Web Development: Bill Mills (mills.wj@gmail.com)'
    });

}

//return the innerHTML of the option currently selected on select #dropID
function getDrop(dropID){
    var i, name,
        dropdown = document.getElementById(dropID),
        filterIndex = parseInt(dropdown.value, 10);

    for(i=0; i<dropdown.childNodes.length; i++){
        if(dropdown.childNodes[i].value == filterIndex){
            name = dropdown.childNodes[i].innerHTML;
        }            
    }

    return name;
}

//convert n to hex, and represent it with at least d digits (left 0s for padding) and a '0x' prefix:
function hexString(n, d){
    var result = n.toString(16);

    while(result.length < d){
        result = '0' + result;
    }
    return '0x' + result.toUpperCase();
}

//delete a dom element by ID
function deleteDOM(id){
    var element = document.getElementById(id);
    element.parentNode.removeChild(element);
};

//return the value of a selected option from a <select> element
function selected(selectID){
    var select = document.getElementById(selectID),
        value = select.options[select.selectedIndex].value;

    return value;
}
// We don't use the platform bootstrapper, so fake this stuff.

window.Platform = {};
var logFlags = {};


// DOMTokenList polyfill for IE9
(function () {

if (typeof window.Element === "undefined" || "classList" in document.documentElement) return;

var prototype = Array.prototype,
    indexOf = prototype.indexOf,
    slice = prototype.slice,
    push = prototype.push,
    splice = prototype.splice,
    join = prototype.join;

function DOMTokenList(el) {
  this._element = el;
  if (el.className != this._classCache) {
    this._classCache = el.className;

    if (!this._classCache) return;

      // The className needs to be trimmed and split on whitespace
      // to retrieve a list of classes.
      var classes = this._classCache.replace(/^\s+|\s+$/g,'').split(/\s+/),
        i;
    for (i = 0; i < classes.length; i++) {
      push.call(this, classes[i]);
    }
  }
};

function setToClassName(el, classes) {
  el.className = classes.join(' ');
}

DOMTokenList.prototype = {
  add: function(token) {
    if(this.contains(token)) return;
    push.call(this, token);
    setToClassName(this._element, slice.call(this, 0));
  },
  contains: function(token) {
    return indexOf.call(this, token) !== -1;
  },
  item: function(index) {
    return this[index] || null;
  },
  remove: function(token) {
    var i = indexOf.call(this, token);
     if (i === -1) {
       return;
     }
    splice.call(this, i, 1);
    setToClassName(this._element, slice.call(this, 0));
  },
  toString: function() {
    return join.call(this, ' ');
  },
  toggle: function(token) {
    if (indexOf.call(this, token) === -1) {
      this.add(token);
    } else {
      this.remove(token);
    }
  }
};

window.DOMTokenList = DOMTokenList;

function defineElementGetter (obj, prop, getter) {
  if (Object.defineProperty) {
    Object.defineProperty(obj, prop,{
      get : getter
    })
  } else {
    obj.__defineGetter__(prop, getter);
  }
}

defineElementGetter(Element.prototype, 'classList', function () {
  return new DOMTokenList(this);
});

})();


/*
 * Copyright 2012 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

if (typeof WeakMap === 'undefined') {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;

    var WeakMap = function() {
      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');
    };

    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key)
          entry[1] = value;
        else
          defineProperty(key, this.name, {value: [key, value], writable: true});
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ?
            entry[1] : undefined;
      },
      delete: function(key) {
        this.set(key, undefined);
      }
    };

    window.WeakMap = WeakMap;
  })();
}

/*
 * Copyright 2012 The Polymer Authors. All rights reserved.
 * Use of this source code is goverened by a BSD-style
 * license that can be found in the LICENSE file.
 */

(function(global) {

  var registrationsTable = new WeakMap();

  // We use setImmediate or postMessage for our future callback.
  var setImmediate = window.msSetImmediate;

  // Use post message to emulate setImmediate.
  if (!setImmediate) {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener('message', function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, '*');
    };
  }

  // This is used to ensure that we never schedule 2 callas to setImmediate
  var isScheduled = false;

  // Keep track of observers that needs to be notified next time.
  var scheduledObservers = [];

  /**
   * Schedules |dispatchCallback| to be called in the future.
   * @param {MutationObserver} observer
   */
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }

  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill &&
        window.ShadowDOMPolyfill.wrapIfNeeded(node) ||
        node;
  }

  function dispatchCallbacks() {
    // http://dom.spec.whatwg.org/#mutation-observers

    isScheduled = false; // Used to allow a new setImmediate call above.

    var observers = scheduledObservers;
    scheduledObservers = [];
    // Sort observers based on their creation UID (incremental).
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });

    var anyNonEmpty = false;
    observers.forEach(function(observer) {

      // 2.1, 2.2
      var queue = observer.takeRecords();
      // 2.3. Remove all transient registered observers whose observer is mo.
      removeTransientObserversFor(observer);

      // 2.4
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });

    // 3.
    if (anyNonEmpty)
      dispatchCallbacks();
  }

  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations)
        return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer)
          registration.removeTransientObservers();
      });
    });
  }

  /**
   * This function is used for the "For each registered observer observer (with
   * observer's options as options) in target's list of registered observers,
   * run these substeps:" and the "For each ancestor ancestor of target, and for
   * each registered observer observer (with options options) in ancestor's list
   * of registered observers, run these substeps:" part of the algorithms. The
   * |options.subtree| is checked to ensure that the callback is called
   * correctly.
   *
   * @param {Node} target
   * @param {function(MutationObserverInit):MutationRecord} callback
   */
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);

      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;

          // Only target ignores subtree.
          if (node !== target && !options.subtree)
            continue;

          var record = callback(options);
          if (record)
            registration.enqueue(record);
        }
      }
    }
  }

  var uidCounter = 0;

  /**
   * The class that maps to the DOM MutationObserver interface.
   * @param {Function} callback.
   * @constructor
   */
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }

  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);

      // 1.1
      if (!options.childList && !options.attributes && !options.characterData ||

          // 1.2
          options.attributeOldValue && !options.attributes ||

          // 1.3
          options.attributeFilter && options.attributeFilter.length &&
              !options.attributes ||

          // 1.4
          options.characterDataOldValue && !options.characterData) {

        throw new SyntaxError();
      }

      var registrations = registrationsTable.get(target);
      if (!registrations)
        registrationsTable.set(target, registrations = []);

      // 2
      // If target's list of registered observers already includes a registered
      // observer associated with the context object, replace that registered
      // observer's options with options.
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }

      // 3.
      // Otherwise, add a new registered observer to target's list of registered
      // observers with the context object as the observer and options as the
      // options, and add target to context object's list of nodes on which it
      // is registered.
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }

      registration.addListeners();
    },

    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            // Each node can only have one registered observer associated with
            // this observer.
            break;
          }
        }
      }, this);
      this.records_ = [];
    },

    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };

  /**
   * @param {string} type
   * @param {Node} target
   * @constructor
   */
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }

  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  };

  // We keep track of the two (possibly one) records used in a single mutation.
  var currentRecord, recordWithOldValue;

  /**
   * Creates a record without |oldValue| and caches it as |currentRecord| for
   * later use.
   * @param {string} oldValue
   * @return {MutationRecord}
   */
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }

  /**
   * Gets or creates a record with |oldValue| based in the |currentRecord|
   * @param {string} oldValue
   * @return {MutationRecord}
   */
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue)
      return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }

  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }

  /**
   * @param {MutationRecord} record
   * @return {boolean} Whether the record represents a record from the current
   * mutation event.
   */
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }

  /**
   * Selects which record, if any, to replace the last record in the queue.
   * This returns |null| if no record should be replaced.
   *
   * @param {MutationRecord} lastRecord
   * @param {MutationRecord} newRecord
   * @param {MutationRecord}
   */
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord)
      return lastRecord;

    // Check if the the record we are adding represents the same record. If
    // so, we keep the one with the oldValue in it.
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
      return recordWithOldValue;

    return null;
  }

  /**
   * Class used to represent a registered observer.
   * @param {MutationObserver} observer
   * @param {Node} target
   * @param {MutationObserverInit} options
   * @constructor
   */
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }

  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;

      // There are cases where we replace the last record with the new record.
      // For example if the record represents the same mutation we need to use
      // the one with the oldValue. If we get same record (this can happen as we
      // walk up the tree) we ignore the new record.
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }

      records[length] = record;
    },

    addListeners: function() {
      this.addListeners_(this.target);
    },

    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes)
        node.addEventListener('DOMAttrModified', this, true);

      if (options.characterData)
        node.addEventListener('DOMCharacterDataModified', this, true);

      if (options.childList)
        node.addEventListener('DOMNodeInserted', this, true);

      if (options.childList || options.subtree)
        node.addEventListener('DOMNodeRemoved', this, true);
    },

    removeListeners: function() {
      this.removeListeners_(this.target);
    },

    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes)
        node.removeEventListener('DOMAttrModified', this, true);

      if (options.characterData)
        node.removeEventListener('DOMCharacterDataModified', this, true);

      if (options.childList)
        node.removeEventListener('DOMNodeInserted', this, true);

      if (options.childList || options.subtree)
        node.removeEventListener('DOMNodeRemoved', this, true);
    },

    /**
     * Adds a transient observer on node. The transient observer gets removed
     * next time we deliver the change records.
     * @param {Node} node
     */
    addTransientObserver: function(node) {
      // Don't add transient observers on the target itself. We already have all
      // the required listeners set up on the target.
      if (node === this.target)
        return;

      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations)
        registrationsTable.set(node, registrations = []);

      // We know that registrations does not contain this because we already
      // checked if node === this.target.
      registrations.push(this);
    },

    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];

      transientObservedNodes.forEach(function(node) {
        // Transient observers are never added to the target.
        this.removeListeners_(node);

        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            // Each node can only have one registered observer associated with
            // this observer.
            break;
          }
        }
      }, this);
    },

    handleEvent: function(e) {
      // Stop propagation since we are managing the propagation manually.
      // This means that other mutation events on the page will not work
      // correctly but that is by design.
      e.stopImmediatePropagation();

      switch (e.type) {
        case 'DOMAttrModified':
          // http://dom.spec.whatwg.org/#concept-mo-queue-attributes

          var name = e.attrName;
          var namespace = e.relatedNode.namespaceURI;
          var target = e.target;

          // 1.
          var record = new getRecord('attributes', target);
          record.attributeName = name;
          record.attributeNamespace = namespace;

          // 2.
          var oldValue =
              e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;

          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 3.1, 4.2
            if (!options.attributes)
              return;

            // 3.2, 4.3
            if (options.attributeFilter && options.attributeFilter.length &&
                options.attributeFilter.indexOf(name) === -1 &&
                options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            // 3.3, 4.4
            if (options.attributeOldValue)
              return getRecordWithOldValue(oldValue);

            // 3.4, 4.5
            return record;
          });

          break;

        case 'DOMCharacterDataModified':
          // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata
          var target = e.target;

          // 1.
          var record = getRecord('characterData', target);

          // 2.
          var oldValue = e.prevValue;


          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 3.1, 4.2
            if (!options.characterData)
              return;

            // 3.2, 4.3
            if (options.characterDataOldValue)
              return getRecordWithOldValue(oldValue);

            // 3.3, 4.4
            return record;
          });

          break;

        case 'DOMNodeRemoved':
          this.addTransientObserver(e.target);
          // Fall through.
        case 'DOMNodeInserted':
          // http://dom.spec.whatwg.org/#concept-mo-queue-childlist
          var target = e.relatedNode;
          var changedNode = e.target;
          var addedNodes, removedNodes;
          if (e.type === 'DOMNodeInserted') {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {

            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;

          // 1.
          var record = getRecord('childList', target);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;

          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 2.1, 3.2
            if (!options.childList)
              return;

            // 2.2, 3.3
            return record;
          });

      }

      clearRecords();
    }
  };

  global.JsMutationObserver = JsMutationObserver;

  // Provide unprefixed MutationObserver with native or JS implementation
  if (!global.MutationObserver && global.WebKitMutationObserver)
    global.MutationObserver = global.WebKitMutationObserver;

  if (!global.MutationObserver)
    global.MutationObserver = JsMutationObserver;


})(this);

/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

/**
 * Implements `document.register`
 * @module CustomElements
*/

/**
 * Polyfilled extensions to the `document` object.
 * @class Document
*/

(function(scope) {

// imports

if (!scope) {
  scope = window.CustomElements = {flags:{}};
}
var flags = scope.flags;

// native document.register?

var hasNative = Boolean(document.register);
var useNative = !flags.register && hasNative;

if (useNative) {

  // stub
  var nop = function() {};

  // exports
  scope.registry = {};
  scope.upgradeElement = nop;
  
  scope.watchShadow = nop;
  scope.upgrade = nop;
  scope.upgradeAll = nop;
  scope.upgradeSubtree = nop;
  scope.observeDocument = nop;
  scope.upgradeDocument = nop;
  scope.takeRecords = nop;

} else {

  /**
   * Registers a custom tag name with the document.
   *
   * When a registered element is created, a `readyCallback` method is called
   * in the scope of the element. The `readyCallback` method can be specified on
   * either `options.prototype` or `options.lifecycle` with the latter taking
   * precedence.
   *
   * @method register
   * @param {String} name The tag name to register. Must include a dash ('-'),
   *    for example 'x-component'.
   * @param {Object} options
   *    @param {String} [options.extends]
   *      (_off spec_) Tag name of an element to extend (or blank for a new
   *      element). This parameter is not part of the specification, but instead
   *      is a hint for the polyfill because the extendee is difficult to infer.
   *      Remember that the input prototype must chain to the extended element's
   *      prototype (or HTMLElement.prototype) regardless of the value of
   *      `extends`.
   *    @param {Object} options.prototype The prototype to use for the new
   *      element. The prototype must inherit from HTMLElement.
   *    @param {Object} [options.lifecycle]
   *      Callbacks that fire at important phases in the life of the custom
   *      element.
   *
   * @example
   *      FancyButton = document.register("fancy-button", {
   *        extends: 'button',
   *        prototype: Object.create(HTMLButtonElement.prototype, {
   *          readyCallback: {
   *            value: function() {
   *              console.log("a fancy-button was created",
   *            }
   *          }
   *        })
   *      });
   * @return {Function} Constructor for the newly registered type.
   */
  function register(name, options) {
    //console.warn('document.register("' + name + '", ', options, ')');
    // construct a defintion out of options
    // TODO(sjmiles): probably should clone options instead of mutating it
    var definition = options || {};
    if (!name) {
      // TODO(sjmiles): replace with more appropriate error (EricB can probably
      // offer guidance)
      throw new Error('document.register: first argument `name` must not be empty');
    }
    if (name.indexOf('-') < 0) {
      // TODO(sjmiles): replace with more appropriate error (EricB can probably
      // offer guidance)
      throw new Error('document.register: first argument (\'name\') must contain a dash (\'-\'). Argument provided was \'' + String(name) + '\'.');
    }
    // elements may only be registered once
    if (getRegisteredDefinition(name)) {
      throw new Error('DuplicateDefinitionError: a type with name \'' + String(name) + '\' is already registered');
    }
    // must have a prototype, default to an extension of HTMLElement
    // TODO(sjmiles): probably should throw if no prototype, check spec
    if (!definition.prototype) {
      // TODO(sjmiles): replace with more appropriate error (EricB can probably
      // offer guidance)
      throw new Error('Options missing required prototype property');
    }
    // record name
    definition.name = name.toLowerCase();
    // ensure a lifecycle object so we don't have to null test it
    definition.lifecycle = definition.lifecycle || {};
    // build a list of ancestral custom elements (for native base detection)
    // TODO(sjmiles): we used to need to store this, but current code only
    // uses it in 'resolveTagName': it should probably be inlined
    definition.ancestry = ancestry(definition.extends);
    // extensions of native specializations of HTMLElement require localName
    // to remain native, and use secondary 'is' specifier for extension type
    resolveTagName(definition);
    // some platforms require modifications to the user-supplied prototype
    // chain
    resolvePrototypeChain(definition);
    // overrides to implement attributeChanged callback
    overrideAttributeApi(definition.prototype);
    // 7.1.5: Register the DEFINITION with DOCUMENT
    registerDefinition(definition.name, definition);
    // 7.1.7. Run custom element constructor generation algorithm with PROTOTYPE
    // 7.1.8. Return the output of the previous step.
    definition.ctor = generateConstructor(definition);
    definition.ctor.prototype = definition.prototype;
    // force our .constructor to be our actual constructor
    definition.prototype.constructor = definition.ctor;
    // if initial parsing is complete
    if (scope.ready) {
      // upgrade any pre-existing nodes of this type
      scope.upgradeAll(document);
    }
    return definition.ctor;
  }

  function ancestry(extnds) {
    var extendee = getRegisteredDefinition(extnds);
    if (extendee) {
      return ancestry(extendee.extends).concat([extendee]);
    }
    return [];
  }

  function resolveTagName(definition) {
    // if we are explicitly extending something, that thing is our
    // baseTag, unless it represents a custom component
    var baseTag = definition.extends;
    // if our ancestry includes custom components, we only have a
    // baseTag if one of them does
    for (var i=0, a; (a=definition.ancestry[i]); i++) {
      baseTag = a.is && a.tag;
    }
    // our tag is our baseTag, if it exists, and otherwise just our name
    definition.tag = baseTag || definition.name;
    if (baseTag) {
      // if there is a base tag, use secondary 'is' specifier
      definition.is = definition.name;
    }
  }

  function resolvePrototypeChain(definition) {
    // if we don't support __proto__ we need to locate the native level
    // prototype for precise mixing in
    if (!Object.__proto__) {
      // default prototype
      var nativePrototype = HTMLElement.prototype;
      // work out prototype when using type-extension
      if (definition.is) {
        var inst = document.createElement(definition.tag);
        nativePrototype = Object.getPrototypeOf(inst);
      }
      // ensure __proto__ reference is installed at each point on the prototype
      // chain.
      // NOTE: On platforms without __proto__, a mixin strategy is used instead
      // of prototype swizzling. In this case, this generated __proto__ provides
      // limited support for prototype traversal.
      var proto = definition.prototype, ancestor;
      while (proto && (proto !== nativePrototype)) {
        var ancestor = Object.getPrototypeOf(proto);
        proto.__proto__ = ancestor;
        proto = ancestor;
      }
    }
    // cache this in case of mixin
    definition.native = nativePrototype;
  }

  // SECTION 4

  function instantiate(definition) {
    // 4.a.1. Create a new object that implements PROTOTYPE
    // 4.a.2. Let ELEMENT by this new object
    //
    // the custom element instantiation algorithm must also ensure that the
    // output is a valid DOM element with the proper wrapper in place.
    //
    return upgrade(domCreateElement(definition.tag), definition);
  }

  function upgrade(element, definition) {
    // some definitions specify an 'is' attribute
    if (definition.is) {
      element.setAttribute('is', definition.is);
    }
    // remove 'unresolved' attr, which is a standin for :unresolved.
    element.removeAttribute('unresolved');
    // make 'element' implement definition.prototype
    implement(element, definition);
    // flag as upgraded
    element.__upgraded__ = true;
    // there should never be a shadow root on element at this point
    // we require child nodes be upgraded before `created`
    scope.upgradeSubtree(element);
    // lifecycle management
    created(element);
    // OUTPUT
    return element;
  }

  function implement(element, definition) {
    // prototype swizzling is best
    if (Object.__proto__) {
      element.__proto__ = definition.prototype;
    } else {
      // where above we can re-acquire inPrototype via
      // getPrototypeOf(Element), we cannot do so when
      // we use mixin, so we install a magic reference
      customMixin(element, definition.prototype, definition.native);
      element.__proto__ = definition.prototype;
    }
  }

  function customMixin(inTarget, inSrc, inNative) {
    // TODO(sjmiles): 'used' allows us to only copy the 'youngest' version of
    // any property. This set should be precalculated. We also need to
    // consider this for supporting 'super'.
    var used = {};
    // start with inSrc
    var p = inSrc;
    // sometimes the default is HTMLUnknownElement.prototype instead of
    // HTMLElement.prototype, so we add a test
    // the idea is to avoid mixing in native prototypes, so adding
    // the second test is WLOG
    while (p !== inNative && p !== HTMLUnknownElement.prototype) {
      var keys = Object.getOwnPropertyNames(p);
      for (var i=0, k; k=keys[i]; i++) {
        if (!used[k]) {
          Object.defineProperty(inTarget, k,
              Object.getOwnPropertyDescriptor(p, k));
          used[k] = 1;
        }
      }
      p = Object.getPrototypeOf(p);
    }
  }

  function created(element) {
    // invoke createdCallback
    if (element.createdCallback) {
      element.createdCallback();
    }
  }

  // attribute watching

  function overrideAttributeApi(prototype) {
    // overrides to implement callbacks
    // TODO(sjmiles): should support access via .attributes NamedNodeMap
    // TODO(sjmiles): preserves user defined overrides, if any
    if (prototype.setAttribute._polyfilled) {
      return;
    }
    var setAttribute = prototype.setAttribute;
    prototype.setAttribute = function(name, value) {
      changeAttribute.call(this, name, value, setAttribute);
    }
    var removeAttribute = prototype.removeAttribute;
    prototype.removeAttribute = function(name) {
      changeAttribute.call(this, name, null, removeAttribute);
    }
    prototype.setAttribute._polyfilled = true;
  }

  // https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/
  // index.html#dfn-attribute-changed-callback
  function changeAttribute(name, value, operation) {
    var oldValue = this.getAttribute(name);
    operation.apply(this, arguments);
    var newValue = this.getAttribute(name);
    if (this.attributeChangedCallback
        && (newValue !== oldValue)) {
      this.attributeChangedCallback(name, oldValue, newValue);
    }
  }

  // element registry (maps tag names to definitions)

  var registry = {};

  function getRegisteredDefinition(name) {
    if (name) {
      return registry[name.toLowerCase()];
    }
  }

  function registerDefinition(name, definition) {
    registry[name] = definition;
  }

  function generateConstructor(definition) {
    return function() {
      return instantiate(definition);
    };
  }

  function createElement(tag, typeExtension) {
    // TODO(sjmiles): ignore 'tag' when using 'typeExtension', we could
    // error check it, or perhaps there should only ever be one argument
    var definition = getRegisteredDefinition(typeExtension || tag);
    if (definition) {
      return new definition.ctor();
    }
    return domCreateElement(tag);
  }

  function upgradeElement(element) {
    if (!element.__upgraded__ && (element.nodeType === Node.ELEMENT_NODE)) {
      var type = element.getAttribute('is') || element.localName;
      var definition = getRegisteredDefinition(type);
      return definition && upgrade(element, definition);
    }
  }

  function cloneNode(deep) {
    // call original clone
    var n = domCloneNode.call(this, deep);
    // upgrade the element and subtree
    scope.upgradeAll(n);
    // return the clone
    return n;
  }
  // capture native createElement before we override it

  var domCreateElement = document.createElement.bind(document);

  // capture native cloneNode before we override it

  var domCloneNode = Node.prototype.cloneNode;

  // exports

  document.register = register;
  document.createElement = createElement; // override
  Node.prototype.cloneNode = cloneNode; // override

  scope.registry = registry;

  /**
   * Upgrade an element to a custom element. Upgrading an element
   * causes the custom prototype to be applied, an `is` attribute 
   * to be attached (as needed), and invocation of the `readyCallback`.
   * `upgrade` does nothing if the element is already upgraded, or
   * if it matches no registered custom tag name.
   *
   * @method ugprade
   * @param {Element} element The element to upgrade.
   * @return {Element} The upgraded element.
   */
  scope.upgrade = upgradeElement;
}

scope.hasNative = hasNative;
scope.useNative = useNative;

})(window.CustomElements);

 /*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

(function(scope){

var logFlags = window.logFlags || {};

// walk the subtree rooted at node, applying 'find(element, data)' function
// to each element
// if 'find' returns true for 'element', do not search element's subtree
function findAll(node, find, data) {
  var e = node.firstElementChild;
  if (!e) {
    e = node.firstChild;
    while (e && e.nodeType !== Node.ELEMENT_NODE) {
      e = e.nextSibling;
    }
  }
  while (e) {
    if (find(e, data) !== true) {
      findAll(e, find, data);
    }
    e = e.nextElementSibling;
  }
  return null;
}

// walk all shadowRoots on a given node.
function forRoots(node, cb) {
  var root = node.shadowRoot;
  while(root) {
    forSubtree(root, cb);
    root = root.olderShadowRoot;
  }
}

// walk the subtree rooted at node, including descent into shadow-roots,
// applying 'cb' to each element
function forSubtree(node, cb) {
  //logFlags.dom && node.childNodes && node.childNodes.length && console.group('subTree: ', node);
  findAll(node, function(e) {
    if (cb(e)) {
      return true;
    }
    forRoots(e, cb);
  });
  forRoots(node, cb);
  //logFlags.dom && node.childNodes && node.childNodes.length && console.groupEnd();
}

// manage lifecycle on added node
function added(node) {
  if (upgrade(node)) {
    insertedNode(node);
    return true;
  }
  inserted(node);
}

// manage lifecycle on added node's subtree only
function addedSubtree(node) {
  forSubtree(node, function(e) {
    if (added(e)) {
      return true;
    }
  });
}

// manage lifecycle on added node and it's subtree
function addedNode(node) {
  return added(node) || addedSubtree(node);
}

// upgrade custom elements at node, if applicable
function upgrade(node) {
  if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
    var type = node.getAttribute('is') || node.localName;
    var definition = scope.registry[type];
    if (definition) {
      logFlags.dom && console.group('upgrade:', node.localName);
      scope.upgrade(node);
      logFlags.dom && console.groupEnd();
      return true;
    }
  }
}

function insertedNode(node) {
  inserted(node);
  if (inDocument(node)) {
    forSubtree(node, function(e) {
      inserted(e);
    });
  }
}


// TODO(sorvell): on platforms without MutationObserver, mutations may not be 
// reliable and therefore entered/leftView are not reliable.
// To make these callbacks less likely to fail, we defer all inserts and removes
// to give a chance for elements to be inserted into dom. 
// This ensures enteredViewCallback fires for elements that are created and 
// immediately added to dom.
var hasPolyfillMutations = (!window.MutationObserver ||
    (window.MutationObserver === window.JsMutationObserver));
scope.hasPolyfillMutations = hasPolyfillMutations;

var isPendingMutations = false;
var pendingMutations = [];
function deferMutation(fn) {
  pendingMutations.push(fn);
  if (!isPendingMutations) {
    isPendingMutations = true;
    var async = (window.Platform && window.Platform.endOfMicrotask) ||
        setTimeout;
    async(takeMutations);
  }
}

function takeMutations() {
  isPendingMutations = false;
  var $p = pendingMutations;
  for (var i=0, l=$p.length, p; (i<l) && (p=$p[i]); i++) {
    p();
  }
  pendingMutations = [];
}

function inserted(element) {
  if (hasPolyfillMutations) {
    deferMutation(function() {
      _inserted(element);
    });
  } else {
    _inserted(element);
  }
}

// TODO(sjmiles): if there are descents into trees that can never have inDocument(*) true, fix this
function _inserted(element) {
  // TODO(sjmiles): it's possible we were inserted and removed in the space
  // of one microtask, in which case we won't be 'inDocument' here
  // But there are other cases where we are testing for inserted without
  // specific knowledge of mutations, and must test 'inDocument' to determine
  // whether to call inserted
  // If we can factor these cases into separate code paths we can have
  // better diagnostics.
  // TODO(sjmiles): when logging, do work on all custom elements so we can
  // track behavior even when callbacks not defined
  //console.log('inserted: ', element.localName);
  if (element.enteredViewCallback || (element.__upgraded__ && logFlags.dom)) {
    logFlags.dom && console.group('inserted:', element.localName);
    if (inDocument(element)) {
      element.__inserted = (element.__inserted || 0) + 1;
      // if we are in a 'removed' state, bluntly adjust to an 'inserted' state
      if (element.__inserted < 1) {
        element.__inserted = 1;
      }
      // if we are 'over inserted', squelch the callback
      if (element.__inserted > 1) {
        logFlags.dom && console.warn('inserted:', element.localName,
          'insert/remove count:', element.__inserted)
      } else if (element.enteredViewCallback) {
        logFlags.dom && console.log('inserted:', element.localName);
        element.enteredViewCallback();
      }
    }
    logFlags.dom && console.groupEnd();
  }
}

function removedNode(node) {
  removed(node);
  forSubtree(node, function(e) {
    removed(e);
  });
}


function removed(element) {
  if (hasPolyfillMutations) {
    deferMutation(function() {
      _removed(element);
    });
  } else {
    _removed(element);
  }
}

function _removed(element) {
  // TODO(sjmiles): temporary: do work on all custom elements so we can track
  // behavior even when callbacks not defined
  if (element.leftViewCallback || (element.__upgraded__ && logFlags.dom)) {
    logFlags.dom && console.log('removed:', element.localName);
    if (!inDocument(element)) {
      element.__inserted = (element.__inserted || 0) - 1;
      // if we are in a 'inserted' state, bluntly adjust to an 'removed' state
      if (element.__inserted > 0) {
        element.__inserted = 0;
      }
      // if we are 'over removed', squelch the callback
      if (element.__inserted < 0) {
        logFlags.dom && console.warn('removed:', element.localName,
            'insert/remove count:', element.__inserted)
      } else if (element.leftViewCallback) {
        element.leftViewCallback();
      }
    }
  }
}

function inDocument(element) {
  var p = element;
  var doc = window.ShadowDOMPolyfill &&
      window.ShadowDOMPolyfill.wrapIfNeeded(document) || document;
  while (p) {
    if (p == doc) {
      return true;
    }
    p = p.parentNode || p.host;
  }
}

function watchShadow(node) {
  if (node.shadowRoot && !node.shadowRoot.__watched) {
    logFlags.dom && console.log('watching shadow-root for: ', node.localName);
    // watch all unwatched roots...
    var root = node.shadowRoot;
    while (root) {
      watchRoot(root);
      root = root.olderShadowRoot;
    }
  }
}

function watchRoot(root) {
  if (!root.__watched) {
    observe(root);
    root.__watched = true;
  }
}

function handler(mutations) {
  //
  if (logFlags.dom) {
    var mx = mutations[0];
    if (mx && mx.type === 'childList' && mx.addedNodes) {
        if (mx.addedNodes) {
          var d = mx.addedNodes[0];
          while (d && d !== document && !d.host) {
            d = d.parentNode;
          }
          var u = d && (d.URL || d._URL || (d.host && d.host.localName)) || '';
          u = u.split('/?').shift().split('/').pop();
        }
    }
    console.group('mutations (%d) [%s]', mutations.length, u || '');
  }
  //
  mutations.forEach(function(mx) {
    //logFlags.dom && console.group('mutation');
    if (mx.type === 'childList') {
      forEach(mx.addedNodes, function(n) {
        //logFlags.dom && console.log(n.localName);
        if (!n.localName) {
          return;
        }
        // nodes added may need lifecycle management
        addedNode(n);
      });
      // removed nodes may need lifecycle management
      forEach(mx.removedNodes, function(n) {
        //logFlags.dom && console.log(n.localName);
        if (!n.localName) {
          return;
        }
        removedNode(n);
      });
    }
    //logFlags.dom && console.groupEnd();
  });
  logFlags.dom && console.groupEnd();
};

var observer = new MutationObserver(handler);

function takeRecords() {
  // TODO(sjmiles): ask Raf why we have to call handler ourselves
  handler(observer.takeRecords());
  takeMutations();
}

var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);

function observe(inRoot) {
  observer.observe(inRoot, {childList: true, subtree: true});
}

function observeDocument(document) {
  observe(document);
}

function upgradeDocument(document) {
  logFlags.dom && console.group('upgradeDocument: ', (document.URL || document._URL || '').split('/').pop());
  addedNode(document);
  logFlags.dom && console.groupEnd();
}

// exports

scope.watchShadow = watchShadow;
scope.upgradeAll = addedNode;
scope.upgradeSubtree = addedSubtree;

scope.observeDocument = observeDocument;
scope.upgradeDocument = upgradeDocument;

scope.takeRecords = takeRecords;

})(window.CustomElements);

/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

(function() {

// import

var IMPORT_LINK_TYPE = window.HTMLImports ? HTMLImports.IMPORT_LINK_TYPE : 'none';

// highlander object for parsing a document tree

var parser = {
  selectors: [
    'link[rel=' + IMPORT_LINK_TYPE + ']'
  ],
  map: {
    link: 'parseLink'
  },
  parse: function(inDocument) {
    if (!inDocument.__parsed) {
      // only parse once
      inDocument.__parsed = true;
      // all parsable elements in inDocument (depth-first pre-order traversal)
      var elts = inDocument.querySelectorAll(parser.selectors);
      // for each parsable node type, call the mapped parsing method
      forEach(elts, function(e) {
        parser[parser.map[e.localName]](e);
      });
      // upgrade all upgradeable static elements, anything dynamically
      // created should be caught by observer
      CustomElements.upgradeDocument(inDocument);
      // observe document for dom changes
      CustomElements.observeDocument(inDocument);
    }
  },
  parseLink: function(linkElt) {
    // imports
    if (isDocumentLink(linkElt)) {
      this.parseImport(linkElt);
    }
  },
  parseImport: function(linkElt) {
    if (linkElt.content) {
      parser.parse(linkElt.content);
    }
  }
};

function isDocumentLink(inElt) {
  return (inElt.localName === 'link'
      && inElt.getAttribute('rel') === IMPORT_LINK_TYPE);
}

var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);

// exports

CustomElements.parser = parser;

})();
/*
 * Copyright 2013 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
(function(scope){

// bootstrap parsing
function bootstrap() {
  // parse document
  CustomElements.parser.parse(document);
  // one more pass before register is 'live'
  CustomElements.upgradeDocument(document);
  // choose async
  var async = window.Platform && Platform.endOfMicrotask ? 
    Platform.endOfMicrotask :
    setTimeout;
  async(function() {
    // set internal 'ready' flag, now document.register will trigger 
    // synchronous upgrades
    CustomElements.ready = true;
    // capture blunt profiling data
    CustomElements.readyTime = Date.now();
    if (window.HTMLImports) {
      CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;
    }
    // notify the system that we are bootstrapped
    document.body.dispatchEvent(
      new CustomEvent('WebComponentsReady', {bubbles: true})
    );
  });
}

// CustomEvent shim for IE
if (typeof window.CustomEvent !== 'function') {
  window.CustomEvent = function(inType) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(inType, true, true);
    return e;
  };
}

// When loading at readyState complete time (or via flag), boot custom elements
// immediately.
// If relevant, HTMLImports must already be loaded.
if (document.readyState === 'complete' || scope.flags.eager) {
  bootstrap();
// When loading at readyState interactive time, bootstrap only if HTMLImports
// are not pending. Also avoid IE as the semantics of this state are unreliable.
} else if (document.readyState === 'interactive' && !window.attachEvent &&
    (!window.HTMLImports || window.HTMLImports.ready)) {
  bootstrap();
// When loading at other readyStates, wait for the appropriate DOM event to 
// bootstrap.
} else {
  var loadEvent = window.HTMLImports ? 'HTMLImportsLoaded' : 'DOMContentLoaded';
  window.addEventListener(loadEvent, bootstrap);
}

})(window.CustomElements);

(function () {

/*** Variables ***/

  var win = window,
    doc = document,
    noop = function(){},
    trueop = function(){ return true; },
    regexPseudoSplit = /([\w-]+(?:\([^\)]+\))?)/g,
    regexPseudoReplace = /(\w*)(?:\(([^\)]*)\))?/,
    regexDigits = /(\d+)/g,
    keypseudo = {
      action: function (pseudo, event) {
        return pseudo.value.match(regexDigits).indexOf(String(event.keyCode)) > -1 == (pseudo.name == 'keypass') || null;
      }
    },
    prefix = (function () {
      var styles = win.getComputedStyle(doc.documentElement, ''),
          pre = (Array.prototype.slice
            .call(styles)
            .join('')
            .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
          )[1];
      return {
        dom: pre == 'ms' ? 'MS' : pre,
        lowercase: pre,
        css: '-' + pre + '-',
        js: pre == 'ms' ? pre : pre[0].toUpperCase() + pre.substr(1)
      };
    })(),
    matchSelector = Element.prototype.matchesSelector || Element.prototype[prefix.lowercase + 'MatchesSelector'],
    mutation = win.MutationObserver || win[prefix.js + 'MutationObserver'];

/*** Functions ***/

// Utilities

  var typeCache = {},
      typeString = typeCache.toString,
      typeRegexp = /\s([a-zA-Z]+)/;
  function typeOf(obj) {
    var type = typeString.call(obj);
    return typeCache[type] || (typeCache[type] = type.match(typeRegexp)[1].toLowerCase());
  }

  function clone(item, type){
    var fn = clone[type || typeOf(item)];
    return fn ? fn(item) : item;
  }
    clone.object = function(src){
      var obj = {};
      for (var key in src) obj[key] = clone(src[key]);
      return obj;
    };
    clone.array = function(src){
      var i = src.length, array = new Array(i);
      while (i--) array[i] = clone(src[i]);
      return array;
    };

  var unsliceable = ['undefined', 'null', 'number', 'boolean', 'string', 'function'];
  function toArray(obj){
    return unsliceable.indexOf(typeOf(obj)) == -1 ?
    Array.prototype.slice.call(obj, 0) :
    [obj];
  }

// DOM

  var str = '';
  function query(element, selector){
    return (selector || str).length ? toArray(element.querySelectorAll(selector)) : [];
  }

  function parseMutations(element, mutations) {
    var diff = { added: [], removed: [] };
    mutations.forEach(function(record){
      record._mutation = true;
      for (var z in diff) {
        var type = element._records[(z == 'added') ? 'inserted' : 'removed'],
          nodes = record[z + 'Nodes'], length = nodes.length;
        for (var i = 0; i < length && diff[z].indexOf(nodes[i]) == -1; i++){
          diff[z].push(nodes[i]);
          type.forEach(function(fn){
            fn(nodes[i], record);
          });
        }
      }
    });
  }

// Mixins

  function mergeOne(source, key, current){
    var type = typeOf(current);
    if (type == 'object' && typeOf(source[key]) == 'object') xtag.merge(source[key], current);
    else source[key] = clone(current, type);
    return source;
  }

  function wrapMixin(tag, key, pseudo, value, original){
    var fn = original[key];
    if (!(key in original)) original[key] = value;
    else if (typeof original[key] == 'function') {
      if (!fn.__mixins__) fn.__mixins__ = [];
      fn.__mixins__.push(xtag.applyPseudos(pseudo, value, tag.pseudos));
    }
  }

  var uniqueMixinCount = 0;
  function mergeMixin(tag, mixin, original, mix) {
    if (mix) {
      var uniques = {};
      for (var z in original) uniques[z.split(':')[0]] = z;
      for (z in mixin) {
        wrapMixin(tag, uniques[z.split(':')[0]] || z, z, mixin[z], original);
      }
    }
    else {
      for (var zz in mixin){
        original[zz + ':__mixin__(' + (uniqueMixinCount++) + ')'] = xtag.applyPseudos(zz, mixin[zz], tag.pseudos);
      }
    }
  }

  function applyMixins(tag) {
    tag.mixins.forEach(function (name) {
      var mixin = xtag.mixins[name];
      for (var type in mixin) {
        var item = mixin[type],
            original = tag[type];
        if (!original) tag[type] = item;
        else {
          switch (type){
            case 'accessors': case 'prototype':
              for (var z in item) {
                if (!original[z]) original[z] = item[z];
                else mergeMixin(tag, item[z], original[z], true);
              }
              break;
            default: mergeMixin(tag, item, original, type != 'events');
          }
        }
      }
    });
    return tag;
  }

// Events

  function delegateAction(pseudo, event) {
    var match, target = event.target;
    if (!target.tagName) return null;
    if (xtag.matchSelector(target, pseudo.value)) match = target;
    else if (xtag.matchSelector(target, pseudo.value + ' *')) {
      var parent = target.parentNode;
      while (!match) {
        if (xtag.matchSelector(parent, pseudo.value)) match = parent;
        parent = parent.parentNode;
      }
    }
    return match ? pseudo.listener = pseudo.listener.bind(match) : null;
  }

  function touchFilter(event) {
    if (event.type.match('touch')){
      event.target.__touched__ = true;
    }
    else if (event.target.__touched__ && event.type.match('mouse')){
      delete event.target.__touched__;
      return;
    }
    return true;
  }

  function createFlowEvent(type) {
    var flow = type == 'over';
    return {
      attach: 'OverflowEvent' in win ? 'overflowchanged' : [],
      condition: function (event, custom) {
        event.flow = type;
        return event.type == (type + 'flow') ||
        ((event.orient === 0 && event.horizontalOverflow == flow) ||
        (event.orient == 1 && event.verticalOverflow == flow) ||
        (event.orient == 2 && event.horizontalOverflow == flow && event.verticalOverflow == flow));
      }
    };
  }

  function writeProperty(key, event, base, desc){
    if (desc) event[key] = base[key];
    else Object.defineProperty(event, key, {
      writable: true,
      enumerable: true,
      value: base[key]
    });
  }

  var skipProps = {};
  for (var z in document.createEvent('CustomEvent')) skipProps[z] = 1;
  function inheritEvent(event, base){
    var desc = Object.getOwnPropertyDescriptor(event, 'target');
    for (var z in base) {
      if (!skipProps[z]) writeProperty(z, event, base, desc);
    }
    event.baseEvent = base;
  }

// Accessors

  function getArgs(attr, value){
    return {
      value: attr.boolean ? '' : value,
      method: attr.boolean && !value ? 'removeAttribute' : 'setAttribute'
    };
  }

  function modAttr(element, attr, name, value){
    var args = getArgs(attr, value);
    element[args.method](name, args.value);
  }

  function syncAttr(element, attr, name, value, method){
    var nodes = attr.property ? [element.xtag[attr.property]] : attr.selector ? xtag.query(element, attr.selector) : [],
        index = nodes.length;
    while (index--) nodes[index][method](name, value);
  }

  function updateView(element, name, value){
    if (element.__view__){
      element.__view__.updateBindingValue(element, name, value);
    }
  }

  function attachProperties(tag, prop, z, accessor, attr, name){
    var key = z.split(':'), type = key[0];
    if (type == 'get') {
      key[0] = prop;
      tag.prototype[prop].get = xtag.applyPseudos(key.join(':'), accessor[z], tag.pseudos, accessor[z]);
    }
    else if (type == 'set') {
      key[0] = prop;
      var setter = tag.prototype[prop].set = xtag.applyPseudos(key.join(':'), attr ? function(value){
        this.xtag._skipSet = true;
        if (!this.xtag._skipAttr) modAttr(this, attr, name, value);
        if (this.xtag._skipAttr && attr.skip) delete this.xtag._skipAttr;
        accessor[z].call(this, attr.boolean ? !!value : value);
        updateView(this, name, value);
        delete this.xtag._skipSet;
      } : accessor[z] ? function(value){
        accessor[z].call(this, value);
        updateView(this, name, value);
      } : null, tag.pseudos, accessor[z]);

      if (attr) attr.setter = setter;
    }
    else tag.prototype[prop][z] = accessor[z];
  }

  function parseAccessor(tag, prop){
    tag.prototype[prop] = {};
    var accessor = tag.accessors[prop],
        attr = accessor.attribute,
        name = attr && attr.name ? attr.name.toLowerCase() : prop;

    if (attr) {
      attr.key = prop;
      tag.attributes[name] = attr;
    }

    for (var z in accessor) attachProperties(tag, prop, z, accessor, attr, name);

    if (attr) {
      if (!tag.prototype[prop].get) {
        var method = (attr.boolean ? 'has' : 'get') + 'Attribute';
        tag.prototype[prop].get = function(){
          return this[method](name);
        };
      }
      if (!tag.prototype[prop].set) tag.prototype[prop].set = function(value){
        modAttr(this, attr, name, value);
        updateView(this, name, value);
      };
    }
  }

  var readyTags = {};
  function fireReady(name){
    readyTags[name] = (readyTags[name] || []).filter(function(obj){
      return (obj.tags = obj.tags.filter(function(z){
        return z != name && !xtag.tags[z];
      })).length || obj.fn();
    });
  }

/*** X-Tag Object Definition ***/

  var xtag = {
    tags: {},
    defaultOptions: {
      pseudos: [],
      mixins: [],
      events: {},
      methods: {},
      accessors: {},
      lifecycle: {},
      attributes: {},
      'prototype': {
        xtag: {
          get: function(){
            return this.__xtag__ ? this.__xtag__ : (this.__xtag__ = { data: {} });
          }
        }
      }
    },
    register: function (name, options) {
      var _name;
      if (typeof name == 'string') {
        _name = name.toLowerCase();
      } else {
        return;
      }

      // save prototype for actual object creation below
      var basePrototype = options.prototype;
      delete options.prototype;

      var tag = xtag.tags[_name] = applyMixins(xtag.merge({}, xtag.defaultOptions, options));

      for (var z in tag.events) tag.events[z] = xtag.parseEvent(z, tag.events[z]);
      for (z in tag.lifecycle) tag.lifecycle[z.split(':')[0]] = xtag.applyPseudos(z, tag.lifecycle[z], tag.pseudos, tag.lifecycle[z]);
      for (z in tag.methods) tag.prototype[z.split(':')[0]] = { value: xtag.applyPseudos(z, tag.methods[z], tag.pseudos, tag.methods[z]), enumerable: true };
      for (z in tag.accessors) parseAccessor(tag, z);

      var ready = tag.lifecycle.created || tag.lifecycle.ready;
      tag.prototype.createdCallback = {
        enumerable: true,
        value: function(){
          var element = this;
          xtag.addEvents(this, tag.events);
          tag.mixins.forEach(function(mixin){
            if (xtag.mixins[mixin].events) xtag.addEvents(element, xtag.mixins[mixin].events);
          });
          var output = ready ? ready.apply(this, arguments) : null;
          for (var name in tag.attributes) {
            var attr = tag.attributes[name],
                hasAttr = this.hasAttribute(name);
            if (hasAttr || attr.boolean) {
              this[attr.key] = attr.boolean ? hasAttr : this.getAttribute(name);
            }
          }
          tag.pseudos.forEach(function(obj){
            obj.onAdd.call(element, obj);
          });
          return output;
        }
      };

      if (tag.lifecycle.inserted) tag.prototype.enteredViewCallback = { value: tag.lifecycle.inserted, enumerable: true };
      if (tag.lifecycle.removed) tag.prototype.leftViewCallback = { value: tag.lifecycle.removed, enumerable: true };
      if (tag.lifecycle.attributeChanged) tag.prototype.attributeChangedCallback = { value: tag.lifecycle.attributeChanged, enumerable: true };

      var setAttribute = tag.prototype.setAttribute || HTMLElement.prototype.setAttribute;
      tag.prototype.setAttribute = {
        writable: true,
        enumberable: true,
        value: function (name, value){
          var attr = tag.attributes[name.toLowerCase()];
          if (!this.xtag._skipAttr) setAttribute.call(this, name, attr && attr.boolean ? '' : value);
          if (attr) {
            if (attr.setter && !this.xtag._skipSet) {
              this.xtag._skipAttr = true;
              attr.setter.call(this, attr.boolean ? true : value);
            }
            value = attr.skip ? attr.boolean ? this.hasAttribute(name) : this.getAttribute(name) : value;
            syncAttr(this, attr, name, attr.boolean ? '' : value, 'setAttribute');
          }
          delete this.xtag._skipAttr;
        }
      };

      var removeAttribute = tag.prototype.removeAttribute || HTMLElement.prototype.removeAttribute;
      tag.prototype.removeAttribute = {
        writable: true,
        enumberable: true,
        value: function (name){
          var attr = tag.attributes[name.toLowerCase()];
          if (!this.xtag._skipAttr) removeAttribute.call(this, name);
          if (attr) {
            if (attr.setter && !this.xtag._skipSet) {
              this.xtag._skipAttr = true;
              attr.setter.call(this, attr.boolean ? false : undefined);
            }
            syncAttr(this, attr, name, undefined, 'removeAttribute');
          }
          delete this.xtag._skipAttr;
        }
      };

      var elementProto = basePrototype ?
            basePrototype :
            options['extends'] ?
            Object.create(doc.createElement(options['extends']).constructor).prototype :
            win.HTMLElement.prototype;

      var definition = {
        'prototype': Object.create(elementProto, tag.prototype)
      };
      if (options['extends']) {
        definition['extends'] = options['extends'];
      }
      var reg = doc.register(_name, definition);
      fireReady(_name);
      return reg;
    },

    ready: function(names, fn){
      var obj = { tags: toArray(names), fn: fn };
      if (obj.tags.reduce(function(last, name){
        if (xtag.tags[name]) return last;
        (readyTags[name] = readyTags[name] || []).push(obj);
      }, true)) fn();
    },

    /* Exposed Variables */

    mixins: {},
    prefix: prefix,
    captureEvents: ['focus', 'blur', 'scroll', 'underflow', 'overflow', 'overflowchanged', 'DOMMouseScroll'],
    customEvents: {
      overflow: createFlowEvent('over'),
      underflow: createFlowEvent('under'),
      animationstart: {
        attach: [prefix.dom + 'AnimationStart']
      },
      animationend: {
        attach: [prefix.dom + 'AnimationEnd']
      },
      transitionend: {
        attach: [prefix.dom + 'TransitionEnd']
      },
      move: {
        attach: ['mousemove', 'touchmove'],
        condition: touchFilter
      },
      enter: {
        attach: ['mouseover', 'touchenter'],
        condition: touchFilter
      },
      leave: {
        attach: ['mouseout', 'touchleave'],
        condition: touchFilter
      },
      scrollwheel: {
        attach: ['DOMMouseScroll', 'mousewheel'],
        condition: function(event){
          event.delta = event.wheelDelta ? event.wheelDelta / 40 : Math.round(event.detail / 3.5 * -1);
          return true;
        }
      },
      tapstart: {
        observe: {
          mousedown: doc,
          touchstart: doc
        },
        condition: touchFilter
      },
      tapend: {
        observe: {
          mouseup: doc,
          touchend: doc
        },
        condition: touchFilter
      },
      tapmove: {
        attach: ['tapstart', 'dragend', 'touchcancel'],
        condition: function(event, custom){
          switch (event.type) {
            case 'move':  return true;
            case 'dragover':
              var last = custom.lastDrag || {};
              custom.lastDrag = event;
              return (last.pageX != event.pageX && last.pageY != event.pageY) || null;
            case 'tapstart':
              if (!custom.move) {
                custom.current = this;
                custom.move = xtag.addEvents(this, {
                  move: custom.listener,
                  dragover: custom.listener
                });
                custom.tapend = xtag.addEvent(doc, 'tapend', custom.listener);
              }
              break;
            case 'tapend': case 'dragend': case 'touchcancel':
              if (!event.touches.length) {
                if (custom.move) xtag.removeEvents(custom.current , custom.move || {});
                if (custom.tapend) xtag.removeEvent(doc, custom.tapend || {});
                delete custom.lastDrag;
                delete custom.current;
                delete custom.tapend;
                delete custom.move;
              }
          }
        }
      }
    },
    pseudos: {
      __mixin__: {},
      mixins: {
        onCompiled: function(fn, pseudo){
          var mixins = pseudo.source.__mixins__;
          if (mixins) switch (pseudo.value) {
            case 'before': return function(){
              var self = this,
                  args = arguments;
              mixins.forEach(function(m){
                m.apply(self, args);
              });
              return fn.apply(self, args);
            };
            case 'after': case null: return function(){
              var self = this,
                  args = arguments;
                  returns = fn.apply(self, args);
              mixins.forEach(function(m){
                m.apply(self, args);
              });
              return returns;
            };
          }
        }
      },
      keypass: keypseudo,
      keyfail: keypseudo,
      delegate: { action: delegateAction },
      within: {
        action: delegateAction,
        onAdd: function(pseudo){
          var condition = pseudo.source.condition;
          if (condition) pseudo.source.condition = function(event, custom){
            return xtag.query(this, pseudo.value).filter(function(node){
              return node == event.target || node.contains ? node.contains(event.target) : null;
            })[0] ? condition.call(this, event, custom) : null;
          };
        }
      },
      preventable: {
        action: function (pseudo, event) {
          return !event.defaultPrevented;
        }
      }
    },

    /* UTILITIES */

    clone: clone,
    typeOf: typeOf,
    toArray: toArray,

    wrap: function (original, fn) {
      return function(){
        var args = arguments,
            output = original.apply(this, args);
        fn.apply(this, args);
        return output;
      };
    },

    merge: function(source, k, v){
      if (typeOf(k) == 'string') return mergeOne(source, k, v);
      for (var i = 1, l = arguments.length; i < l; i++){
        var object = arguments[i];
        for (var key in object) mergeOne(source, key, object[key]);
      }
      return source;
    },

    uid: function(){
      return Math.random().toString(36).substr(2,10);
    },

    /* DOM */

    query: query,

    skipTransition: function(element, fn, bind){
      var prop = prefix.js + 'TransitionProperty';
      element.style[prop] = element.style.transitionProperty = 'none';
      var callback = fn ? fn.call(bind) : null;
      return xtag.requestFrame(function(){
        xtag.requestFrame(function(){
          element.style[prop] = element.style.transitionProperty = '';
          if (callback) xtag.requestFrame(callback);
        });
      });
    },

    requestFrame: (function(){
      var raf = win.requestAnimationFrame ||
                win[prefix.lowercase + 'RequestAnimationFrame'] ||
                function(fn){ return win.setTimeout(fn, 20); };
      return function(fn){ return raf(fn); };
    })(),

    cancelFrame: (function(){
      var cancel = win.cancelAnimationFrame ||
                   win[prefix.lowercase + 'CancelAnimationFrame'] ||
                   win.clearTimeout;
      return function(id){ return cancel(id); };
    })(),

    matchSelector: function (element, selector) {
      return matchSelector.call(element, selector);
    },

    set: function (element, method, value) {
      element[method] = value;
      if (window.CustomElements) CustomElements.upgradeAll(element);
    },

    innerHTML: function(el, html){
      xtag.set(el, 'innerHTML', html);
    },

    hasClass: function (element, klass) {
      return element.className.split(' ').indexOf(klass.trim())>-1;
    },

    addClass: function (element, klass) {
      var list = element.className.trim().split(' ');
      klass.trim().split(' ').forEach(function (name) {
        if (!~list.indexOf(name)) list.push(name);
      });
      element.className = list.join(' ').trim();
      return element;
    },

    removeClass: function (element, klass) {
      var classes = klass.trim().split(' ');
      element.className = element.className.trim().split(' ').filter(function (name) {
        return name && !~classes.indexOf(name);
      }).join(' ');
      return element;
    },

    toggleClass: function (element, klass) {
      return xtag[xtag.hasClass(element, klass) ? 'removeClass' : 'addClass'].call(null, element, klass);
    },

    queryChildren: function (element, selector) {
      var id = element.id,
        guid = element.id = id || 'x_' + xtag.uid(),
        attr = '#' + guid + ' > ';
      selector = attr + (selector + '').replace(',', ',' + attr, 'g');
      var result = element.parentNode.querySelectorAll(selector);
      if (!id) element.removeAttribute('id');
      return toArray(result);
    },

    createFragment: function(content) {
      var frag = doc.createDocumentFragment();
      if (content) {
        var div = frag.appendChild(doc.createElement('div')),
          nodes = toArray(content.nodeName ? arguments : !(div.innerHTML = content) || div.children),
          length = nodes.length,
          index = 0;
        while (index < length) frag.insertBefore(nodes[index++], div);
        frag.removeChild(div);
      }
      return frag;
    },

    manipulate: function(element, fn){
      var next = element.nextSibling,
        parent = element.parentNode,
        frag = doc.createDocumentFragment(),
        returned = fn.call(frag.appendChild(element), frag) || element;
      if (next) parent.insertBefore(returned, next);
      else parent.appendChild(returned);
    },

    /* PSEUDOS */

    applyPseudos: function(key, fn, target, source) {
      var listener = fn,
          pseudos = {};
      if (key.match(':')) {
        var split = key.match(regexPseudoSplit),
            i = split.length;
        while (--i) {
          split[i].replace(regexPseudoReplace, function (match, name, value) {
            if (!xtag.pseudos[name]) throw "pseudo not found: " + name + " " + split;
            var value = (value === '' || typeof value == 'undefined') ? null : value,
                pseudo = pseudos[i] = Object.create(xtag.pseudos[name]);
                pseudo.key = key;
                pseudo.name = name;
                pseudo.value = value;
                pseudo['arguments'] = (value || '').split(',');
                pseudo.action = pseudo.action || trueop;
                pseudo.source = source;
            var last = listener;
            listener = function(){
              var args = toArray(arguments),
                  obj = {
                    key: key,
                    name: name,
                    value: value,
                    source: source,
                    'arguments': pseudo['arguments'],
                    listener: last
                  };
              var output = pseudo.action.apply(this, [obj].concat(args));
              if (output === null || output === false) return output;
              return obj.listener.apply(this, args);
            };
            if (target && pseudo.onAdd) {
              if (target.nodeName) pseudo.onAdd.call(target, pseudo);
              else target.push(pseudo);
            }
          });
        }
      }
      for (var z in pseudos) {
        if (pseudos[z].onCompiled) listener = pseudos[z].onCompiled(listener, pseudos[z]) || listener;
      }
      return listener;
    },

    removePseudos: function(target, pseudos){
      pseudos.forEach(function(obj){
        if (obj.onRemove) obj.onRemove.call(target, obj);
      });
    },

  /*** Events ***/

    parseEvent: function(type, fn) {
      var pseudos = type.split(':'),
          key = pseudos.shift(),
          custom = xtag.customEvents[key],
          event = xtag.merge({
            type: key,
            stack: noop,
            condition: trueop,
            attach: [],
            _attach: [],
            pseudos: '',
            _pseudos: [],
            onAdd: noop,
            onRemove: noop
          }, custom || {});
      event.attach = toArray(event.base || event.attach);
      event.chain = key + (event.pseudos.length ? ':' + event.pseudos : '') + (pseudos.length ? ':' + pseudos.join(':') : '');
      var condition = event.condition;
      event.condition = function(e){
        var t = e.touches, tt = e.targetTouches;
        return condition.apply(this, arguments);
      };
      var stack = xtag.applyPseudos(event.chain, fn, event._pseudos, event);
      event.stack = function(e){
        e.currentTarget = e.currentTarget || this;
        var t = e.touches, tt = e.targetTouches;
        var detail = e.detail || {};
        if (!detail.__stack__) return stack.apply(this, arguments);
        else if (detail.__stack__ == stack) {
          e.stopPropagation();
          e.cancelBubble = true;
          return stack.apply(this, arguments);
        }
      };
      event.listener = function(e){
        var args = toArray(arguments),
            output = event.condition.apply(this, args.concat([event]));
        if (!output) return output;
        if (e.type != key) {
          xtag.fireEvent(e.target, key, {
            baseEvent: e,
            detail: output !== true && (output.__stack__ = stack) ? output : { __stack__: stack }
          });
        }
        else return event.stack.apply(this, args);
      };
      event.attach.forEach(function(name) {
        event._attach.push(xtag.parseEvent(name, event.listener));
      });
      if (custom && custom.observe && !custom.__observing__) {
        custom.observer = function(e){
          var output = event.condition.apply(this, toArray(arguments).concat([custom]));
          if (!output) return output;
          xtag.fireEvent(e.target, key, {
            baseEvent: e,
            detail: output !== true ? output : {}
          });
        };
        for (var z in custom.observe) xtag.addEvent(custom.observe[z] || document, z, custom.observer, true);
        custom.__observing__ = true;
      }
      return event;
    },

    addEvent: function (element, type, fn, capture) {
      var event = typeof fn == 'function' ? xtag.parseEvent(type, fn) : fn;
      event._pseudos.forEach(function(obj){
        obj.onAdd.call(element, obj);
      });
      event._attach.forEach(function(obj) {
        xtag.addEvent(element, obj.type, obj);
      });
      event.onAdd.call(element, event, event.listener);
      element.addEventListener(event.type, event.stack, capture || xtag.captureEvents.indexOf(event.type) > -1);
      return event;
    },

    addEvents: function (element, obj) {
      var events = {};
      for (var z in obj) {
        events[z] = xtag.addEvent(element, z, obj[z]);
      }
      return events;
    },

    removeEvent: function (element, type, event) {
      event = event || type;
      event.onRemove.call(element, event, event.listener);
      xtag.removePseudos(element, event._pseudos);
      event._attach.forEach(function(obj) {
        xtag.removeEvent(element, obj);
      });
      element.removeEventListener(event.type, event.stack);
    },

    removeEvents: function(element, obj){
      for (var z in obj) xtag.removeEvent(element, obj[z]);
    },

    fireEvent: function(element, type, options, warn){
      var event = doc.createEvent('CustomEvent');
      options = options || {};
      if (warn) console.warn('fireEvent has been modified');
      event.initCustomEvent(type,
        options.bubbles !== false,
        options.cancelable !== false,
        options.detail
      );
      if (options.baseEvent) inheritEvent(event, options.baseEvent);
      try { element.dispatchEvent(event); }
      catch (e) {
        console.warn('This error may have been caused by a change in the fireEvent method', e);
      }
    },

    addObserver: function(element, type, fn){
      if (!element._records) {
        element._records = { inserted: [], removed: [] };
        if (mutation){
          element._observer = new mutation(function(mutations) {
            parseMutations(element, mutations);
          });
          element._observer.observe(element, {
            subtree: true,
            childList: true,
            attributes: !true,
            characterData: false
          });
        }
        else ['Inserted', 'Removed'].forEach(function(type){
          element.addEventListener('DOMNode' + type, function(event){
            event._mutation = true;
            element._records[type.toLowerCase()].forEach(function(fn){
              fn(event.target, event);
            });
          }, false);
        });
      }
      if (element._records[type].indexOf(fn) == -1) element._records[type].push(fn);
    },

    removeObserver: function(element, type, fn){
      var obj = element._records;
      if (obj && fn){
        obj[type].splice(obj[type].indexOf(fn), 1);
      }
      else{
        obj[type] = [];
      }
    }

  };

/*** Universal Touch ***/

var touching = false,
    touchTarget = null;

doc.addEventListener('mousedown', function(e){
  touching = true;
  touchTarget = e.target;
}, true);

doc.addEventListener('mouseup', function(){
  touching = false;
  touchTarget = null;
}, true);

doc.addEventListener('dragend', function(){
  touching = false;
  touchTarget = null;
}, true);

var UIEventProto = {
  touches: {
    configurable: true,
    get: function(){
      return this.__touches__ ||
        (this.identifier = 0) ||
        (this.__touches__ = touching ? [this] : []);
    }
  },
  targetTouches: {
    configurable: true,
    get: function(){
      return this.__targetTouches__ || (this.__targetTouches__ =
        (touching && this.currentTarget &&
        (this.currentTarget == touchTarget ||
        (this.currentTarget.contains && this.currentTarget.contains(touchTarget)))) ? (this.identifier = 0) || [this] : []);
    }
  },
  changedTouches: {
    configurable: true,
    get: function(){
      return this.__changedTouches__ || (this.identifier = 0) || (this.__changedTouches__ = [this]);
    }
  }
};

for (z in UIEventProto){
  UIEvent.prototype[z] = UIEventProto[z];
  Object.defineProperty(UIEvent.prototype, z, UIEventProto[z]);
}


/*** Custom Event Definitions ***/

  function addTap(el, tap, e){
    if (!el.__tap__) {
      el.__tap__ = { click: e.type == 'mousedown' };
      if (el.__tap__.click) el.addEventListener('click', tap.observer);
      else {
        el.__tap__.scroll = tap.observer.bind(el);
        window.addEventListener('scroll', el.__tap__.scroll, true);
        el.addEventListener('touchmove', tap.observer);
        el.addEventListener('touchcancel', tap.observer);
        el.addEventListener('touchend', tap.observer);
      }
    }
    if (!el.__tap__.click) {
      el.__tap__.x = e.touches[0].pageX;
      el.__tap__.y = e.touches[0].pageY;
    }
  }

  function removeTap(el, tap){
    if (el.__tap__) {
      if (el.__tap__.click) el.removeEventListener('click', tap.observer);
      else {
        window.removeEventListener('scroll', el.__tap__.scroll, true);
        el.removeEventListener('touchmove', tap.observer);
        el.removeEventListener('touchcancel', tap.observer);
        el.removeEventListener('touchend', tap.observer);
      }
      delete el.__tap__;
    }
  }

  function checkTapPosition(el, tap, e){
    var touch = e.changedTouches[0],
        tol = tap.gesture.tolerance;
    if (
      touch.pageX < el.__tap__.x + tol &&
      touch.pageX > el.__tap__.x - tol &&
      touch.pageY < el.__tap__.y + tol &&
      touch.pageY > el.__tap__.y - tol
    ) return true;
  }

  xtag.customEvents.tap = {
    observe: {
      mousedown: document,
      touchstart: document
    },
    gesture: {
      tolerance: 8
    },
    condition: function(e, tap){
      var el = e.target;
      switch (e.type) {
        case 'touchstart':
          if (el.__tap__ && el.__tap__.click) removeTap(el, tap);
          addTap(el, tap, e);
          return;
        case 'mousedown':
          if (!el.__tap__) addTap(el, tap, e);
          return;
        case 'scroll':
        case 'touchcancel':
          removeTap(this, tap);
          return;
        case 'touchmove':
        case 'touchend':
          if (this.__tap__ && !checkTapPosition(this, tap, e)) {
            removeTap(this, tap);
            return;
          }
          return e.type == 'touchend' || null;
        case 'click':
          removeTap(this, tap);
          return true;
      }
    }
  };

  win.xtag = xtag;
  if (typeof define == 'function' && define.amd) define(xtag);

  doc.addEventListener('WebComponentsReady', function(){
    xtag.fireEvent(doc.body, 'DOMComponentsLoaded');
  });

})();/*
x-tag for making a fan of options - choosing one hides the rest, unchoosing it re-reveals all options
hacks: 
1.  x-blade dimensions are fixed in css for transitions
*/

(function(){  

    xtag.register('x-fan', {
        lifecycle: {
            created: function() {
                //the fan starts life unlocked and not knowing what it wants:
                this.buffer = { 'selected' : null,
                                'locked' : false};
            },
            inserted: function() {},
            removed: function() {},
            attributeChanged: function() {}
        }, 
        events: { 

        },
        accessors: {
            //selected attribute indicates what choice, if any, has been made for the fan
            'selected':{ 
                get: function(){
                    return this.buffer.selected
                },

                set: function(value){
                    //if the fan is locked, bail out instantly:
                    if(this.buffer.locked) return;

                    if(this.buffer.selected != value){
                        //a new blade has been chosen - fade the other ones out.
                        var i;

                        //register the set value in buffer.selected
                        this.buffer.selected = value;

                        for(i=0; i<this.childNodes.length; i++){
                            //hide all the other blades by setting thier class to 'hidden'
                            if(this.childNodes[i].id != value && this.childNodes[i].tagName == 'X-BLADE')
                                this.childNodes[i].className = 'hidden';
                        }
                        //highlight the chosen blade with the 'chosen' class, and call its set callback - 2nd loop to ensure cb happens last
                        for(i=0; i<this.childNodes.length; i++){
                            if(this.childNodes[i].id == value && this.childNodes[i].tagName == 'X-BLADE'){
                                this.childNodes[i].className = 'chosen';
                                this.childNodes[i].setCallback;
                            }
                        }
    
                    } else{
                        //return the fan to an agnostic state:
                        this.buffer.selected = null;

                        //blade is being unselected - present all blades by removing special classes
                        for(i=0; i<this.childNodes.length; i++){
                            if(this.childNodes[i].tagName == 'X-BLADE'){
                                this.childNodes[i].className = '';
                                this.childNodes[i].style = '';
                                this.childNodes[i].style.overflow = 'visible';
                            }
                        }
                        //call the unset callback for the blade being deselected - 2nd loop to ensure cb happens last
                        for(i=0; i<this.childNodes.length; i++){
                            if(this.childNodes[i].tagName == 'X-BLADE' && this.childNodes[i].id == value){
                                this.childNodes[i].unsetCallback;
                            }
                        }

                    }                    
                }
            },

            //if true, don't allow this fan to change its state
            'locked':{
                get: function(){
                    return this.buffer.locked;
                },

                set: function(value){
                    this.buffer.locked = value;
                }
            }
        }, 
        methods: {

        }
    });

})();

(function(){  

    xtag.register('x-blade', {
        lifecycle: {
            created: function() {
                this.buffer = {};
            },
            inserted: function() {},
            removed: function() {},
            attributeChanged: function() {}
        }, 
        events: { 
            click: function(){
                //set the fan's selected id - triggers all transition animations and set / unset callbacks
                this.parentNode.selected = this.id;
            },

            webkitTransitionEnd: function(){
                if(this.className == 'hidden'){
                    this.style.overflow = 'hidden'
                }
            }
        },
        accessors: {
            'setCallback' : {
                get : function(){
                    if(this.buffer.setCallback)
                        this.buffer.setCallback();
                },

                set : function(value){
                    this.buffer.setCallback = value;
                }
            },
            'unsetCallback' : {
                get : function(){
                    if(this.buffer.unsetCallback)
                        this.buffer.unsetCallback();
                },

                set : function(value){
                    this.buffer.unsetCallback = value;
                }
            }

        }, 
        methods: {

        }
    });

})();

//x-altmodal inspired by x-tags x-modal, but less fancy & easier to make work :)
(function(){  

    xtag.register('x-altmodal', {
        lifecycle: {
            created: function() {
                var that = this;
                //starts life asleep:
                this.buffer = {'active' : false};
                //has its dismiss button living inside it:
                this.innerHTML += '<button id="'+this.id+'Dismiss", class="altmodalDismiss">Dismiss</button>'
                document.getElementById(this.id+'Dismiss').onclick = function(){
                    that.active = false;
                }
            },
            inserted: function() {

            },
            removed: function() {},
            attributeChanged: function() {}
        }, 
        events: { 
            click: function(){
                //set the fan's selected id - triggers all transition animations and set / unset callbacks
                this.parentNode.selected = this.id;
            },

            webkitTransitionEnd: function(){
                if(this.className == 'hiddenModal'){
                    this.style.zIndex = -1000;
                } else if(this.className == 'activeModal'){
                    this.style.zIndex = 1000;
                }
            }
        },
        accessors: {
            'active' : {
                get : function(){
                    return this.buffer.active;
                },

                set : function(value){
                    this.buffer.active = value;
                    if(this.buffer.active)
                        this.className = 'activeModal';
                    else 
                        this.className = 'hiddenModal';
                }
            },
        }, 
        methods: {
        }
    });
})();