//SHARC////////////////////////////////////////////////////////////
//SHARC assets: x0, y0 = center of shape
//Quad back summary - azimuthal segments, colors sorted azimuthally
quadBack = function(context, x0, y0, innerRad, outerRad, squish, colors, TT){
    
    var angularStep = (2*Math.PI)/colors.length;

    for(i=0; i<colors.length; i++){
        azimuthalSegment(context, x0, y0, innerRad, outerRad, angularStep, Math.PI-(i+1)*angularStep, squish, colors[i], TT);
    }

}

//draws a wedge shaped segment
azimuthalSegment = function(context, x0, y0, innerRad, outerRad, arc, orientation, squish, color, TT){
    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    context.save();
    context.translate(x0, y0);
    context.scale(1,squish);
    context.rotate(-orientation);
    context.beginPath();
    context.arc(0,0,innerRad, 0, -arc, true);
    context.lineTo(outerRad*Math.cos(arc), -outerRad*Math.sin(arc));
    context.arc(0,0,outerRad, -arc, 0, false);
    context.closePath();
    context.fill();
    context.stroke();
    context.restore();
}

//Quad front summary - radial segments.  Colors should be sorted first by array position (ie quadrant), then by smallest to largest radius.
quadFront = function(context, x0, y0, innerRad, outerRad, squish, colors, TT){

    var radStep = (outerRad - innerRad)/4;

    for(i=0; i<colors.length; i++){
        annularSegment(context, x0, y0, innerRad+(i%4)*radStep, innerRad + ((i%4)+1)*radStep, Math.PI/2, Math.PI/2*Math.floor(i/4), squish, colors[i], TT);
    }

}

//draws a macaroni-shaped segment that extends <arc> radians CCW from angle <orientation>
annularSegment = function(context, x0, y0, innerRad, outerRad, arc, orientation, squish, color, TT){
    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    context.save();
    context.translate(x0, y0);
    context.scale(-1,squish);
    context.rotate(-orientation);
    context.beginPath();
    context.arc(0,0,innerRad, 0, -arc, true);
    context.lineTo(outerRad*Math.cos(arc), -outerRad*Math.sin(arc));
    context.arc(0,0,outerRad, -arc, 0, false);
    context.closePath();
    context.fill();
    context.stroke();
    context.restore();

}

//stack of four horizontal parallelograms for summary view; colors stack bottom to top:
horizStack = function(context, X0, Y0, width, height, colors, pitch, TT){
    var i, y0, x0, dX, dY, stripWidth;

    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    //for the pads:
    if(colors.length==1){
        horizPara(context, X0, Y0, width, height, colors[0], pitch, TT);  
        return;
    }

    if(pitch == 'h'){
        //center of first strip:
        y0 = Y0 + 1.5*height/4,
        x0 = X0 - 1.5*height/4*Math.tan(Math.PI/6),
        dX = height/4*Math.tan(Math.PI/6),
        dY = height/4;
        for(i=0; i<4; i++){
            horizPara(context, x0+i*dX, y0-i*dY, width - 0.75*height*Math.tan(Math.PI/6), height/4, colors[i], pitch, TT );
        }
    } else {
        stripWidth = (height-width*Math.tan(Math.PI/6))/4;
        x0 = X0;
        y0 = Y0 + 1.5*stripWidth;
        dY = stripWidth;
        dX = 0;
        for(i=0; i<4; i++){
            horizPara(context, x0+i*dX, y0-i*dY, width, (height-width*Math.tan(Math.PI/6))/4+width*Math.tan(Math.PI/6), colors[i], pitch, TT );
        }
    }



}

//paralellogram with horizontal stripes - pitch = 'h' for top and bottom parallel to x or 'v' for left and right parallel to y
horizPara = function(context, x0, y0, width, height, color, pitch, TT){

    var theta = Math.PI/6,
        yLength, xLength,
        //cx, cy coords of bottom left corner
        cx = x0 - width/2,
        cy = y0 + height/2;

    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.beginPath();
    context.moveTo(cx,cy);
    if(pitch == 'h'){
        yLength = height / Math.cos(theta);
        xLength = width - height*Math.tan(theta);
        context.lineTo(cx + height*Math.tan(theta), cy - height);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+xLength, cy);
    } else{
        xLength = width / Math.cos(theta);
        yLength = height - width*Math.tan(theta);
        context.lineTo(cx, cy-yLength);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+width, cy - (height-yLength) )
    }
    context.closePath();
    context.fill();
    context.stroke();

}

//stack of four vertical parallelograms for summary view; colors stack left to right:
vertStack = function(context, X0, Y0, width, height, colors, pitch, TT){
    var i, y0, x0, dX, dY, stripWidth;

    context.strokeStyle = ( (TT) ? '#123456' : '#999999' );

    //for the pads:
    if(colors.length==1){
        vertPara(context, X0, Y0, width, height, colors[0], pitch, TT);  
        return;
    }

    if(pitch == 'h'){
        //center of first strip:
        y0 = Y0,
        x0 = X0 - 1.5*(width - height*Math.tan(Math.PI/6))/4,
        dX = (width - height*Math.tan(Math.PI/6))/4,
        dY = 0;
        for(i=0; i<4; i++){
            vertPara(context, x0+i*dX, y0, (width + 3*height*Math.tan(Math.PI/6))/4, height, colors[i], pitch, TT );
        }
    } else {
        stripWidth = width/4/Math.cos(Math.PI/6);
        dY = stripWidth*Math.sin(Math.PI/6);
        dX = width/4;
        x0 = X0 - 1.5*dX;
        y0 = Y0 + 1.5*dY;
        for(i=0; i<4; i++){
            vertPara(context, x0+i*dX, y0-i*dY, width/4, (height-0.75*width*Math.tan(Math.PI/6)), colors[i], pitch, TT );
        }
    }



}

//paralellogram with vertical stripes
vertPara = function(context, x0, y0, width, height, color, pitch, TT){

    var theta = Math.PI/6,
        yLength, xLength,
        //cx, cy coords of bottom left corner
        cx = x0 - width/2,
        cy = y0 + height/2;

    context.fillStyle = (color==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : color;
    context.beginPath();
    context.moveTo(cx,cy);
    if(pitch == 'h'){
        yLength = height / Math.cos(theta);
        xLength = width - height*Math.tan(theta);
        context.lineTo(cx + height*Math.tan(theta), cy - height);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+xLength, cy);
    } else{
        xLength = width / Math.cos(theta);
        yLength = height - width*Math.tan(theta);
        context.lineTo(cx, cy-yLength);
        context.lineTo(cx+width, cy-height);
        context.lineTo(cx+width, cy - (height-yLength) )
    }
    context.closePath();
    context.fill();
    context.stroke();

}

radialQuadrant = function(context, x0, y0, innerRad, outerRad, arc, orientation, colors, TT){
    var i,
        segments = colors.length,
        radStep = (outerRad - innerRad) / segments;

    context.save();
    context.translate(x0,y0);
    context.rotate(orientation);

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<segments; i++){
        context.fillStyle = colors[i];
        context.beginPath();
        context.arc(0,0,innerRad + i*radStep, -arc/2, arc/2, false);
        context.arc(0,0,innerRad + (i+1)*radStep, arc/2, -arc/2, true);
        context.closePath();
        context.fill();
        context.stroke();
    }

    context.restore();

}

azimuthalQuadrant = function(context, x0, y0, innerRad, outerRad, arc, orientation, colors, TT){
    var i,
        segments = colors.length,
        angleStep = arc / segments;

    context.save();
    context.translate(x0,y0);
    context.rotate(orientation);

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<segments; i++){
        context.fillStyle = colors[i];
        context.beginPath();
        context.arc(0,0,innerRad, -arc/2 + i*angleStep, -arc/2 + (i+1)*angleStep  , false);
        context.arc(0,0,outerRad, -arc/2 + (i+1)*angleStep, -arc/2 + i*angleStep, true);
        context.closePath();
        context.fill();
        context.stroke();
    }

    context.restore();

}

boxFront = function(context, x0,y0, height, width, colors, TT){
    var i,
        nStrips = colors.length,
        stripWidth = height/nStrips;

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<nStrips; i++){
        context.fillStyle = (colors[i]==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : colors[i];
        context.fillRect(x0, y0+i*stripWidth, width, stripWidth);
        context.strokeRect(x0, y0+i*stripWidth, width, stripWidth);
    }
}

boxBack = function(context, x0,y0, height, width, colors, TT){
    var i,
        nStrips = colors.length,
        stripWidth = width/nStrips;

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';

    for(i=0; i<nStrips; i++){
        context.fillStyle = (colors[i]==0xDEADBEEF) ? context.createPattern(window.parameters.warningFill, 'repeat') : colors[i];
        context.fillRect(x0+i*stripWidth, y0, stripWidth, height);
        context.strokeRect(x0+i*stripWidth, y0, stripWidth, height);
    }
}

padSummaries = function(context, x0, y0, scale, colors, TT){

    //outline cell or suppress antialiasing, as appropriate
    if(TT)
        context.strokeStyle = '#123456';
    else
        context.strokeStyle = '#999999';   

    context.fillStyle = colors[0];
    context.fillRect(x0-1.5*scale, y0-scale/2, scale, scale);
    context.strokeRect(x0-1.5*scale, y0-scale/2, scale, scale);

    context.fillStyle = colors[1];
    context.fillRect(x0+0.5*scale, y0-scale/2, scale, scale);
    context.strokeRect(x0+0.5*scale, y0-scale/2, scale, scale);    

}

//draw elliptical arc:
ellipse = function(context, centerX, centerY, horizRadius, startAngle, endAngle){
    context.save();
    context.translate(centerX, centerY);
    context.scale(1, 0.3);
    context.beginPath();
    context.arc(0, 0, horizRadius, 2*Math.PI - startAngle, 2*Math.PI - endAngle);
    context.restore();
    context.closePath();
    context.stroke();
}

//draw spokes from center ellipse to outer ellipse
ellipseSpoke = function(context, centerX, centerY, horizRadiusInner, horizRadiusOuter, phase, nSpokes, spokeNumber){

    //angle between spokes
    var sectionArc = 2*Math.PI / nSpokes;
    //angle of this spoke; recall the internet counts its angles backwards :(
    var phi = 2*Math.PI - (phase + spokeNumber*sectionArc);

    context.save();
    context.translate(centerX, centerY);
    context.scale(1, 0.3);
    //context.beginPath();
    context.moveTo(horizRadiusInner*Math.cos(phi), horizRadiusInner*Math.sin(phi));
    context.lineTo(horizRadiusOuter*Math.cos(phi), horizRadiusOuter*Math.sin(phi));
    context.restore();
    context.stroke();

}

//color in a particular annular section
fillAnnularSection = function(drawOption, context, centerX, centerY, innerRadius, outerRadius, startAngle, endAngle){

    context.save();
    context.translate(centerX, centerY);
    context.scale(1, 0.3);
    context.beginPath();
    context.moveTo(innerRadius*Math.cos(2*Math.PI - startAngle), innerRadius*Math.sin(2*Math.PI - startAngle));
    context.arc(0, 0, innerRadius, 2*Math.PI - startAngle, 2*Math.PI - endAngle, true);
    context.lineTo(outerRadius*Math.cos(2*Math.PI - endAngle), outerRadius*Math.sin(2*Math.PI - endAngle));
    context.arc(0, 0, outerRadius, 2*Math.PI - endAngle, 2*Math.PI - startAngle, false);
    context.closePath();
    context.restore();
    if(drawOption == 'fill' || drawOption == 'both') context.fill();
    if(drawOption == 'stroke' || drawOption == 'both')context.stroke();

}

//DESCANT////////////////////////////////////////////////////////////////////////////////////////

hex = function(context, centerX, centerY, side, phi){

    var i;

    //center to vertex distance:
    var spoke = side / 2 / Math.sin(Math.PI/6);

    //find coords of 6 vertices relative to center:
    var x = [];
    var y = [];

    for(i=0; i<6; i++){
        x[i] = spoke*Math.cos(phi + i*Math.PI/3);
        y[i] = spoke*Math.sin(phi + i*Math.PI/3);

        //alert(x[i]+' '+y[i]);
    }

    //draw hexagon:
    context.save();
    context.translate(centerX, centerY);
    context.beginPath();
    context.moveTo(x[0], y[0]);
    for(i=1; i<7; i++){
        context.lineTo(x[i%6], y[i%6]);
    }
    context.restore();
    context.stroke();

}

whiteDetector = function(context, centerX, centerY, scale, phi, bkg){
    context.strokeStyle = '#999999';//'rgba(255,255,255,1)';
    context.save();
    context.translate(centerX, centerY);
    context.beginPath();
    context.moveTo(scale*41.5, scale*(71.9));
    context.lineTo(scale*(-41.5), scale*(71.9));
    context.lineTo(scale*(-93), 0);
    context.lineTo(scale*(-41.5), scale*(-79.6));
    context.lineTo(scale*41.5, scale*(-79.6));
    context.lineTo(scale*93, 0);
    context.closePath();
    context.restore();
    context.fill();
    if(bkg == 0)context.stroke();
}

redDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999'; //'rgba(255,0,0,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(rotation);
    context.beginPath();
    context.moveTo(scale*37.4, scale*(-87.1));
    context.lineTo(scale*(-51.6), scale*(-83.3));
    context.lineTo(scale*(-101.8), 0);
    context.lineTo(scale*(-51.6), scale*(83.3));
    context.lineTo(scale*37.4, scale*(87.1));
    context.lineTo(scale*73.1, 0);
    context.closePath();
    context.restore();
    context.fill();
    if(bkg == 0)context.stroke();
}

blueDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999';//'rgba(0,150,255,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(rotation);
    context.beginPath();
    context.moveTo(scale*52.6, scale*(-79.4));
    context.lineTo(scale*(-45.1), scale*(-79.4));
    context.lineTo(scale*(-97.6), 0);
    context.lineTo(scale*(-45.1), scale*(79.4));
    context.lineTo(scale*52.6, scale*(79.4));
    context.lineTo(scale*99.2, 0);
    context.closePath();
    context.restore();
    context.fill();
    if(bkg == 0)context.stroke();
}

greenLeftDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999';//'rgba(0,255,0,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(-1*Math.PI/2 + rotation);
    context.beginPath();
    context.moveTo(scale*41.5, scale*(-71.9));
    context.lineTo(scale*(-41.5), scale*(-71.9));
    context.lineTo(scale*(-93), 0);
    context.lineTo(scale*(-41.5), scale*(79.6));
    context.lineTo(scale*41.5, scale*(79.6));
    context.lineTo(scale*62.3, scale*47.6);
    context.closePath();
    context.restore();  
    context.fill();
    if(bkg == 0)context.stroke(); 
}

greenRightDetector = function(context, centerX, centerY, scale, phi, rotation, bkg){
    context.strokeStyle = '#999999';//'rgba(0,255,0,1)'
    context.save();
    context.translate(centerX, centerY);
    context.rotate(Math.PI/2 + rotation);
    context.beginPath();
    context.moveTo(scale*41.5, scale*(-71.9));
    context.lineTo(scale*(-41.5), scale*(-71.9));
    context.lineTo(scale*(-62.3), scale*47.6);
    context.lineTo(scale*(-41.5), scale*(79.6));
    context.lineTo(scale*41.5, scale*(79.6));
    context.lineTo(scale*93, 0);
    context.closePath();
    context.restore();   
    context.fill();
    if(bkg == 0)context.stroke();
}

//Color Scales///////////////////////////////////////////////////////////////////////////////////

//map [0,1] onto [#000000, #FF0000]
redScale = function(scale){
    var R = scale*255;
    return constructHexColor([R,0,0]);
}

//map [0,1] onto [#000000, #0000FF]
blueScale = function(scale){
    var B = scale*255;
    return constructHexColor([0,0,B]);
}

//map [0,1] onto [#000000, #00FF00]
greenScale = function(scale){
    var G = scale*255;
    return constructHexColor([0,G,0]);
}

colorScale = function(colors,scale){
    return constructHexColor([scale*(colors[3]-colors[0])+colors[0], scale*(colors[4]-colors[1])+colors[1], scale*(colors[5]-colors[2])+colors[2]]);
}

//map [0,1] onto various color scales
scalepickr = function(scale, palette){
    //map scale onto [0,360]:
    var H = scale*300 / 60;
    if(H>5) H=5;
    if(H<0) H=0;
    var R, G, B;
    var start0, start1, start2, start3, start4, start5;
    if (palette == 'Sunset'){
        start0 = [0,0,0];
        start1 = [0,0,0x52];
        start2 = [0xE6,0,0x5C];
        start3 = [255,255,0];        
        start4 = [255,0x66,0];
        start5 = [255,0,0];        
    } else if (palette == 'ROOT Rainbow'){
        start0 = [0xFF,0x00,0x00];
        start1 = [0xFF,0xFF,0x00];
        start2 = [0x00,0xFF,0x00];
        start3 = [0x00,0xFF,0xFF];
        start4 = [0x00,0x00,0xFF];
        start5 = [0x66,0x00,0xCC];
        H = -1*(H-5);
    } else if (palette == 'Greyscale'){
        start0 = [0x00,0x00,0x00];
        start1 = [0x22,0x22,0x22];
        start2 = [0x55,0x55,0x55];
        start3 = [0x88,0x88,0x88];        
        start4 = [0xBB,0xBB,0xBB];
        start5 = [0xFF,0xFF,0xFF];
    } else if (palette == 'Red Scale'){
        start0 = [0x00,0x00,0x00];
        start1 = [0x33,0x00,0x00];
        start2 = [0x66,0x00,0x00];
        start3 = [0x99,0x00,0x00];
        start4 = [0xCC,0x00,0x00];
        start5 = [0xFF,0x00,0x00];
    } else if (palette == 'Mayfair'){
        start0 = [0x1E,0x4B,0x0F];
        start1 = [0x0E,0xBE,0x57];
        start2 = [0xE4,0xAB,0x33];
        start3 = [0xEC,0x95,0xF7];
        start4 = [0x86,0x19,0x4A];
        start5 = [0xFF,0x10,0x10];
    } else if (palette == 'Test'){
        start0 = [0x5E,0x1F,0x14];
        start1 = [0x74,0x4D,0x3E];
        start2 = [0x9D,0x47,0x05];
        start3 = [0xDF,0x67,0x19];
        start4 = [0xFE,0x83,0x54];
        start5 = [0x251,0x15,0x29];
    }
    if(H>=0 && H<1){
        R = start0[0] + Math.round(H*(start1[0]-start0[0]));
        G = start0[1] + Math.round(H*(start1[1]-start0[1]));
        B = start0[2] + Math.round(H*(start1[2]-start0[2]));
    } else if(H>=1 && H<2){
        R = start1[0] + Math.round((H-1)*(start2[0]-start1[0]));
        G = start1[1] + Math.round((H-1)*(start2[1]-start1[1]));
        B = start1[2] + Math.round((H-1)*(start2[2]-start1[2]));
    } else if(H>=2 && H<3){
        R = start2[0] + Math.round((H-2)*(start3[0]-start2[0]));
        G = start2[1] + Math.round((H-2)*(start3[1]-start2[1]));
        B = start2[2] + Math.round((H-2)*(start3[2]-start2[2]));
    } else if(H>=3 && H<4){
        R = start3[0] + Math.round((H-3)*(start4[0]-start3[0]));
        G = start3[1] + Math.round((H-3)*(start4[1]-start3[1]));
        B = start3[2] + Math.round((H-3)*(start4[2]-start3[2]));
    } else if(H>=4 && H<=5){
        R = start4[0] + Math.round((H-4)*(start5[0]-start4[0]));
        G = start4[1] + Math.round((H-4)*(start5[1]-start4[1]));
        B = start4[2] + Math.round((H-4)*(start5[2]-start4[2]));  
    }

    return constructHexColor([R,G,B]);

}

//Misc///////////////////////////////////////////////////////////////////////////


function interpolateColor(oldColor, newColor, scale){
    var R, G, B;

    if(oldColor == 0xDEADBEEF || newColor == 0xDEADBEEF) return 0xDEADBEEF;

    R = Math.round((newColor[0] - oldColor[0])*scale + oldColor[0]);
    G = Math.round((newColor[1] - oldColor[1])*scale + oldColor[1]);
    B = Math.round((newColor[2] - oldColor[2])*scale + oldColor[2]);

    return 'rgba('+R+','+G+','+B+',1)';
}

function roundBox(context, leftX, topY, width, height, cornerRadius){
    
    context.moveTo(leftX, topY+cornerRadius);
    context.beginPath();
    context.arc(leftX+cornerRadius, topY+cornerRadius, cornerRadius, Math.PI, 3*Math.PI/2);
    context.lineTo(leftX+width-cornerRadius,topY);
    context.arc(leftX+width-cornerRadius, topY+cornerRadius, cornerRadius, 3*Math.PI/2, 0);
    context.lineTo(leftX+width, topY+height-cornerRadius);
    context.arc(leftX+width-cornerRadius, topY+height-cornerRadius, cornerRadius, 0, Math.PI/2);
    context.lineTo(leftX + cornerRadius, topY+height);
    context.arc(leftX+cornerRadius, topY+height-cornerRadius, cornerRadius, Math.PI/2, Math.PI);
    context.closePath();
}

function strokePolygon(context, nSides, x0, y0, spoke, phi){
    var i;
    context.save();
    context.translate(x0, y0);
    context.rotate(phi);
    context.moveTo(0, -spoke);
    for(i=0; i<nSides; i++){
        context.rotate(2*Math.PI/nSides);
        context.lineTo(0, -spoke);
    }
    context.stroke();
    context.restore();
}

//take a hex color string '#012345' and parse it into [R,G,B]
function parseHexColor(color){
    var R, G, B;

    if(color==0xDEADBEEF) return 0xDEADBEEF
        
    var number = String(color).slice(1,7)

    R = parseInt(number.slice(0,2), 16);
    G = parseInt(number.slice(2,4), 16);
    B = parseInt(number.slice(4,6), 16);

    return [R,G,B];
}

//invert the above function:
function constructHexColor(color){
    var R = Math.round(color[0]);
    var G = Math.round(color[1]);
    var B = Math.round(color[2]);

    R = R.toString(16);
    G = G.toString(16);
    B = B.toString(16);

    if(R.length == 1) R = '0'+R;
    if(G.length == 1) G = '0'+G;
    if(B.length == 1) B = '0'+B;

    return '#'+R+G+B;
}
/*
//draw a nicer sidebar background
function tabBKG(canvasID, side){

    var canvas = document.getElementById(canvasID);
    var context = canvas.getContext('2d');

    var width = $(canvas).width();
    var height = $(canvas).height();
    //console.log(canvasID + ': ' + height)
    var cornerRad = 20;
    var tailRad = 50;
    var lineWeight = 2;

    context.clearRect(0,0,width,height);

    if(side == 'left'){
        context.save()
        context.translate(width,0);
        context.scale(-1,1);   
    }

    context.fillStyle = '#4C4C4C';
    context.lineWidth = lineWeight;
    context.beginPath();
    context.moveTo(width,lineWeight);
    context.lineTo(cornerRad, lineWeight);
    context.arc(cornerRad+lineWeight, cornerRad+lineWeight, cornerRad, -Math.PI/2, -Math.PI, true);
    context.lineTo(lineWeight, height - cornerRad - tailRad);
    context.arc(cornerRad+lineWeight, height - tailRad - cornerRad, cornerRad, -Math.PI, Math.PI/2, true);
    context.lineTo(width - tailRad, height - tailRad);
    context.arc(width - tailRad, height, tailRad, -Math.PI/2, 0);
    context.closePath();
    context.fill();
    context.stroke();

    if(side== 'left'){
        context.restore();
    }

}
*/
//atom spinner:
function drawSpinner(canvasID, label){
    
    var canvas = document.getElementById(canvasID);
    var context = canvas.getContext('2d');
    var string = (label) ? label : 'LOADING';

        $('#spinner').css('left', window.innerWidth/2 - 100);
        $('#spinner').css('top', window.innerHeight/2 - 100);

    context.lineWidth = 5;
    context.strokeStyle = '#FFFFFF';
    context.fillStyle = 'rgba(0,0,0,0.7)';
    roundBox(context, 5, 5, 190, 190, 5);
    context.lineWidth = 1;
    context.fill();
    context.stroke();

    context.fillStyle = '#FFFFFF';
    context.font = '16px Arial'
    context.fillText(string, 100-context.measureText(string).width/2, 145);
    window.nProtons = 0;
    window.nNucleons = 0;

/*
    window.spinLoop = setInterval(function(){
        context = document.getElementById('spinner').getContext('2d');

        //choose proton or neutron:
        var nucleon = (Math.random() < 0.5) ? 'p' : 'n';
        window.nNucleons++;
        if(nucleon == 'p') window.nProtons++;
        //choose position on canvas
        var radius = Math.random()*15;
        var phi = Math.random()*Math.PI*2;

        //draw:
        context.strokeStyle = '#FFFFFF';
        context.fillStyle = (nucleon == 'p') ? '#FF0000' : '#0000FF';
        context.beginPath();
        context.arc(100+radius*Math.cos(phi), 100+radius*Math.sin(phi), 5, 0, Math.PI*2);
        context.closePath();
        context.fill();
        context.stroke();

        context.clearRect(20,20, 160, 55);
        context.fillStyle = 'rgba(0,0,0,0.7)'
        context.fillRect(20,20, 160, 55);
        context.fillStyle = '#FFFFFF';
        context.fillText('Z = '+window.nProtons, 70-context.measureText('Z = '+window.nProtons).width/2, 70);
        context.fillText('A = '+window.nNucleons, 130-context.measureText('N = '+window.nProtons).width/2, 70);

    }, 3);
*/    
}

function curveText(text, context, x0, y0, rad, startAngle){
    var textWidth = context.measureText(text).width,
        charRotation = startAngle,
        character, charWidth, nextChar, nextWidth, bothWidth, kern, extraRotation, charSegment;

    for (var i=0, l=text.length; i<l; i++) {
        character = nextChar || text[i];
        charWidth = nextWidth || context.measureText(character).width;

        // Rotate so the letter base makes a circle segment instead of a tangent
        extraRotation = (Math.PI/2) - Math.acos((charWidth/2) / rad);

        context.save();
        context.translate(x0, y0);
        context.rotate(charRotation);
        context.translate(0, -rad);
        context.rotate(extraRotation);
        context.fillText(character,0,0);
        context.restore();

        nextChar = text[i+1] || '';
        nextWidth = context.measureText(nextChar).width;

        bothWidth = context.measureText(character+nextChar).width;
        kern = bothWidth - charWidth - nextWidth;

        charSegment = (charWidth+kern) / textWidth; // percent of total text size this takes up
        charRotation += charSegment * (context.measureText(text).width/rad);
    }           
}

function arrow(context, x0, y0, x1, y1, headScale){
    context.beginPath();
    context.moveTo(x0,y0);
    context.lineTo(x1,y1);

    context.save();
    context.translate(x1, y1);
    context.rotate(Math.atan((x1-x0)/(y1-y0)));
    context.moveTo(-headScale, headScale);
    context.lineTo(0,0);
    context.lineTo(headScale, headScale);
    context.restore();
}

function closeX(context, x0, y0, radius){
    context.strokeStyle = '#FFFFFF';
    context.fillStyle = '#FF0000';
    context.lineWidth = 1;

    context.beginPath();
    context.arc(x0, y0, radius, 0, Math.PI*2, true);
    context.closePath();
    context.fill();
    context.stroke();

    context.beginPath();
    context.lineWidth = 1;
    context.moveTo(x0 - 0.4*radius, y0 - 0.4*radius);
    context.lineTo(x0 + 0.4*radius, y0 + 0.4*radius);
    context.stroke();
    
    context.moveTo(x0 + 0.4*radius, y0 - 0.4*radius);
    context.lineTo(x0 - 0.4*radius, y0 + 0.4*radius);
    context.stroke();
}

//draws a digit like on an old digital clock.  cells is an array describing which cells
//are lit, indexed 0-5 around the edge starting on top, and 6 for the middle bar.
function digitalDigit(cells, context, height, x0, y0){

    var cellWidth = 0.05*height,
        width = 0.5*height,
        cellHeight = 0.5*height;

    context.save();
    context.setTransform(1, -Math.tan(Math.PI/12), 0, 1, 0, 0);
    context.rotate(Math.tan(Math.PI/12));

    if(cells[0]){
        context.beginPath();
        context.moveTo(x0+cellWidth, y0);
        context.lineTo(x0+cellWidth+width, y0);
        context.lineTo(x0+width, y0+cellWidth);
        context.lineTo(x0+2*cellWidth, y0+cellWidth);
        context.closePath();
        context.fill();
    }

    if(cells[1]){
        context.beginPath();
        context.moveTo(x0+width+2*cellWidth, y0+cellWidth);
        context.lineTo(x0+width+2*cellWidth, y0+cellWidth+cellHeight);
        context.lineTo(x0+width+cellWidth, y0+cellHeight);
        context.lineTo(x0+width+cellWidth, y0+2*cellWidth);
        context.closePath();
        context.fill();
    }

    if(cells[2]){
        context.beginPath();
        context.moveTo(x0+width+2*cellWidth, y0+3*cellWidth+cellHeight);
        context.lineTo(x0+width+2*cellWidth, y0+3*cellWidth+2*cellHeight);
        context.lineTo(x0+width+cellWidth, y0+2*cellWidth+2*cellHeight);
        context.lineTo(x0+width+cellWidth, y0+4*cellWidth+cellHeight);     
        context.closePath();
        context.fill();   
    }

    if(cells[3]){
        context.beginPath();
        context.moveTo(x0+cellWidth+width, y0+4*cellWidth+2*cellHeight);
        context.lineTo(x0+cellWidth, y0+4*cellWidth+2*cellHeight);
        context.lineTo(x0+2*cellWidth, y0+3*cellWidth+2*cellHeight);
        context.lineTo(x0+width, y0+3*cellWidth+2*cellHeight);
        context.closePath();
        context.fill();
    }

    if(cells[4]){
        context.beginPath();
        context.moveTo(x0, y0+3*cellWidth+cellHeight);
        context.lineTo(x0, y0+3*cellWidth+2*cellHeight);
        context.lineTo(x0+cellWidth, y0+2*cellWidth+2*cellHeight);
        context.lineTo(x0+cellWidth, y0+4*cellWidth+cellHeight);
        context.closePath();
        context.fill();
    }

    if(cells[5]){
        context.beginPath();
        context.moveTo(x0, y0+cellWidth+cellHeight);
        context.lineTo(x0, y0+cellWidth);
        context.lineTo(x0+cellWidth, y0+2*cellWidth);
        context.lineTo(x0+cellWidth, y0+cellHeight);
        context.closePath();
        context.fill();
    }

    if(cells[6]){
        context.beginPath();
        context.moveTo(x0+cellWidth, y0+2*cellWidth+cellHeight);
        context.lineTo(x0+2*cellWidth, y0+1.5*cellWidth+cellHeight);
        context.lineTo(x0+width, y0+1.5*cellWidth+cellHeight);
        context.lineTo(x0+width+cellWidth, y0+2*cellWidth+cellHeight);
        context.lineTo(x0+width, y0+2.5*cellWidth+cellHeight);
        context.lineTo(x0+2*cellWidth, y0+2.5*cellWidth+cellHeight);
        context.closePath();
        context.fill();
    }

    context.restore();

}

//draw a flow-chart like branch
//    |         x0, y0
//    ---       
//      |       
//  ----------  x1, y1
//  |  |  |  |  combLength
//context == context to draw in
//combColors == array containing color of each comb end; length = number of comb tines (4 in ascii art above)
//combWidth == width of base of comb in px
//combLength length of tines
//branchColor == color of 3 branch segments and comb spine
//x0, y0 == coordinates of branch root
//x1, y1 == coordinates of branch / comb join
function drawBranch(context, combColors, combWidth, combLength, branchColor, x0, y0, x1, y1){

    var nTine = combColors.length,
        tineSpacing = combWidth / (nTine-1),
        branchHeight = y1-y0;
        branchWidth = x1-x0;
        i;

    //draw branch and spine of comb:
    context.strokeStyle = branchColor;
    context.beginPath();
    context.moveTo(x0, y0);
    context.lineTo(x0, y0 + branchHeight/2);
    context.lineTo(x0 + branchWidth, y0 + branchHeight/2);
    context.lineTo(x0 + branchWidth, y0 + branchHeight);
    context.moveTo(x0 + branchWidth - combWidth / 2 - parseFloat(context.lineWidth)/2, y0 + branchHeight);
    context.lineTo(x0 + branchWidth + combWidth / 2 + parseFloat(context.lineWidth)/2, y0 + branchHeight);
    context.stroke();

    //draw tines
    for(i=0; i<nTine; i++){
        context.strokeStyle = combColors[i];
        context.beginPath();
        context.moveTo(x0 + branchWidth - combWidth / 2 + i*tineSpacing, y0 + branchHeight + parseFloat(context.lineWidth)/2);
        context.lineTo(x0 + branchWidth - combWidth / 2 + i*tineSpacing, y0 + branchHeight + combLength);
        context.stroke();
    }
}
function configure(detector){
	if(detector == 'SHARC'){
		minmaxTable('SHARCdiv', 'SHARC');
	} else if(detector == 'HPGe'){
		minmaxTable('HPGediv', 'HPGe');
		minmaxTable('HPGediv', 'HPGe BGO');
	} else if(detector == 'DESCANT'){
		minmaxTable('DESCANTdiv', 'DESCANT');
	} else if(detector == 'PACES'){
		minmaxTable('PACESdiv', 'PACES');
	} else if(detector == 'DANTE'){
		minmaxTable('DANTEdiv', 'DANTE LaBrPMT');
		minmaxTable('DANTEdiv', 'DANTE LaBrTAC');
		minmaxTable('DANTEdiv', 'DANTE BGO');
		document.getElementById('DANTE LaBrPMTTabletitleCell').innerHTML = 'DANTE LaBr PMT Scale Limits';
		document.getElementById('DANTE LaBrTACTabletitleCell').innerHTML = 'DANTE LaBr TAC Scale Limits';
	} else if(detector == 'BAMBINO'){
		//S2 or S3 mode:
		injectDOM('p', 'BAMBINOmodeLabel', 'BAMBINOdiv', {
			'style' : 'float:left; text-align:center; padding-right:20px; margin-top:70px',
			'innerHTML' : 'BAMBINO Mode<br>'
		});
		injectDOM('p', 'S2label', 'BAMBINOmodeLabel', {'style':'display:inline', 'innerHTML':'S2'});
		injectDOM('input', 'BAMBINOmodeS2', 'BAMBINOmodeLabel', {'name':'BAMBINOmode', 'type':'radio', 'value':'S2'});
		injectDOM('p', 'S3label', 'BAMBINOmodeLabel', {'style':'display:inline; margin-left:10px;', 'innerHTML':'S3'});
		injectDOM('input', 'BAMBINOmodeS3', 'BAMBINOmodeLabel', {'name':'BAMBINOmode', 'type':'radio', 'value':'S3', 'checked':true});
		//scale table:
		minmaxTable('BAMBINOdiv', 'BAMBINO');
		injectDOM('br', 'break', 'BAMBINOdiv', {});
		//upstream / downstream options
		injectDOM('p', 'BAMBINOupstreamLabel', 'BAMBINOdiv', {'style':'float:left; text-align:right;', 'innerHTML':'Upstream'});
		injectDOM('input', 'BAMBINOupstreamCheck', 'BAMBINOupstreamLabel', {
			'style':'float:left', 
			'type':'checkbox', 
			'value':'deploy', 
			'checked': (window.experiment == 'TIGRESS') ? true : false, 
		});
		document.getElementById('BAMBINOupstreamCheck').onchange = function(){checkBAMBINO()};
		injectDOM('p', 'BAMBINOdownstreamLabel', 'BAMBINOdiv', {'style':'float:left; text-align:right;', 'innerHTML':'Downstream'});
		injectDOM('input', 'BAMBINOdownstreamCheck', 'BAMBINOdownstreamLabel', {
			'style':'float:left; margin-left:10px', 
			'type':'checkbox', 
			'value':'deploy', 
			'checked':true, 
		});
		document.getElementById('BAMBINOdownstreamCheck').onchange = function(){checkBAMBINO()}; 
		//groups of checkboxes are a pain for validation, do it in JS:
		//document.getElementById('BAMBINOupstreamCheck').onchange = function(){checkBAMBINO()};
		//document.getElementById('BAMBINOdownstreamCheck').onchange = function(){checkBAMBINO()};
		//one or two layers:
		injectDOM('p', 'BAMBINOlayerLabel', 'BAMBINOdiv', {'style':'float:left; text-align:center; margin-left:30px;', 'innerHTML': 'Layers: '});
		injectDOM('p', 'singleLayerLabel', 'BAMBINOlayerLabel', {'style':'display:inline;', 'innerHTML':'Single'});
		injectDOM('input', 'BAMBINOsingleLayer', 'BAMBINOlayerLabel', {
			'name':'BAMBINOlayer', 
			'type':'radio', 
			'value':'single', 
			'checked':true
		});
		injectDOM('p', 'doubleLayerLabel', 'BAMBINOlayerLabel', {'style':'display:inline; margin-left:10px;', 'innerHTML':'Double'});
		injectDOM('input', 'BAMBINOdoubleLayer', 'BAMBINOlayerLabel', {'name':'BAMBINOlayer', 'type':'radio', 'value':'double'});


	} else if(detector == 'SCEPTAR'){
		minmaxTable('SCEPTARdiv', 'SCEPTAR');
	} else if(detector == 'ZDS'){
		minmaxTable('ZDSdiv', 'ZDS');
	} else if(detector == 'SPICE'){
		//only need all the other stuff in TIGRESS - GRIFFIN gives the SPICE aux it's own dialog
		if(window.experiment == 'TIGRESS'){
			//S2 or S3 auxiliary:
			injectDOM('p', 'SPICEmodeLabel', 'SPICEdiv', {
				'style' : 'float:left; text-align:center; padding-right:20px; margin-top:70px',
				'innerHTML' : 'SPICE Auxiliary Mode<br>'
			});
			injectDOM('p', 'S2label', 'SPICEmodeLabel', {'style':'display:inline', 'innerHTML':'S2'});
			injectDOM('input', 'SPICEmodeS2', 'SPICEmodeLabel', {'name':'SPICEmode', 'type':'radio', 'value':'S2', 'checked':true});
			document.getElementById('SPICEmodeS2').onchange = function(){hideSPICEaux()};
			injectDOM('p', 'S3label', 'SPICEmodeLabel', {'style':'display:inline; margin-left:10px;', 'innerHTML':'S3'});
			injectDOM('input', 'SPICEmodeS3', 'SPICEmodeLabel', {'name':'SPICEmode', 'type':'radio', 'value':'S3'});
			document.getElementById('SPICEmodeS3').onchange = function(){hideSPICEaux()};
			injectDOM('p', 'noAuxlabel', 'SPICEmodeLabel', {'style':'display:inline; margin-left:10px;', 'innerHTML':'none'});
			injectDOM('input', 'SPICEnoAux', 'SPICEmodeLabel', {'name':'SPICEmode', 'type':'radio', 'value':'none'});
			document.getElementById('SPICEnoAux').onchange = function(){hideSPICEaux()};
		}

		minmaxTable('SPICEdiv', 'SPICE');

		//again, only for TIGRESS
		if(window.experiment == 'TIGRESS'){
			//one or two auxiliary layers:
			injectDOM('br', 'break', 'SPICEmodeLabel', {});
			injectDOM('p', 'SPICElayerLabel', 'SPICEmodeLabel', {'style':'float:left; text-align:center;', 'innerHTML':'Aux. Layers: '});
			injectDOM('p', 'singleLayerLabel', 'SPICElayerLabel', {'style':'display:inline;', 'innerHTML':'Single'});
			injectDOM('input', 'SPICEsingleLayer', 'SPICElayerLabel', {'name':'SPICElayer', 'type':'radio', 'value':'single', 'checked':true});
			injectDOM('p', 'doubleLayerLabel', 'SPICElayerLabel', {'style':'display:inline; margin-left:10px;', 'innerHTML':'Double'});
			injectDOM('input', 'SPICEdoubleLayer', 'SPICElayerLabel', {'name':'SPICElayer', 'type':'radio', 'value':'double'});
		}

	} else if(detector == 'TIPwall'){
		minmaxTable('TIPwalldiv', 'TIPwall');
	} else if(detector == 'TIPball'){
		minmaxTable('TIPballdiv', 'TIPball');
	}	
}

function hideSPICEaux(){
	if(!document.getElementById('SPICEnoAux').checked){
		document.getElementById('SPICElayerLabel').style.display = 'block';
		document.getElementById('singleLayerLabel').style.display = 'inline';
		document.getElementById('SPICEsingleLayer').style.display = 'inline';
		document.getElementById('doubleLayerLabel').style.display = 'inline';
		document.getElementById('SPICEdoubleLayer').style.display = 'inline';
	} else{
		document.getElementById('SPICElayerLabel').style.display = 'none';
		document.getElementById('singleLayerLabel').style.display = 'none';
		document.getElementById('SPICEsingleLayer').style.display = 'none';
		document.getElementById('doubleLayerLabel').style.display = 'none';
		document.getElementById('SPICEdoubleLayer').style.display = 'none';
	}
}

function minmaxTable(wrapper, detType){

	var id = detType + 'Table';

	//wrap elements in a table
	injectDOM('table', id, wrapper, {'class':'minmaxtable',});
	//title
	injectDOM('tr', id+'titleRow', id, {});
	injectDOM('td', 'spacer', id+'titleRow', {});
	injectDOM('td', id+'titleCell', id+'titleRow', {'colspan':2, 'innerHTML':((detType) ? detType + ' Scale Limits' : 'Scale Limits')});

	//column headers
	injectDOM('tr', id+'columnHeadRow', id, {});
	injectDOM('td', id+'spacer', id+'columnHeadRow', {});
	injectDOM('td', id+'minHead', id+'columnHeadRow', {'innerHTML':'Min'});
	injectDOM('td', id+'maxHead', id+'columnHeadRow', {'innerHTML':'Max'});

	//meter types, one row for each:
	//HV
    injectDOM('tr', id+'HVRow', id, {});
    injectDOM('td', id+'HVTitle', id+'HVRow', {'style':'text-align:right;', 'innerHTML':'HV'});
    injectDOM('td', id+'HVminCell', id+'HVRow', {});
    injectDOM('td', id+'HVmaxCell', id+'HVRow', {});
    injectDOM('input', id+'HVmin', id+'HVminCell', {
    	'class':'minmaxCell', 
    	'type':'number', 
    	'value':0
    });
    document.getElementById(id+'HVmin').onchange = function(){document.getElementById(id+'HVmax').min = document.getElementById(id+'HVmin').valueAsNumber;}
    injectDOM('input', id+'HVmax', id+'HVmaxCell', {'class':'minmaxCell', 'type':'number', 'value':3000});
    injectDOM('td', id+'HVunitCell', id+'HVRow', {'style':'text-align:left'});
    injectDOM('p', id+'HVunit', id+'HVunitCell', {'style':'display:inline', 'innerHTML':'V'});

	//threshold
    injectDOM('tr', id+'thresholdRow', id, {});
    injectDOM('td', id+'thresholdTitle', id+'thresholdRow', {'style':'text-align:right;', 'innerHTML':'Threshold'});
    injectDOM('td', id+'thresholdMinCell', id+'thresholdRow', {});
    injectDOM('td', id+'thresholdMaxCell', id+'thresholdRow', {});
    injectDOM('input', id+'thresholdMin', id+'thresholdMinCell', {
    	'class':'minmaxCell', 
    	'type':'number', 
    	'value':0,
    	'min':0
    });
    document.getElementById(id+'thresholdMin').onchange = function(){document.getElementById(id+'thresholdMax').min = document.getElementById(id+'thresholdMin').valueAsNumber;}
    injectDOM('input', id+'thresholdMax', id+'thresholdMaxCell', {'class':'minmaxCell', 'type':'number', 'value':1000});
    injectDOM('td', id+'thresholdUnitCell', id+'thresholdRow', {'style':'text-align:left'});
    injectDOM('p', id+'thresholdUnit', id+'thresholdUnitCell', {'style':'display:inline', 'innerHTML':'ADC Units'});

	//rate	
    injectDOM('tr', id+'rateRow', id, {});
    injectDOM('td', id+'rateTitle', id+'rateRow', {'style':'text-align:right;', 'innerHTML':'Rate'});
    injectDOM('td', id+'rateMinCell', id+'rateRow', {});
    injectDOM('td', id+'rateMaxCell', id+'rateRow', {});
    injectDOM('input', id+'rateMin', id+'rateMinCell', {
    	'class':'minmaxCell', 
    	'type':'number', 
    	'value':0,
    	'min':0
    });
    document.getElementById(id+'rateMin').onchange = function(){document.getElementById(id+'rateMax').min = document.getElementById(id+'rateMin').valueAsNumber;};
    injectDOM('input', id+'rateMax', id+'rateMaxCell', {'class':'minmaxCell', 'type':'number', 'value':10000});
    injectDOM('td', id+'rateUnitCell', id+'rateRow', {'style':'text-align:left'});
    injectDOM('p', id+'rateUnit', id+'rateUnitCell', {'style':'display:inline;', 'innerHTML':'Hz'});

}









function thumbnail(canvasID, left, right, color, disabled){
	var canvas = document.getElementById(canvasID);
	var context = canvas.getContext('2d');

	imageObj = document.getElementById('logo')

	var width = canvas.width;
	var height = canvas.height;

	window.width = width;
	window.height = height;

	context.clearRect(0,0,width,height);
	context.lineWidth = 1;

	var title = '';

	context.strokeStyle = color;
	context.fillStyle = color;

	//GRIFFIN options
	if(left == 'US SCEPTAR' && right == 'DS SCEPTAR'){
		sceptar(context, width/3, height*0.4, height*0.2, disabled);
		sceptar(context, 2*width/3, height*0.4, height*0.2, disabled);
		title = 'USSC + DSSC';
	} else if(left == 'US SCEPTAR' && right == 'ZDS'){
		sceptar(context, width/3, height*0.4, height*0.2, disabled);
		zds(context, 2/3*width, 0.4*height, 0.18*height, disabled);
		title = 'USSC + ZDS';
	} else if(left == 'PACES' && right == 'DS SCEPTAR'){
		paces(context, width/3, height*0.4, height*0.15, height*0.05);
		sceptar(context, 2*width/3, height*0.4, height*0.2, disabled);
		title = 'PACES + SCEPTAR';
	} else if(left == 'PACES' && right == 'ZDS'){
		paces(context, width/3, height*0.4, height*0.15, height*0.05, disabled);
		zds(context, 2/3*width, 0.4*height, 0.18*height, disabled);
		title = 'PACES + ZDS';
	} else if(left == 'SPICE' && right == 'ZDS'){
		spice(context, width/3, height*0.4, height*0.2, disabled);
		zds(context, 2/3*width, 0.4*height, 0.18*height, disabled);
		title = 'SPICE + ZDS';
	} else if(left == 'SPICE' && right == 'DS SCEPTAR'){
		spice(context, width/3, height*0.4, height*0.2);
		sceptar(context, 2*width/3, height*0.4, height*0.2, disabled);
		title = 'SPICE + DSSC';
	} else if(left == 'GRIFFIN' && right == 'none'){
		griffin(context, width*0.5 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		title = 'GRIFFIN Standalone';	
	} else if(left == 'GRIFFIN' && right == 'DESCANT'){
		griffin(context, width*0.28 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		descant(context, width*0.68, height*0.4, height*0.1 )
		title = 'GRIFFIN + DESCANT'
	} else if(left == 'GRIFFIN' && right == 'DANTE'){
		griffin(context, width*0.3 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		dante(context, width*0.7, height*0.4, height*0.2, color);
		title = 'GRIFFIN + DANTE';
	} else if(left == 'GRIFFIN' && right == 'SPICE'){
		griffin(context, width*0.28 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		spice(context, width*0.68, height*0.4, height*0.2, disabled);
		title = 'GRIFFIN + SPICE';
	}

	//TIGRESS options
	if(left == 'BAMBINO' && right == 'none'){
		title = 'BAMBINO';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);	
	} else if(right == 'BAMBINO' && left == 'none'){
		title = 'DS BAMBINO';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);		
	} else if(left == 'BAMBINO' && right == 'BAMBINO'){
		title = 'US + DS BAMBINO';
		bambino(context, width*0.28, width*0.38, height/3, height*0.6, height*0.12);
		bambino(context, width*0.62, width*0.72, height/3, height*0.6, height*0.12);
	} else if(left == 'SHARC' && right == 'none'){
		title = 'SHARC';
		sharc(context, width/2, height*0.45, width*0.3, height*0.7, disabled);	
	} else if(left == 'SHARC' && right == 'services'){
		title = 'SHARC Services';
		sharc(context, width/2, height*0.45, width*0.3, height*0.7, disabled);	
	} else if(left == 'SPICE' && right == 'none'){
		spice(context, width*0.5, height*0.45, height*0.2, disabled);
		title = 'SPICE';
	} else if(left == 'SPICE' && right == 'services'){
		spice(context, width*0.5, height*0.45, height*0.2, disabled);
		title = 'SPICE Services';
	} else if(left == 'TIPwall' && right == 'none'){
		tipWall(context, width/2, height*0.45, height/2);
		title = 'TIP Wall';
	} else if(left == 'TIPball' && right == 'none'){
		tipBall(context, width/2, height/2, height*0.25);
		title = 'TIP Ball';
	} else if(left == 'TIGRESS' && right == 'none'){
		tigress(context, width/2, height*0.45, Math.round(height*0.25));
		title = 'TIGRESS';
	} else if(left == 'TIGRESS' && right == 'SHARC'){
		tigress(context, width*0.32, height*0.45, Math.round(height*0.25));
		sharc(context, width*0.7, height*0.45, width*0.3, height*0.7);
		title = 'TIGRESS + SHARC';
	} else if(left == 'TIGRESS' && right == 'DESCANT'){
		tigress(context, width*0.28, height*0.45, Math.round(height*0.25));
		descant(context, width*0.68,height*0.4, height*0.1 );
		title = 'TIGRESS + DESCANT';
	} else if(left == 'TIGRESS' && right == 'all'){
		tigress(context, width*0.2, height*0.45, Math.round(height*0.25));
		sharc(context, width*0.5, height*0.45, width*0.3, height*0.7);
		descant(context, width*0.8,height*0.4, height*0.1 );
		context.font = '14px Raleway';
		title = 'TIGRESS + SHARC + DESCANT';
	} else if(left == 'TIGRESS' && right == 'SPICE'){
		tigress(context, width*0.28, height*0.45, Math.round(height*0.25));
		spice(context, width*0.68, height*0.45, height*0.2, disabled);
		title = 'TIGRESS + SPICE';
	} else if(left == 'beamdump' && right == 'none'){
		beamdump(context, width/2, height*0.45, height*0.4)
		title = 'Beamdump Scintilator';
	}

	//standalone options
	if(left == 'HPGe' && right == 'none'){
		tigress(context, width/2, height*0.45, Math.round(height*0.25));
		title = 'HPGe';		
	} else if(left == 'DESCANT' && right=='none'){
		descant(context, width*0.5,height*0.4, height*0.1 );
		title = 'DESCANT';		
	} else if(left == 'PACES' && right=='none'){
		paces(context, width/2, height*0.4, height*0.15, height*0.05);
		title = 'PACES';
	} else if(left == 'DANTE' && right=='none'){
		dante(context, width*0.5, height*0.4, height*0.2, color);
		title = 'DANTE';
	} else if( (left == 'US SCEPTAR' || left == 'SCEPTAR') && right=='none'){
		sceptar(context, width/2, height*0.4, height*0.2, disabled);
		title = 'SCEPTAR';
	} else if(left == 'SPICE' && right=='none'){
		spice(context, width*0.5, height*0.45, height*0.2, disabled);
		title = 'SPICE';
	} else if(left == 'ZDS' && right=='none'){
		zds(context, 0.5*width, 0.4*height, 0.18*height);
		title = 'ZDS';
	} else if(left == 'BAMBINO' && right=='none'){
		title = 'BAMBINO';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);		
	} else if(left == 'S3' && right=='none'){
		title = 'S2 / S3';
		bambino(context, width*0.45, width*0.55, height/3, height*0.6, height*0.12);		
	} else if(left == 'TRIUMF' && right == 'none'){
		triumf(context, width*0.5 - imageObj.width/imageObj.height*context.canvas.height*0.6/2, height*0.1, color);
		title = 'Top Level Config';	
	} else if(left == 'HV' && right == 'none'){
		hv(context, width, height, color);
		title = 'High Voltage';
	}

	if(right != 'all') context.font = '16px Raleway';
	context.fillText(title, width/2 - context.measureText(title).width/2, 0.9*height);
}

//individual thumbnails////////////////////////////////////////////////////////////////////////////////

//draw a SCEPTAR wireframe on context centered at x0, y0.  size is the center to outer vertext distance. 
function sceptar(context, x0, y0, size, disabled){
	var i, side;
	side = size*Math.sqrt(2-2*Math.cos(72/180*Math.PI));
	smallSize = 0.5*size;
	smallSide = smallSize*Math.sqrt(2-2*Math.cos(72/180*Math.PI));
	context.save();
	context.translate(x0, y0);
	context.beginPath();
	context.rotate(54/180*Math.PI);
	for(i=0; i<5; i++){
		context.moveTo(0,0);
		context.lineTo(size, 0);
		context.lineTo(size - side*Math.cos(54/180*Math.PI), side*Math.sin(54/180*Math.PI) );
		context.stroke();
		context.moveTo(smallSize, 0);
		context.lineTo(smallSize - smallSide*Math.cos(54/180*Math.PI), smallSide*Math.sin(54/180*Math.PI) );
		context.stroke();
		context.rotate(72/180*Math.PI);
	}
	context.closePath();
	context.restore();

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

function zds(context, x0, y0, radius, disabled){
	context.beginPath();
	context.arc(x0, y0, radius, 0, 2*Math.PI);
	context.closePath();
	context.stroke();

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

//draw a PACES wireframe on context centered at x0, y0.  size is the array center to detector center distance, rad is the detector radius.
function paces(context, x0, y0, size, rad, disabled){
	var i;

	context.save();
	context.translate(x0, y0);
	context.rotate(54/180*Math.PI);
	for(i=0; i<5; i++){
		context.beginPath();
		context.arc(size, 0, rad, 0, 2*Math.PI);
		context.closePath();
		context.stroke();
		context.rotate(72/180*Math.PI);
	}
	context.restore();

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

function spice(context, x0, y0, rad, disabled){
	var i, innerRad, radStep;

	innerRad = 0.15*rad;
	radStep = (rad - innerRad)/3

	for(i=0; i<4; i++){
		context.beginPath();
		context.arc(x0, y0, innerRad+i*radStep, 0, 2*Math.PI);
		context.closePath();
		context.stroke();
	}

	for(i=0; i<8; i++){
		context.beginPath();
		context.moveTo(x0 + innerRad*Math.cos(Math.PI/4*i), y0 + innerRad*Math.sin(Math.PI/4*i));
		context.lineTo(x0 + rad*Math.cos(Math.PI/4*i), y0 + rad*Math.sin(Math.PI/4*i));
		context.closePath();
		context.stroke();
	}

	if(disabled)
		strikeOut(context, window.width, window.height, window.width/2, y0);
}

function descant(context, x0, y0, cellSize){
	var i, rad;

	//center to center distance of adjacent honeycomb cells:
	rad = 2*cellSize*Math.cos(30/180*Math.PI);

	regPoly(context, x0,y0, 6, cellSize);

	context.save();
	context.translate(x0, y0);
	for(i=0; i<6; i++){
		regPoly(context, 0, rad, 6, cellSize);
		context.rotate(60/180*Math.PI);
	}
	context.restore();
}

function dante(context, x0, y0, radius, color){
	var i;

	context.save();
	context.translate(x0,y0);
	context.rotate(Math.PI/8);
	context.beginPath();
	context.arc(0,0,radius, 0, 2*Math.PI);
	context.closePath();
	context.stroke();
	for(i=0; i<4; i++){
		context.beginPath();
		context.fillStyle = color;
		context.arc(radius, 0, radius*0.35, 0, 2*Math.PI);
		context.closePath();
		context.fill();
		context.beginPath();
		context.fillStyle = '#333333';
		context.arc(radius, 0, radius*0.3, 0, 2*Math.PI);
		context.closePath();
		context.fill();
		context.beginPath();
		context.fillStyle = color;
		context.arc(radius, 0, radius*0.2, 0, 2*Math.PI);
		context.closePath();
		context.fill();
		context.rotate(Math.PI/2);
	}
	context.restore();
}
function bambino(context, x0upper, x0lower, y0upper, y0lower, rad){
	var i, innerRad, radStep;

	innerRad = 0.15*rad;
	radStep = (rad - innerRad)/5

	for(i=0; i<6; i++){
		context.beginPath();
		context.arc(x0upper, y0upper, innerRad+i*radStep, 0, 2*Math.PI);
		context.closePath();
		context.stroke();

		if(i==0 || i==5){
			context.beginPath();
			context.arc(x0lower, y0lower, innerRad+i*radStep, 0, 2*Math.PI);
			context.closePath();
		}
		context.stroke();
	}

	for(i=0; i<12; i++){
		context.beginPath();
		context.moveTo(x0lower + innerRad*Math.cos(Math.PI/6*i), y0lower + innerRad*Math.sin(Math.PI/6*i));
		context.lineTo(x0lower + rad*Math.cos(Math.PI/6*i), y0lower + rad*Math.sin(Math.PI/6*i));
		context.closePath();
		context.stroke();		
	}
}

function sharc(context, x0, y0, width, height, disabled){
	context.save();
	context.translate(x0,y0);
	ellipse(context, 0, -0.35*height, 0.2*width, 0, Math.PI*2);
	ellipse(context, 0, 0.35*height, 0.2*width, 0, Math.PI*2);
	ellipse(context, 0, -0.35*height, 0.4/3*width, 0, Math.PI*2);
	ellipse(context, 0, 0.35*height, 0.4/3*width, 0, Math.PI*2);
	ellipse(context, 0, -0.35*height, 0.2/3*width, 0, Math.PI*2);
	ellipse(context, 0, 0.35*height, 0.2/3*width, 0, Math.PI*2);
	context.strokeRect(-width*0.2, -height*0.2, width*0.4, height*0.4);
	context.stroke();
	context.beginPath();
	context.moveTo(-width*0.2, 0);
	context.lineTo(width*0.2, 0);
	context.stroke();
	context.beginPath();
	context.moveTo(-width*0.4/6, -height*0.2);
	context.lineTo(-width*0.4/6, height*0.2);
	context.stroke();
	context.beginPath();
	context.moveTo(width*0.4/6, -height*0.2);
	context.lineTo(width*0.4/6, height*0.2);
	context.stroke();
	context.restore();

	if(disabled)
		strikeOut(context, window.width, window.height, x0, y0)
}

function tipWall(context, x0, y0, width){
		var i, cellSize, CsIx0, CsIy0;

		cellSize = width / 5;
		CsIx0 = x0-width/2;
		CsIy0 = y0-width/2;

    	for(i=0; i<25; i++){
            context.strokeRect(CsIx0 + cellSize*(i%5), CsIy0 + cellSize*Math.floor(i/5), cellSize, cellSize);
    	}
    	context.strokeRect(CsIx0, CsIy0, width, width)
}

function tipBall(context, x0, y0, rad){

	context.save();

	context.beginPath();
	context.arc(x0,y0,rad,0,Math.PI*2);
	context.clip();

	context.beginPath();
	context.lineWidth = 2;
	context.arc(x0,y0,rad-1,0,Math.PI*2);
	context.stroke();

	context.lineWidth=1;
	context.beginPath();
	context.arc(x0+20,y0,rad+10,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0-20,y0,rad+10,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0+20,rad+10,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0-20,rad+10,0,Math.PI*2);
	context.stroke();

	context.beginPath();
	context.arc(x0+40,y0,rad+20,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0-40,y0,rad+20,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0+40,rad+20,0,Math.PI*2);
	context.stroke();
	context.beginPath();
	context.arc(x0,y0-40,rad+20,0,Math.PI*2);
	context.stroke();

	context.beginPath();
	context.moveTo(x0-rad, y0);
	context.lineTo(x0+rad,y0);
	context.stroke;
	context.moveTo(x0, y0-rad);
	context.lineTo(x0, y0+rad);
	context.stroke();

	context.restore();

}

function griffin(context, x0, y0, color){
	if(color == '#999999')context.globalAlpha = 0.4;

    var imgObj = document.getElementById('logo')
    context.drawImage(imgObj, x0, y0, imgObj.width/imgObj.height*context.canvas.height*0.6, context.canvas.height*0.6);
	context.globalAlpha = 1;
}

function triumf(context, x0, y0, color){
	if(color == '#999999')context.globalAlpha = 0.4;
	context.drawImage(imageObj, x0, y0, imageObj.width/imageObj.height*context.canvas.height*0.6, context.canvas.height*0.6);
	context.globalAlpha = 1;
}

function tigress(context, x0, y0, size){
	var hpge = Math.round(size*0.3);
	var bgo = Math.round(size*0.75);

	context.save();
	context.translate(x0, y0);
	context.strokeRect(-size, -size, 2*size, 2*size);
	context.strokeRect(-bgo, -bgo, 2*bgo, 2*bgo);
	context.strokeRect(-hpge, -hpge, 2*hpge, 2*hpge );

	context.moveTo(-hpge, 0);
	context.lineTo(hpge, 0);
	context.moveTo(0, -hpge);
	context.lineTo(0, hpge);

	context.moveTo(0, -size);
	context.lineTo(0, -(size-hpge) - 2 );
	context.moveTo(0, size);
	context.lineTo(0, size-hpge + 2 );
	context.moveTo(-size, 0);
	context.lineTo(-(size-hpge) - 2, 0);
	context.moveTo(size, 0);
	context.lineTo(size-hpge + 2, 0);

	context.stroke();
	context.restore();
}

function beamdump(context, x0, y0, width){
	var i;

	context.save();
	context.translate(x0, y0);

	context.moveTo(width/2, -width/2);
	context.lineTo(width/2, width/2);
	context.moveTo(width*0.45, -width/2 );
	context.lineTo(width*0.45, width/2);

	for(i=0; i<10; i++){
		context.moveTo(width*0.45, width/2 - i*width/10);
		context.lineTo(width*0.5, width/2 - (i+1)*width/10)
	}

	context.fillRect(-width/2, -2, width*0.95, 4);

	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.4, 12);
	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.3, 20);
	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.4, -15);
	context.moveTo(width*0.45, 0);
	context.lineTo(width*0.1, -10)

	context.stroke();
	context.restore();

}

function hv(context, width, height, color){
	context.fillStyle = color;
	context.beginPath()
	context.moveTo(0.6*width, 0.2*height);
	context.lineTo(0.4*width, 0.475*height);
	context.lineTo(0.5*width, 0.475*height);
	context.lineTo(0.4*width, 0.7*height);
	context.lineTo(0.6*width, 0.425*height);
	context.lineTo(0.5*width, 0.425*height);
	context.closePath();
	context.fill()
}

//draws a regular polygon of n sides on context, centered at x0, y0 and with a center-vertext distance of size
function regPoly(context, x0, y0, n, size){
	var i;
	var stepAngle = 2*Math.PI/n;
	var jointAngle = (Math.PI-stepAngle)/2;
	var side = size*Math.sqrt(2-2*Math.cos(stepAngle));

	context.save();
	context.translate(x0, y0);
	context.beginPath();
	for(i=0; i<n; i++){
		context.moveTo(size, 0);
		context.lineTo(size - side*Math.cos(jointAngle), 0-side*Math.sin(jointAngle));
		context.stroke();
		context.rotate(stepAngle);
	}
	context.restore();
}

function strikeOut(context, width, height, x0, y0){

	context.save();
	context.beginPath()
	context.lineWidth = 5;
	context.strokeStyle = '#FF0000';
	context.moveTo(x0-width/4, y0-height/4);
	context.lineTo(x0+width/4, y0+height/4);
	context.stroke();
	context.moveTo(x0+width/4, y0-height/4);
	context.lineTo(x0-width/4, y0+height/4);
	context.stroke();
	context.restore();

}

function glowy(canvasID){
	var canvas = document.getElementById(canvasID);
	var context = canvas.getContext('2d');

	context.shadowOffsetX = 0;
	context.shadowOffsetY = 0;
	context.shadowBlur = 2;
	context.shadowColor = '#FFFFFF';
	thumbnail('Gcha5canv', 'SPICE', 'DSSC');
	context.fill();

}

//cycle badges/////////////////////////////////////////////////////
function clearScalars(context, height, width){
	context.fillStyle = '#999999';
	digitalDigit([1,1,1,1,1,1,0], context, height, 0.2*width, 0.05*height);
	digitalDigit([1,1,1,1,1,1,0], context, height, 0.65*width, 0.05*height);
}

function moveTape(context, width, height, x0, y0){
	var i,
		tapeTop = 0.1*height;
		tapeHeight = 0.6*height;
		holeSide = tapeHeight/10;
		holeSpacing = holeSide/2;

	context.fillStyle = '#999999';
	context.fillRect(0, tapeTop, width, tapeHeight);
	context.fillStyle = '#333333';
	for(i=0; i<20; i++){
		context.fillRect(i*(holeSpacing+holeSide), tapeTop+holeSpacing, holeSide, holeSide );
		context.fillRect(i*(holeSpacing+holeSide), tapeTop+tapeHeight - holeSpacing - holeSide, holeSide, holeSide );
	}
	roundBox(context, -0.1*width, tapeTop+2*holeSpacing+holeSide, 0.33*width, tapeHeight - 2*(2*holeSpacing+holeSide), 5);
	context.fill();
	roundBox(context, 0.25*width, tapeTop+2*holeSpacing+holeSide, 0.5*width, tapeHeight - 2*(2*holeSpacing+holeSide), 5);
	context.fill();
	roundBox(context, 0.77*width, tapeTop+2*holeSpacing+holeSide, 0.5*width, tapeHeight - 2*(2*holeSpacing+holeSide), 5);
	context.fill();

}

function beamOn(context, width, height, x0, y0){
	beamdump(context, x0, y0, width);
}

function triggersOn(context, width, height, x0, y0){
	//fingernail
	context.moveTo(width*0.5, height*0.3);
	context.quadraticCurveTo(width*0.52, height*0.32, width*0.6, height*0.35);
	context.quadraticCurveTo(width*0.52, height*0.37, width*0.5, height*0.3)

	//finger top
	context.moveTo(width*0.5, height*0.3);
	context.quadraticCurveTo(width*0.5*0.9, height*0.3*0.9, -2*width, -width);
	context.stroke();

	//finger bottom
	context.moveTo(width*0.6, height*0.35);
	context.quadraticCurveTo(width*0.55, height*0.6, -2*width, -width);
	context.stroke();

	//switch
	context.moveTo(0, height*0.7);
	context.lineTo(width, height*0.7);
	context.moveTo(0.3*width, height*0.7);
	context.lineTo(0.3*width, height*0.5);
	context.quadraticCurveTo(0.5*width, height*0.55, 0.7*width, height*0.5);
	context.lineTo(0.7*width, 0.7*height);

	//arrow
	context.moveTo(0.5*width, 0.6*height);
	context.lineTo(0.9*width, 0.6*height);
	context.lineTo(0.85*width, 0.55*height);
	context.moveTo(0.9*width, 0.6*height);
	context.lineTo(0.85*width, 0.65*height);


	context.stroke();
}

function syncClocks(context, width, height, x0, y0){
	var i;

	context.beginPath();
	context.arc(x0,y0, height*0.3, 0, Math.PI*2);
	context.stroke();
	context.closePath();

	context.save();
	context.translate(x0, y0);
	for(i=0; i<12; i++){
		context.moveTo(0, -height*0.3);
		context.lineTo(0, -height*0.3 +height*0.06);
		context.stroke();
		context.closePath();
		context.rotate(Math.PI/6);
	}

	context.moveTo(0, 0);
	context.lineTo(height*0.3*Math.cos(1.2*Math.PI), height*0.3*Math.sin(1.2*Math.PI));
	context.stroke();
	context.closePath();

	context.moveTo(0, 0);
	context.lineTo(height*0.15*Math.cos(4.3*Math.PI), height*0.15*Math.sin(4.3*Math.PI));
	context.stroke();
	context.closePath();	

	context.restore();
}

function wildcard(context, width, height, x0, y0){
	context.font = '100px Raleway';
	context.fillText('*', width/2-15, height);
	context.font = '16px Raleway';
}//generic function to execute the animation of some object <thing>, which has memeber function .draw which draws
//the thing only as a function of what frame the animation is on, and member data .duration, .FPS and .nFrames.
function animate(thing, frame){

    //clearTimeout(window.animateLoop);

    thing.draw(frame);
    if(frame < thing.nFrames){
        frame++;
        window.animateLoop = setTimeout(function(){animate(thing, frame)},thing.duration/thing.FPS*1000);
    }
}

//copy of animate, but for use on detail level view:  todo: combine with animate
function animateDetail(thing, frame){

    thing.drawDetail(thing.detailContext, frame);
    if(frame < thing.nFrames){
        frame++;
        window.transAnimateLoop = setTimeout(function(){animateDetail(thing, frame)},thing.duration/thing.FPS*1000);
    }
}

//styling functions to highlight / unhighlight submit button
function unhighlight(buttonID){
    clearTimeout(window.commitBlink);
    $('#'+buttonID).css('background-color', '#FFFFFF');
}

function highlight(buttonID){

    //$('#'+buttonID).css('background-color', '#FFFF00');
    clearTimeout(window.commitBlink);
    function blinkHighlight(color){
        $('#'+buttonID).css('background-color', color);

        if(color == '#FFFFFF') window.commitBlink = setTimeout(function(){blinkHighlight('#FFFF00')},1000);
        if(color == '#FFFF00') window.commitBlink = setTimeout(function(){blinkHighlight('#FFFFFF')},1000);
    }

    blinkHighlight('#FFFF00')


}

//insert something in the DOM
function insertDOM(element, id, classTag, style, wrapperID, onclick, content, name, type, value){
    var newElement = document.createElement(element);
    newElement.setAttribute('id', id);
    newElement.setAttribute('class', classTag);
    newElement.setAttribute('style', style);
    newElement.setAttribute('name', name);
    newElement.setAttribute('type', type);
    newElement.setAttribute('value', value);
    if(wrapperID == 'body')
        document.body.appendChild(newElement)
    else
        document.getElementById(wrapperID).appendChild(newElement);
    document.getElementById(id).innerHTML = content;
    document.getElementById(id).onclick = onclick;
}

//more flexible DOM injector; <properties> is an object containing property.value pairs for all properties to be set: 
function injectDOM(element, id, wrapperID, properties){
    var key, elt,
        newElement = document.createElement(element);
    //explicit ID
    newElement.setAttribute('id', id);
    //append to document:
    if(wrapperID == 'body')
        document.body.appendChild(newElement)
    else
        document.getElementById(wrapperID).appendChild(newElement);
    elt = document.getElementById(id);

    //some things need to be set specially:
    if(properties['innerHTML'] || properties['innerHTML'] === 0){
        elt.innerHTML = properties['innerHTML'];
        delete properties['innerHTML'];
    }
    if(properties['onclick']){
        elt.onclick = properties['onclick'];
        delete properties['onclick'];
    }
    //send in the clowns:
    for(key in properties){
        elt.setAttribute(key, properties[key]);
    }

}

//devName = device Name, scales = [ [scale title, parameter service minima, parameter service maxima, unit, ODBminpath, ODBmaxpath], ...]
function parameterDialogue(devName, scales, currentColorScale, noLog){
    var i, j, ODBpath;

    //insert div and title
    injectDOM('div', 'tempDiv', window.parameters.wrapper, {'class' : 'tempDialog'});
    var dialogue = document.getElementById('tempDiv');
    injectDOM('h2', 'dialogHeader', 'tempDiv', {
        'style' : 'position:relative; font:24px Orbitron; top:10px; margin-bottom:6%',
        'innerHTML' : 'Adjust '+devName+' Scale'
    });

    //fix dimensions
    var width = 0.35*window.innerWidth;
    $('#dialogHeader').width(width)

    //center dialogue
    $('#tempDiv').css('left', ($('#'+window.parameters.wrapper).width()/2 - width/2))

    //insert form fields
    injectDOM('form', 'dialogueValues', 'tempDiv', {});
    for(i=0; i<scales.length; i++){
        injectDOM('p', 'title'+i, 'dialogueValues', {'style':'font-size:16px; margin-top:3%;', 'innerHTML':scales[i][0]+'<br>'});
        injectDOM('p', 'minlabel'+i, 'dialogueValues', {'style':'display:inline', 'innerHTML':'Minimum: '});
        injectDOM('input', 'minfield'+i, 'dialogueValues', {
            'style' : 'display:inline;',
            'name' : 'textbox',
            'type' : 'number',
            'value' : scales[i][1],
            'size' : 6
        });
        injectDOM('p', 'minunit'+i, 'dialogueValues', {'style':'display:inline; margin-right:3%', 'innerHTML':scales[i][3]});
        injectDOM('p', 'maxlabel'+i, 'dialogueValues', {'style':'display:inline;', 'innerHTML':'Maximum: '});
        injectDOM('input', 'maxfield'+i, 'dialogueValues', {
            'style' : 'display:inline;',
            'name' : 'textbox',
            'type' : 'number',
            'value' : scales[i][2],
            'size' : 6
        });
        injectDOM('p', 'maxunit'+i, 'dialogueValues', {'style':'display:inline;', 'innerHTML':scales[i][3] + '<br>'});
        //don't allow min > max:
        document.getElementById('minfield'+i).onchange = function(){document.getElementById('maxfield'+this.id[8]).min = document.getElementById(this.id).valueAsNumber;};

    }

    //insert color scale picker:
    if(currentColorScale){
        injectDOM('p', 'colorPickerLabel', 'dialogueValues', {'style':'display:inline;', 'innerHTML':'<br><br>Palette: '})
        var colorScales = window.parameters.colorScale;
        injectDOM('select', 'colorOptions', 'dialogueValues', {});
        var colorDD = document.getElementById('colorOptions');
        var option = [];
        for(i=0; i<colorScales.length; i++){
            option[i] = document.createElement('option');
            option[i].text = colorScales[i];
            option[i].value = colorScales[i];
            colorDD.add(option[i], null);
        }
        colorDD.value = currentColorScale;
        injectDOM('br', 'break', 'dialogueValues', {});
    }

    //insert scale linear / log choice:
    if(!noLog){
        injectDOM('p', 'scalePickerLabel', 'dialogueValues', {'style':'display:inline; margin-right:2%', 'innerHTML':'<br><br>Scale: '});
        injectDOM('p', 'linearRadioLabel', 'dialogueValues', {'style':'display:inline', 'innerHTML':'Linear'});
        injectDOM('input', 'linearRadio', 'dialogueValues', {
            'style' : 'display:inline; margin-right:2%;',
            'name' : 'scaleSwitch',
            'type' : 'radio',
            'value' : 'linear'
        });
        injectDOM('p', 'logRadioLabel', 'dialogueValues', {'style':'display:inline', 'innerHTML':'Log'});
        injectDOM('input', 'logRadio', 'dialogueValues', {
            'style' : 'display:inline;',
            'name' : 'scaleSwitch',
            'type' : 'radio',
            'value' : 'log'
        });
        injectDOM('br', 'break', 'dialogueValues', {});

        if (window.parameters.detectorLogMode[window.viewState] == 1) document.getElementById('logRadio').checked = true;
        else document.getElementById('linearRadio').checked = true;
    }

    //insert submit & dismiss button
    injectDOM('input', 'updateParameters', 'dialogueValues', {
        'class' : 'bigButton',
        'style' : 'width:20%; margin-right:2%; margin-top:6%',
        'type' : 'button',
        'value' : 'Commit'
    });
    injectDOM('input', 'dismiss', 'dialogueValues', {
        'class' : 'bigButton',
        'style' : 'width:20%; margin-top:6%; margin-bottom:6%;',
        'type' : 'button',
        'value' : 'Dismiss'
    });

    document.getElementById('updateParameters').onclick = function(event){
        var i;
        if(document.getElementById('dialogueValues').checkValidity()){
            
            for(i=0; i<scales.length; i++){
                //commit
                scales[i][1] = parseFloat(document.getElementById('minfield'+i).value);
                scales[i][2] = parseFloat(document.getElementById('maxfield'+i).value);
                ODBSet(scales[i][4], scales[i][1]);
                ODBSet(scales[i][5], scales[i][2]);
            }
            fetchODB(); //pushes back to the parameter store

            if(currentColorScale){
                if(window.onDisplay.slice(0,3) == 'DAQ'){
                    window.DAQpointer.DAQcolor = window.parameters.colorScale.indexOf(colorDD.value);
                } else {
                    window.parameters.subdetectorColors[window.state.subdetectorView] = colorDD.value;
                }
            }

            if(!noLog){
                if(document.getElementById('logRadio').checked) window.parameters.detectorLogMode[window.viewState] = 1;
                else if(document.getElementById('linearRadio').checked) window.parameters.detectorLogMode[window.viewState] = 0;
            }

            //remove dialogue
            document.getElementById('tempDiv').style.opacity = 0;
            setTimeout(function(){
                var element = document.getElementById('tempDiv');
                element.parentNode.removeChild(element);            
            }, 500);

            rePaint();

        } else{
            alert("Something doesn't make sense.  Check fields for mistakes, highlighted in red.");
        }
    }

    document.getElementById('dismiss').onclick = function(event){
        document.getElementById('tempDiv').style.opacity = 0;
        setTimeout(function(){
            var element = document.getElementById('tempDiv');
            element.parentNode.removeChild(element);            
        }, 500);
    }

    //fade the div in:
    dialogue.style.opacity = 1
}

//help build the ODB path string for the above parameter dialogue:
function scaleType(){
    if (window.state.subdetectorView == 0) return 'HVscale';
    else if (window.state.subdetectorView == 1 || window.state.subdetectorView == 3) return 'thresholdScale';
    else if (window.state.subdetectorView == 2 || window.state.subdetectorView == 4) return 'rateScale';    
}

//Crockford's prototype magics:
function DCobject(o) {
    function F() {}
    F.prototype = o;
    return new F();
}


//return the biggest font size that fits a string into a given length in a given context:
function fitFont(context, string, length){
    var i, size = 1;
    context.font = size+'px Raleway';
    
    while(context.measureText(string).width < length){
        size++;
        context.font = size+'px Raleway';
    }
    
    return size-1;
}

//get the <tag> elements inside a given <parent> (for stripping the head out of the imported status page, since those objects currently have no id's :/ )
function getTag(tag, parentID){
    parent = document.getElementById(parentID);
    var descendants = parent.getElementsByTagName(tag);
    if ( descendants.length )
        return descendants;
    return null;
}

//generate a fake JSONP scalar post to use for offline development:
function fakeScalars(){
    
    var JSONP = {'scalar' : {} },
        key, subKey;


    for(key in ODB){
        if(ODB[key].deploy || ODB[key].USdeploy || ODB[key].DSdeploy){     
            for(subKey in window[key+'pointer'].dataBus[key]){
                JSONP.scalar[subKey] = {"TRIGREQ" : 1000*Math.random(), "dataRate" : 1000*Math.random()};
            }
        }
    }

    return JSONP;
    
}
//like fake scalars, but now thresholds:
function fakeThresholds(){

    var JSONP = {'parameters' : {'thresholds' : {} } },
        key, subKey;

    for(key in ODB){
        if(ODB[key].deploy || ODB[key].USdeploy || ODB[key].DSdeploy){
            for(subKey in window[key+'pointer'].dataBus[key] ){
                JSONP.parameters.thresholds[subKey] = 1000*Math.random();
            }
        }
    }

    return JSONP;

}

//take a standard object from datastructures and a frame, and determine the appropriate fill color:
function frameColor(obj, frame, nFrames){
    var oldKey, newKey;

    //pick the right keys
    if(window.state.subdetectorView == 0){
        if(obj.HV == 0xDEADBEEF) return 0xDEADBEEF;
        oldKey = 'oldHVcolor';
        newKey = 'HVcolor';
    } else if(window.state.subdetectorView == 1){
        if(obj.threshold == 0xDEADBEEF) return 0xDEADBEEF;
        oldKey = 'oldThresholdColor';
        newKey = 'thresholdColor';
    } else if(window.state.subdetectorView == 2){
        if(obj.rate == 0xDEADBEEF) return 0xDEADBEEF;
        oldKey = 'oldRateColor';
        newKey = 'rateColor';
    }

    return interpolateColor(parseHexColor(obj[oldKey]), parseHexColor(obj[newKey]), frame/nFrames);

}

//make a table for a tooltip using <objects> as rows and <keys> as columns, where the objects are keys of <data>, and insert it into DOM element <id>.  
//[split] indicates how many elements to put in each supercolumn:
function TTtable(id, data, objects, keys, rowTitles, tableTitle, titles, split){
    var i, j, k, n, nContentRows, cellContent;

    injectDOM('table', id+'table', id, {'class':'TTtab', 'style':'border-collapse:collapse'});
    injectDOM('colgroup', id+'colgroup', id+'table', {});
    for(i=0; i<split.length-1; i++){
        injectDOM('col', id+'colSpace'+i, id+'colgroup', {'span':keys.length+1});
        injectDOM('col', id+'col'+i, id+'colgroup', {'style':'border-left:1px solid white;', 'span':'1'});
    }


    if(tableTitle != ''){
        injectDOM('tr', id+'tableTitleRow', id+'table', {});
        injectDOM('td', id+'tableTitle', id+'tableTitleRow', {'innerHTML':tableTitle, 'colspan':(1+keys.length)*split.length});
    }

    injectDOM('tr', id+'tableHeaderRow', id+'table', {});
    for(k=0; k<split.length; k++){
        for(j=0; j<titles.length; j++){
            injectDOM('td', id+'headerCell'+j+'col'+k, id+'tableHeaderRow', {
                'style' : 'padding-left:'+( (j==0 && k!=0) ? 25:10 )+'px; padding-right:'+( (j==titles.length-1) ? 25:10 )+'px;',
                'innerHTML' : titles[j]
            });
        }
    }
    
    nContentRows = Math.max.apply(null, split);

    //build table:
    for(i=0; i<nContentRows; i++){
        //rows
        injectDOM('tr', id+'row'+i, id+'table', {});
        //cells
        for(j=0; j<titles.length*split.length; j++){
            injectDOM('td', id+'row'+i+'cell'+j, id+'row'+i, {
                'style' : 'padding:0px; padding-right:'+( (j%(titles.length+1)==0 && j!=0) ? 25:10 )+'px; padding-left:'+( (j%titles.length == 0 && j!=0) ? 25:10 )+'px'
            });
            //if(j%(keys.length+1)==keys.length && j!=titles.length*split.length-1 ){
            //    document.getElementById(id+'row'+i+'cell'+j).setAttribute('style', 'border-right:1px solid white');
            //}
        }
    }

    //fill table:
    n=0;

    for(i=0; i<split.length; i++){
        for(j=0; j<split[i]; j++){
            document.getElementById(id+'row'+j+'cell'+(titles.length*i)).innerHTML = rowTitles[n];
            for(k=0; k<keys.length; k++){

                if(typeof data[objects[n]][keys[k]] == 'string')
                    cellContent = data[objects[n]][keys[k]];
                else
                    cellContent = data[objects[n]][keys[k]].toFixed(window.parameters.tooltipPrecision);
                if(cellContent == 0xDEADBEEF) cellContent = '0xDEADBEEF'
                document.getElementById(id+'row'+j+'cell'+(1+titles.length*i+k)).innerHTML = cellContent;
            }
            n++;
        }
    }

}

//return an array with the appropriate colors chosen from <dataStore> (typically dataBus[this.name] for detectors) corresponding to the elements listed in [elements]
function colors(elements, dataStore, frame, nFrames){
    var i,
        colors=[];

    if(Array.isArray(elements)){
        for(i=0; i<elements.length; i++){
            colors[i] = viewMap(elements[i], dataStore, frame, nFrames);
        }
    } else {
        colors = viewMap(elements, dataStore, frame, nFrames);
    }

    function viewMap(elements, dataStore, frame, nFrames){
        if(window.state.subdetectorView == 0) return interpolateColor(parseHexColor(dataStore[elements].oldHVcolor), parseHexColor(dataStore[elements].HVcolor), frame/nFrames);
        else if(window.state.subdetectorView == 1 || window.state.subdetectorView == 3) return interpolateColor(parseHexColor(dataStore[elements].oldThresholdColor), parseHexColor(dataStore[elements].thresholdColor), frame/nFrames);
        else if(window.state.subdetectorView == 2 || window.state.subdetectorView == 4) return interpolateColor(parseHexColor(dataStore[elements].oldRateColor), parseHexColor(dataStore[elements].rateColor), frame/nFrames);        
    }

    return colors;
}

String.prototype.width = function(font) {
  var f = font || '12px arial',
      o = $('<div>' + this + '</div>')
            .css({'position': 'absolute', 'float': 'left', 'white-space': 'nowrap', 'visibility': 'hidden', 'font': f})
            .appendTo($('body')),
      w = o.width();

  o.remove();

  return w;
}

function arraySum(start, end) {
    var i, last, total = 0;

    (end == -1) ? last = this.length : end;

    for(i=start; i<end; i++){
        total += parseFloat(this[i]);
    }
    return total
}


function relMouseCoords(event){
    var totalOffsetX = 0,
    totalOffsetY = 0,
    canvasX = 0,
    canvasY = 0,
    currentElement = this,
    test = [],
    elts = [];

    if (event.offsetX !== undefined && event.offsetY !== undefined) { return {x:event.offsetX, y:event.offsetY}; }
    //if (event.layerX !== undefined && event.layerY !== undefined) { return {x:event.layerX, y:event.layerY}; }

    do{
        totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
        totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
        //test[test.length] = currentElement.offsetLeft - currentElement.scrollLeft
        //elts[elts.length] = currentElement
    }
    while(currentElement = currentElement.offsetParent)

    canvasX = event.pageX - totalOffsetX;
    canvasY = event.pageY - totalOffsetY;

    //hack to deal with FF scroll, better solution TBD:
    if(event.offsetX == undefined){
        canvasX -= document.body.scrollLeft;
        canvasY -= document.body.scrollTop;
    }

    return {x:canvasX, y:canvasY}
}
HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;

//generic confirmation dialog
function confirm(headline, detailText, confirmFunc){
    var i, j, ODBpath;

    //insert div and title
    injectDOM('div', 'tempDiv', 'body', {'class':'tempDialog'});
    var dialogue = document.getElementById('tempDiv');
    injectDOM('h2', 'dialogHeader', 'tempDiv', {
        'style' : 'position:relative; font:24px Orbitron; top:10px; margin:0px; margin-left:auto; margin-right:auto; padding:1em; padding-top:0;',
        'innerHTML' : headline
    })

    //warning text
    injectDOM('p', 'warning', 'tempDiv', {'style':'padding: 1em; margin:0px; font-size:120%;', 'innerHTML':detailText});

    //center dialogue
    var width = document.getElementById('tempDiv').offsetWidth;
    document.getElementById('tempDiv').style.left = document.body.offsetWidth/2 - width/2;

    //insert submit & abort button if there's a function to excecute on confirm, otherwise just an acknowledge button
    if(confirmFunc){
        injectDOM('input', 'confirmChoice', 'tempDiv', {
            'class' : 'standardButton',
            'style' : 'width:auto; height:auto; padding:0.5em; margin-left:0px',
            'type' : 'button',
            'value' : 'Confirm'
        });

        document.getElementById('confirmChoice').onclick = function(event){

            confirmFunc();

            document.getElementById('tempDiv').style.opacity = 0;
            setTimeout(function(){
                var element = document.getElementById('tempDiv');
                element.parentNode.removeChild(element);            
            }, 500);

            rePaint();
        }
    }

    injectDOM('input', 'abortChoice', 'tempDiv', {
        'class' : 'standardButton',
        'style' : 'width:auto; height:auto; padding:0.5em;',
        'type' : 'button',
        'value' : (confirmFunc == null) ? 'Dismiss' : 'Abort'
    });

    document.getElementById('abortChoice').onclick = function(event){
        document.getElementById('tempDiv').style.opacity = 0;
        setTimeout(function(){
            var element = document.getElementById('tempDiv');
            element.parentNode.removeChild(element);            
        }, 500);
    }

    //fade the div in:
    dialogue.style.opacity = 1
}

//define function to fetch from JSONP service
//for the scalar service (and anything with the same hierarchy):
function parseResponse(dataWeGotViaJsonp){
    var key, subkey;
    for(key in dataWeGotViaJsonp){
        if (dataWeGotViaJsonp.hasOwnProperty(key)) {
            window.JSONPstore[key] = {};
            for(subkey in dataWeGotViaJsonp[key]){
                if(dataWeGotViaJsonp[key].hasOwnProperty(subkey)){
                    window.JSONPstore[key][subkey.toUpperCase()] = dataWeGotViaJsonp[key][subkey];
                }
            }
        }
    }
}

//similar function for the threshold service:
function parseThreshold(data){
    var key;
    if(data['parameters']['thresholds']){
        window.JSONPstore['thresholds'] = {};
        //console.log(window.JSONPstore['thresholds'])
        for(key in data['parameters']['thresholds']){
            window.JSONPstore['thresholds'][key.toUpperCase().slice(0,10)] = data['parameters']['thresholds'][key];
        }
        //console.log(window.JSONPstore['thresholds'])
    }

    //console.log(data['parameters']['thresholds']['SPI00XN119'])
}

function deployFooter(){
    injectDOM('div', 'footer', 'body', {
        'innerHTML' : 'GRIFFIN 2013<br>GRIFFIN Collaboration Spokesperson: Adam Garnsworthy (garns@triumf.ca) - UI/UX Design & Web Development: Bill Mills (mills.wj@gmail.com)'
    });

}

//return the innerHTML of the option currently selected on select #dropID
function getDrop(dropID){
    var i, name,
        dropdown = document.getElementById(dropID),
        filterIndex = parseInt(dropdown.value, 10);

    for(i=0; i<dropdown.childNodes.length; i++){
        if(dropdown.childNodes[i].value == filterIndex){
            name = dropdown.childNodes[i].innerHTML;
        }            
    }

    return name;
}

//convert n to hex, and represent it with at least d digits (left 0s for padding) and a '0x' prefix:
function hexString(n, d){
    var result = n.toString(16);

    while(result.length < d){
        result = '0' + result;
    }
    return '0x' + result.toUpperCase();
}

//delete a dom element by ID
function deleteDOM(id){
    var element = document.getElementById(id);
    element.parentNode.removeChild(element);
};

//return the value of a selected option from a <select> element
function selected(selectID){
    var select = document.getElementById(selectID),
        value = select.options[select.selectedIndex].value;

    return value;
}
